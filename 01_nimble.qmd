---
title: "Introduction to `nimble`"
format: 
  html:
    toc: true
    toc-location: right
author:
  - Baptiste Alglave
  - Julien Chiquet
  - Pierre Gloaguen
  - Emily Walker
editor_options: 
  chunk_output_type: console
---

# Required packages for this tutorial {.unnumbered}

```{r}
#| label: packages_nimble_section
#| warning: false
#| message: false
#| cache: false
library(nimble)
library(nimbleHMC)
library(tidyverse)
library(ggmcmc)
```



# Short presentation of `nimble`

First, a very good reference: https://r-nimble.org/html_manual/cha-welcome-nimble.html

The `nimble` package is:

- A system for writing statistical models flexibly (based on bugs).
- A library of inference algorithms (MCMC, Laplace approximation).
- A compiler that generates and compiles C++ for your models and algorithms without knowing it is C++.

There is a `nimble` language with the basics for building statistical models (e.g. the key probability distributions, some key transformation functions).

But, this remains limited and to have full flexibility, ones need to build its own functions, which can be very challenging. 

# Fitting a model in a bayesian framework with nimble

## Toy model

We observe a sample $Y_1,\dots, Y_n$ of i.i.d. random variables having a negative binomial distribution with parameter $p \in [0, 1]$ and $\theta \in \mathbb{R}_+^*$.
Formally, for $i \in \lbrace 1,\dots, n\rbrace$, and $k \in \mathbb{N}$, we have that:
$$
\mathbb{P}\left(Y_i = k \vert p, \theta\right) = \frac{\Gamma(k + \theta)}{k!\Gamma(\theta)}p^\theta(1 - p)^k\,.

$$
Let's simulate data from this model with $n = 100, p = 0.4$ and $\theta = 12$:
```{r}
#| label: example1_data
set.seed(123) #Â For reproducibility
data_ex1 <- rnbinom(n = 100, prob = 0.4, size = 12)
```

Our goal is to estimate $p$ and $\theta$ from these observations, within a Bayesian framework.
For this tutorial, we assume the following priors:
\begin{align*}
\theta &\sim \mathcal{E}(0.1)\,,\\
p &\sim \mathcal{U}\left[0, 1\right]\.
\end{align*}

## Defining a negative binomial model in `nimble`

Basically, as in `BUGS`or `JAGS`, the user's role is to write the way to simulate the data and to give the prior distributions of the unkown. This is done within the `nimbleCode` function.
This function will typically need to use built-in distributions that can be seen in the native documentation. 
All random variables must be assigned using the `~` symbol while deterministic quantities are assigned using the `<-` or `=` as in `R`. 
Overall, the syntax is quite similar to `R`.

```{r}
#| label: code_neg_bin
code_neg_bin <- nimbleCode({
  # Observation model
  for(i in 1:n){# n is never defined before, it will be a constant
    y[i] ~ dnbinom(prob, theta)
  }
  # PRIORS
  prob ~ dunif(0, 1)
  theta ~ dexp(0.1)
})
```

Note that in this code, nothing distinguishes observed data from unknown (or latent variables).
The order of lines has no importance as everything will be compiled afterwards.

## Defining the nimble model

Now that the code exists, we define the model. That's here that data and constants will be provided.
Typically, data are quantities which are considered as realizations of random variables in the code, while constants are not. 

```{r}
#| label: model_neg_bin
model_neg_bin <- nimbleModel(code = code_neg_bin, 
                             name = "Negative binomial", 
                             constants = list(n = length(data_ex1)),
                             data = list(y = data_ex1))
```

Note that the code points that we did not give initial guesses (which would typically be starting points for MCMC sampling algorithms). 
We will do it in the sampling step.

## Basic MCMC sampling

A direct way to proceed is to use the `nimbleMCMC` function that provides basic Metropolis Hastings within Gibbs sampling.

```{r}
#| label: posterior_sampling_neg_bin
#| cache: true
posterior_samples_neg_bin <- nimbleMCMC(model_neg_bin,
                                        inits = list(prob = 0.5, theta = 1),
                                        nchains = 2, # Number of independent chains 
                                        niter = 10000, # Number of it. per chain
                                        thin = 10, # Thinning
                                        nburnin = 1000) # Number of initial iterations discarded
```

## Exploring the results

Now that we have performed MCMC sampling, we can access the results, which are lists (one element per chain) of matrices having $n_{\text{iter}}$ rows and $n_{\text{parameters}}$ columns.

```{r}
#| label: str_posterior_samples
str(posterior_samples_neg_bin)
```

To perform any post processing or plotting results, a bit of formatting must be done.

```{r}
#| label: custom_formatted_results
formatted_results <- imap_dfr(posterior_samples_neg_bin, 
                              function(x, nm){
                                as.data.frame(x) %>% 
                                  rowid_to_column(var = "Iteration") %>% 
                                  mutate(Chain = str_remove(nm, "chain"))
                              }) %>% 
  pivot_longer(cols = -c("Iteration", "Chain"),
               names_to = "Parameter", 
               values_to = "value")
```

We can then perform usual plots.

```{r}
#| label: plot
ggplot(formatted_results) +
  aes(x = Iteration,
      y = value, color = Chain) +
  facet_wrap(~Parameter, scales = "free") +
  geom_line() +
  labs(x = "Sample ID", y = "Parameter value", color = "")
```

### Package for automatic formatting of results

For `ggplot`users, the `ggmcmc` package provide useful tools for plots and formatting of MCMC outputs in `R` (not necessarily for the `nimble` package).
This package is suited for any `coda` object, which is an historic format for MCMC outputs in `R`. 
We can specify during the sampling that we want outputs to be in `coda`.

```{r}
#| label: posterior_samples_coda
#| cache: true
posterior_samples_neg_bin <- nimbleMCMC(model_neg_bin, 
                                        nchains = 2, 
                                        niter = 10000, 
                                        thin = 10, 
                                        nburnin = 1000,
                                        samplesAsCodaMCMC = TRUE)
```


We can see that this modifies the type of output:

```{r}
#| label: str_posterior_samples_coda
str(posterior_samples_neg_bin)
```

Now, we can use the `ggs`function which performs the post processing that we made above.

```{r}
#| label: coda_formatted_results
formatted_results <- ggs(posterior_samples_neg_bin)
formatted_results # same as above
```

Then, everything works as before!.

## Defining a `nimbleFunction`

What makes `nimble`'s popularity is it suitability for statistical programming.

As your specific model will certainly requires specific functions, we cannot expect to find all our tools in the built-in function.

However, we can define new functions in a syntax which is pretty similar to `R`.

### Alternative parameterization of the negative binomial

Suppose now we want to perform negative binomial regression.
In this context, we model the expectation (typically through a link to some covariates) of the response variable.
Typically, if we denote, for all $1\leq i \leq n$, $\mu = \mathbb{E}\left[Y_i\right]$, we assume the following prior:

$$
\ln \mu \sim \mathcal{N}\left(0, 1\right)\,.
$$
Sadly, in `nimble`, we do not have access to an implementation of the negative binomial distribution parameterized by $(\mu,  \theta)$.
However, we know that:
$$
\mu = \theta \times \frac{1 - p}{p}\,,
$$
or, equivalently, that:
$$
p = \frac{\theta}{\theta + \mu}
$$
```{r}
#| label: get_p_from_mu
get_p_from_mu <- nimbleFunction(
  run = function(mu = double(0),
                 theta = double(0)) { # type declarations
    returnType(double(0))  # return type declaration
    output <- theta / (theta + mu)
    return(output)
  })
get_p_from_mu(18, 12) # Works as a usual R function
```

```{r}
#| label: code_neg_bin_alternatif
#| cache: true
code_alternatif <- nimbleCode({
  # Observation model
  for(i in 1:n){# n is never defined before, it will be a constant
    y[i] ~ dnbinom(prob, theta)
  }
  # Alternative vectorized formulation 
  # y[1:n] ~ dnbinom(prob, theta)
  # PRIORS
  log_mu ~ dnorm(0, 1)
  theta ~ dexp(0.1)
  # Quantites deterministes
  mu <- exp(log_mu)
  prob <- get_p_from_mu(mu = mu, theta = theta)
})

model_alternatif <- nimbleModel(code = code_alternatif, 
                                name = "Alternative negative binomial", 
                                constants = list(n = length(data_ex1)),
                                data = list(y = data_ex1),
                                inits = list(mu = 0.5, theta = 1))

posterior_samples_alternatif <- nimbleMCMC(model_alternatif, 
                                           nchains = 2, 
                                           niter = 10000, 
                                           thin = 10, 
                                           nburnin = 1000,
                                           monitors = c("prob", "theta"),
                                           samplesAsCodaMCMC = TRUE)
```

## Defining new distribution

An alternative is to define a new distribution.

```{r}
#| label: dmynegbin
dmynegbin <- nimbleFunction(
  run = function(x = double(0), 
                 mu = double(0),
                 theta = double(0),
                 log = integer(0, default = 0)) {
    returnType(double(0))
    prob = get_p_from_mu(mu, theta)
    output <- dnbinom(x, size = theta, prob = prob, log = log)
    return(output)
  })
registerDistributions(list(
  dmynegbin = list(BUGSdist = "dmynegbin(mu, theta)",
                   discrete = TRUE, pqAvail = FALSE)
))
```

```{r}
code_with_my_dist <- nimbleCode({
  # Observation model
  for(i in 1:n){# n is never defined before, it will be a constant
    y[i] ~ dmynegbin(mu, theta) # my distribution
  }
  # PRIORS
  log_mu ~ dnorm(0, 1)
  mu <- exp(log_mu)
  theta ~ dexp(0.1)
})

model_with_my_dist <- nimbleModel(code = code_with_my_dist, 
                                  name = "Alternative negative binomial", 
                                  constants = list(n = length(data_ex1)),
                                  data = list(y = data_ex1),
                                  inits = list(log_mu = 0.5, theta = 1))

compileNimble(model_with_my_dist)
posterior_samples_alternatif <- nimbleMCMC(model_with_my_dist, 
                                           nchains = 2, 
                                           niter = 10000, 
                                           thin = 10, 
                                           nburnin = 1000, 
                                           monitors = c("mu", "theta"),
                                           samplesAsCodaMCMC = TRUE)
```


```{r}
posterior_samples_alternatif %>% 
  ggs() %>% 
  ggplot() +
  aes(x = Iteration,
      y = value, color = factor(Chain)) +
  facet_wrap(~Parameter, scales = "free") +
  geom_line() +
  labs(x = "Iteration", y = "Parameter value", color = "")
```


## Alternative MCMC sampler

One big strength of `nimble` are the several samplers that are available in the package.

## Conjuguate priors

First, nimble is able to identify conjugate priors and make the exact computation of the posterior [link](https://r-nimble.org/html_manual/cha-mcmc.html#conjugate-gibbs-samplers).

## HMC algorithm

`nimble` provides support for Hamiltonian Monte Carlo (HMC) and compute the derivatives of the likelihood through automatic differentiation. The `nimbleHMC` package implement two versions of No-U-Turn (NUTS) HMC sampling: the standard one developed in Hoffman and Gelman ([link](https://jmlr.org/papers/volume15/hoffman14a/hoffman14a.pdf)) and an updated one with improved adaptation routines and convergence criteria, which matches the HMC sampler of `STAN`.

In order to allow an algorithm to use AD for a specific model, that model must be created with `buildDerivs = TRUE`.

# ```{r}
# # Build model with nimble
# model_neg_bin_HMC <- nimbleModel(code = code_neg_bin, 
#                                  name = "Negative binomial", 
#                                  constants = list(n = length(data_ex1)),
#                                  data = list(y = data_ex1),
#                                  inits = list(prob = 0.5, theta = 1),
#                                  calculate = FALSE, 
#                                  buildDerivs = TRUE) # This is the line required for running HMC
# 
# # Build the MCMC algorithm which applies HMC sampling
# HMC <- buildHMC(model_neg_bin_HMC)
# 
# # Careful here, when the model has random effects
# # HMC requires to set values in the model before running the algorithm
# # One solution is to simulate with the model and set the model with these values
# # See : https://r-nimble.org/html_manual/cha-mcmc.html#subsec:HMC-example
# # Here, as the model is simple, there is no need for this and everything is handled withing nimble/nimbleHMC
# 
# ## Then everything is standard in nimble
# CHMC <- compileNimble(HMC) # Compile the model/algo
# samples <- runMCMC(CHMC, niter = 1000, nburnin = 500) # Short run for illustration
# summary(coda::as.mcmc(samples)) # Summary of the estimates
# ```

And there are plenty of others samplers:

- Particle filters / sequential Monte Carlo and iterated filtering (package `nimbleSMC`)

- Monte Carlo Expectation Maximization (MCEM)

- Laplace approximation and adaptive Gauss-Hermite quadrature

