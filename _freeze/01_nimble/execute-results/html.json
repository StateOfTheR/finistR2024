{
  "hash": "ba8107cb728554e2825b4f2fa3ebfd7b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to `nimble`\"\nformat: \n  html:\n    toc: true\n    toc-location: right\nauthor:\n  - Baptiste Alglave\n  - Julien Chiquet\n  - Pierre Gloaguen\n  - Emily Walker\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n\n# Required packages for this tutorial {.unnumbered}\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(compareMCMCs)\nlibrary(ggmcmc)\nlibrary(mvtnorm)\nlibrary(nimble)\nlibrary(nimbleHMC)\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n\n\n# Short presentation of `nimble`\n\nFirst, a very good reference: https://r-nimble.org/html_manual/cha-welcome-nimble.html\n\nThe `nimble` package is:\n\n- A system for writing statistical models flexibly (based on `bugs` and `jags`).\n- A library of inference algorithms (MCMC, HMC, Laplace approximation).\n- A compiler that generates and compiles C++ for your models and algorithms without knowing it is C++.\n\nThere is a `nimble` language with the basics for building statistical models (e.g. the key probability distributions, some key transformation functions).\n\nBut, this remains limited and to have full flexibility, ones need to build its own functions, which **can be very challenging**. \n\n# Fitting a model in a bayesian framework with nimble\n\n## Toy model\n\nWe observe a sample $Y_1,\\dots, Y_n$ of i.i.d. random variables having a negative binomial distribution with parameter $p \\in [0, 1]$ and $\\theta \\in \\mathbb{R}_+^*$.\nFormally, for $i \\in \\lbrace 1,\\dots, n\\rbrace$, and $k \\in \\mathbb{N}$, we have that:\n\n$$\n\\mathbb{P}\\left(Y_i = k \\vert p, \\theta\\right) = \\frac{\\Gamma(k + \\theta)}{k!\\Gamma(\\theta)}p^\\theta(1 - p)^k\\,.\n$$\n\nLet's simulate data from this model with $n = 100, p = 0.4$ and $\\theta = 12$:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123) #Â For reproducibility\ndata_ex1 <- rnbinom(n = 100, prob = 0.4, size = 12)\n```\n:::\n\n\n\n\nOur goal is to estimate $p$ and $\\theta$ from these observations, within a Bayesian framework.\nFor this tutorial, we assume the following priors:\n\\begin{align*}\n\\theta &\\sim \\mathcal{E}(0.1)\\,,\\\\\np &\\sim \\mathcal{U}\\left[0, 1\\right]\\,.\\\\\n\\end{align*}\n\n## Defining a negative binomial model in `nimble`\n\nBasically, as in `BUGS`or `JAGS`, the user's role is to write the way to simulate the data and to give the prior distributions of the unkown. This is done within the `nimbleCode` function.\nThis function will typically need to use built-in distributions that can be seen in the native documentation. \nAll random variables must be assigned using the `~` symbol while deterministic quantities are assigned using the `<-` or `=` as in `R`. \nOverall, the syntax is quite similar to `R`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode_neg_bin <- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # PRIORS\n  prob ~ dunif(0, 1)\n  theta ~ dexp(0.1)\n})\n```\n:::\n\n\n\n\nNote that in this code, nothing distinguishes observed data from unknown (or latent variables).\nThe order of lines has no importance as everything will be compiled afterwards.\n\n## Defining the nimble model\n\nNow that the code exists, we define the model. That's here that data and constants will be provided.\nTypically, data are quantities which are considered as realizations of random variables in the code, while constants are not. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_neg_bin <- nimbleModel(code = code_neg_bin, \n                             name = \"Negative binomial\", \n                             constants = list(n = length(data_ex1)),\n                             data = list(y = data_ex1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n```\n\n\n:::\n:::\n\n\n\n\nNote that the code points that we did not give initial guesses (which would typically be starting points for MCMC sampling algorithms). \nWe will do it in the sampling step.\n\n## Basic MCMC sampling\n\nA direct way to proceed is to use the `nimbleMCMC` function that provides basic Metropolis Hastings within Gibbs sampling.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior_samples_neg_bin <- nimbleMCMC(model_neg_bin,\n                                        inits = list(prob = 0.5, theta = 1),\n                                        nchains = 2, # Number of independent chains \n                                        niter = 10000, # Number of it. per chain\n                                        thin = 10, # Thinning\n                                        nburnin = 1000) # Number of initial iterations discarded\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n\n\n\n## Exploring the results\n\nNow that we have performed MCMC sampling, we can access the results, which are lists (one element per chain) of matrices having $n_{\\text{iter}}$ rows and $n_{\\text{parameters}}$ columns.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(posterior_samples_neg_bin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ chain1: num [1:900, 1:2] 0.334 0.328 0.333 0.334 0.315 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n $ chain2: num [1:900, 1:2] 0.343 0.363 0.379 0.336 0.352 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n```\n\n\n:::\n:::\n\n\n\n\nTo perform any post processing or plotting results, a bit of formatting must be done.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformatted_results <- imap_dfr(posterior_samples_neg_bin, \n                              function(x, nm){\n                                as.data.frame(x) %>% \n                                  rowid_to_column(var = \"Iteration\") %>% \n                                  mutate(Chain = str_remove(nm, \"chain\"))\n                              }) %>% \n  pivot_longer(cols = -c(\"Iteration\", \"Chain\"),\n               names_to = \"Parameter\", \n               values_to = \"value\")\n```\n:::\n\n\n\n\nWe can then perform usual plots.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(formatted_results) +\n  aes(x = Iteration,\n      y = value, color = Chain) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Sample ID\", y = \"Parameter value\", color = \"\")\n```\n\n::: {.cell-output-display}\n![](01_nimble_files/figure-html/plot-1.png){width=672}\n:::\n:::\n\n\n\n\n### Package for automatic formatting of results\n\nFor `ggplot`users, the `ggmcmc` package provide useful tools for plots and formatting of MCMC outputs in `R` (not necessarily for the `nimble` package).\nThis package is suited for any `coda` object, which is an historic format for MCMC outputs in `R`. \nWe can specify during the sampling that we want outputs to be in `coda`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior_samples_neg_bin <- nimbleMCMC(model_neg_bin, \n                                        nchains = 2, \n                                        niter = 10000, \n                                        thin = 10, \n                                        nburnin = 1000,\n                                        samplesAsCodaMCMC = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n\n\n\n\nWe can see that this modifies the type of output:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(posterior_samples_neg_bin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ chain1: 'mcmc' num [1:900, 1:2] 0.286 0.31 0.301 0.304 0.348 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n $ chain2: 'mcmc' num [1:900, 1:2] 0.398 0.412 0.419 0.429 0.433 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n - attr(*, \"class\")= chr \"mcmc.list\"\n```\n\n\n:::\n:::\n\n\n\n\nNow, we can use the `ggs`function which performs the post processing that we made above.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformatted_results <- ggs(posterior_samples_neg_bin)\nformatted_results # same as above\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,600 Ã 4\n   Iteration Chain Parameter value\n       <int> <int> <fct>     <dbl>\n 1         1     1 prob      0.286\n 2         2     1 prob      0.310\n 3         3     1 prob      0.301\n 4         4     1 prob      0.304\n 5         5     1 prob      0.348\n 6         6     1 prob      0.325\n 7         7     1 prob      0.308\n 8         8     1 prob      0.346\n 9         9     1 prob      0.358\n10        10     1 prob      0.383\n# â¹ 3,590 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThen, everything works as before!.\n\n## Defining a `nimbleFunction`\n\nWhat makes `nimble`'s popularity is it suitability for statistical programming.\n\nAs your specific model will certainly requires specific functions, we cannot expect to find all our tools in the built-in function.\n\nHowever, we can define new functions in a syntax which is pretty similar to `R`.\n\n### Alternative parameterization of the negative binomial\n\nSuppose now we want to perform negative binomial regression.\nIn this context, we model the expectation (typically through a link to some covariates) of the response variable.\nTypically, if we denote, for all $1\\leq i \\leq n$, $\\mu = \\mathbb{E}\\left[Y_i\\right]$, we assume the following prior:\n\n$$\n\\ln \\mu \\sim \\mathcal{N}\\left(0, 1\\right)\\,.\n$$\nSadly, in `nimble`, we do not have access to an implementation of the negative binomial distribution parameterized by $(\\mu,  \\theta)$.\nHowever, we know that:\n$$\n\\mu = \\theta \\times \\frac{1 - p}{p}\\,,\n$$\nor, equivalently, that:\n$$\np = \\frac{\\theta}{\\theta + \\mu}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_p_from_mu <- nimbleFunction(\n  run = function(mu = double(0),\n                 theta = double(0)) { # type declarations\n    returnType(double(0))  # return type declaration\n    output <- theta / (theta + mu)\n    return(output)\n  })\nget_p_from_mu(18, 12) # Works as a usual R function\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncode_alternatif <- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # Alternative vectorized formulation \n  # y[1:n] ~ dnbinom(prob, theta)\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  theta ~ dexp(0.1)\n  # Quantites deterministes\n  mu <- exp(log_mu)\n  prob <- get_p_from_mu(mu = mu, theta = theta)\n})\n\nmodel_alternatif <- nimbleModel(code = code_alternatif, \n                                name = \"Alternative negative binomial\", \n                                constants = list(n = length(data_ex1)),\n                                data = list(y = data_ex1),\n                                inits = list(mu = 0.5, theta = 1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n```\n\n\n:::\n\n```{.r .cell-code}\nposterior_samples_alternatif <- nimbleMCMC(model_alternatif, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000,\n                                           monitors = c(\"prob\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n\n\n\n## Defining new distribution\n\nAn alternative is to define a new distribution.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmynegbin <- nimbleFunction(\n  run = function(x = double(0), \n                 mu = double(0),\n                 theta = double(0),\n                 log = integer(0, default = 0)) {\n    returnType(double(0))\n    prob = get_p_from_mu(mu, theta)\n    output <- dnbinom(x, size = theta, prob = prob, log = log)\n    return(output)\n  })\nregisterDistributions(list(\n  dmynegbin = list(BUGSdist = \"dmynegbin(mu, theta)\",\n                   discrete = TRUE, pqAvail = FALSE)\n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Warning] Random generation function for dmynegbin is not available. NIMBLE is generating a placeholder function, rmynegbin, that will invoke an error if an algorithm needs to simulate from this distribution. Some algorithms (such as random-walk Metropolis MCMC sampling) will work without the ability to simulate from the distribution.  If simulation is needed, provide a nimbleFunction (with no setup code) to do it.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncode_with_my_dist <- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dmynegbin(mu, theta) # my distribution\n  }\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  mu <- exp(log_mu)\n  theta ~ dexp(0.1)\n})\n\nmodel_with_my_dist <- nimbleModel(code = code_with_my_dist, \n                                  name = \"Alternative negative binomial\", \n                                  constants = list(n = length(data_ex1)),\n                                  data = list(y = data_ex1),\n                                  inits = list(log_mu = 0.5, theta = 1))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n```{.r .cell-code}\ncompileNimble(model_with_my_dist)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDerived CmodelBaseClass created by buildModelInterface for model Alternative negative binomial\n```\n\n\n:::\n\n```{.r .cell-code}\nposterior_samples_alternatif <- nimbleMCMC(model_with_my_dist, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000, \n                                           monitors = c(\"mu\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nposterior_samples_alternatif %>% \n  ggs() %>% \n  ggplot() +\n  aes(x = Iteration,\n      y = value, color = factor(Chain)) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Iteration\", y = \"Parameter value\", color = \"\")\n```\n\n::: {.cell-output-display}\n![](01_nimble_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Alternative MCMC sampler\n\nOne big strength of `nimble` are the several samplers that are available in the package.\n\n## Conjuguate priors\n\nFirst, nimble is able to identify conjugate priors and make the exact computation of the posterior [link](https://r-nimble.org/html_manual/cha-mcmc.html#conjugate-gibbs-samplers).\n\n## HMC algorithm\n\n`nimble` provides support for Hamiltonian Monte Carlo (HMC) and compute the derivatives of the likelihood through automatic differentiation. The `nimbleHMC` package implement two versions of No-U-Turn (NUTS) HMC sampling: the standard one developed in Hoffman and Gelman ([link](https://jmlr.org/papers/volume15/hoffman14a/hoffman14a.pdf)) and an updated one with improved adaptation routines and convergence criteria, which matches the HMC sampler of `STAN`.\n\nIn order to allow an algorithm to use AD for a specific model, that model must be created with `buildDerivs = TRUE`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Build model with nimble\nmodel_neg_bin_HMC <- nimbleModel(code = code_neg_bin, \n                                 name = \"Negative binomial\", \n                                 constants = list(n = length(data_ex1)),\n                                 data = list(y = data_ex1),\n                                 inits = list(prob = 0.5, theta = 1),\n                                 calculate = FALSE, buildDerivs = TRUE) # This is the line required for running HMC\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n```{.r .cell-code}\nC_model_neg_bin_HMC <- compileNimble(model_neg_bin_HMC) # Compile the model (they require this for the compilation of the HMC object)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Build the MCMC algorithm which applies HMC sampling\nHMC <- buildHMC(C_model_neg_bin_HMC)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nNUTS sampler (1)\n  - prob, theta \n```\n\n\n:::\n\n```{.r .cell-code}\n# Careful here, when the model has random effects\n# HMC requires to set values in the model before running the algorithm\n# One solution is to simulate with the model and set the model with these values\n# See : https://r-nimble.org/html_manual/cha-mcmc.html#subsec:HMC-example\n# Here, as the model is simple, there is no need for this and everything is handled withing nimble/nimbleHMC\n\n## Then everything is standard in nimble\nCHMC <- compileNimble(HMC) # Compile the HMC model/algo\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\nsamples <- runMCMC(CHMC, niter = 1000, nburnin = 500) # Short run for illustration\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [Note] NUTS sampler (nodes: prob, theta) is using 500 warmup iterations.\n         Since `warmupMode` is 'default' and `nburnin` > 0,\n         the number of warmup iterations is equal to `nburnin`.\n         The burnin samples will be discarded, and all samples returned will be post-warmup.\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(coda::as.mcmc(samples)) # Summary of the estimates\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nIterations = 1:500\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 500 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n         Mean      SD Naive SE Time-series SE\nprob   0.3868 0.05279 0.002361       0.006271\ntheta 11.7050 2.65299 0.118645       0.356911\n\n2. Quantiles for each variable:\n\n        2.5%    25%    50%     75%   97.5%\nprob  0.2908 0.3506  0.385  0.4228  0.5013\ntheta 7.4061 9.7948 11.262 13.2115 18.2079\n```\n\n\n:::\n:::\n\n\n\n\nAnd there are plenty of others samplers:\n\n- Particle filters / sequential Monte Carlo and iterated filtering (package `nimbleSMC`)\n\n- Monte Carlo Expectation Maximization (MCEM)\n\nSee [link](https://r-nimble.org/html_manual/cha-algos-provided.html#cha-algos-provided)\n\n\n## The laplace approximation\n\n`nimble` also implements the Laplace approximation. But be careful, it performs maximum likelihood estimation. This is not the same as `INLA` (fully bayesian approach), but more like `TMB` (or `glmmTMB`- maximum likelihood estimation through Laplace approximation and automatic differentiation).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We need the derivatives to build the Laplace algorithm\n# so we take the object model_neg_bin_HMC built previously\nmodel_laplace <- buildLaplace(model_neg_bin_HMC)\nCmodel_laplace <- compileNimble(model_laplace)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get the Laplace approximation for one set of parameter values.\nCmodel_laplace$calcLaplace(c(0.5,0.5)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1499.737\n```\n\n\n:::\n\n```{.r .cell-code}\n # Get the corresponding gradient.\nCmodel_laplace$gr_Laplace(c(0.5,0.5))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -3552.0000   409.7602\n```\n\n\n:::\n\n```{.r .cell-code}\n# Search the (approximate) MLE\nMLE <- Cmodel_laplace$findMLE(c(0.5,0.5)) # Find the (approximate) MLE.\nMLE$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  0.366619 10.569421\n```\n\n\n:::\n\n```{.r .cell-code}\n# Get log-likelihood value\nMLE$value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -333.2813\n```\n\n\n:::\n\n```{.r .cell-code}\n# And output summaries\nCmodel_laplace$summary(MLE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnimbleList object of type AGHQuad_summary\nField \"params\":\nnimbleList object of type AGHQuad_params\nField \"names\":\n[1] \"prob\"  \"theta\"\nField \"estimates\":\n[1]  0.366619 10.569421\nField \"stdErrors\":\n[1] 0.05242939 2.35119020\nField \"randomEffects\":\nnimbleList object of type AGHQuad_params\nField \"names\":\ncharacter(0)\nField \"estimates\":\nnumeric(0)\nField \"stdErrors\":\nnumeric(0)\nField \"vcov\":\n<0 x 0 matrix>\nField \"scale\":\n[1] \"original\"\n```\n\n\n:::\n:::\n\n\n\n\nN.b this example is only for illustration of the code. The Laplace approximation is relevant only when there are random effects in the model (which is not the case here).\n\nFor a full example see [link](https://r-nimble.org/html_manual/cha-AD.html#sec:AD-laplace)\n\n## Comparing MCMC algorithms\n\nOne can compare several algorithms through the package `compareMCMCs`. It is possible to compare several algorithms internal to `nimble` with those from `jags` (or even `STAN`) algorithms. An example below for `nimble` and `STAN`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This model code will be used for both nimble and JAGS\nmodelInfo <- list(\n  code = code_neg_bin,\n  constants = list(n = length(data_ex1)),\n  data = list(y = data_ex1),\n  inits = list(prob = 0.5, theta = 1)\n)\n\n# Here is a custom MCMC configuration function for nimble\nconfigure_nimble_slice <- function(model) {\n  configureMCMC(model, onlySlice = TRUE)\n}\n\n# Here is the call to compareMCMCs\nres <- compareMCMCs(modelInfo,\n                    MCMCs = c('nimble',       # nimble with default samplers\n                              'nimble_slice' # nimble with slice samplers\n                              ),\n                    nimbleMCMCdefs = \n                      list(nimble_slice = 'configure_nimble_slice'),\n                    MCMCcontrol = list(inits = list(prob = 0.5, theta = 1),\n                                       niter = 10000,\n                                       burnin = 1000))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nbuilding nimble model...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nRW sampler (2)\n  - prob\n  - theta\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nslice sampler (2)\n  - prob\n  - theta\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nmake_MCMC_comparison_pages(res, modelName = 'code_neg_bin',dir = \"/tmp/\",\n                           control = list(res = 75))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLe chargement a nÃ©cessitÃ© le package : xtable\n```\n\n\n:::\n:::\n\n\n\n\n# Another example: multivariate normal with zero inflated component\n\nWe consider a multivariate Gaussian model with zero inflation, where the probability in the zero inflation can depend on the variable. The vector of observations $Y_i$ lives in $\\mathbb{R}^p$, and its distribution is defined conditionnally on a (multivariate) Bernoulli $W_i \\in {0,1}^p$ and a multivariate Gaussian variable $Z_i\\in\\mathbb{R}^p$: \n\n\\begin{equation}\n    \\begin{array}{rcl}\n    Y_{ij} | Z_i, W_{i} & = & W_{ij} \\delta_0 + (1 - W_{ij}) Z_{ij}\\\\\n    W_{i} & \\sim & \\otimes_j \\mathcal{B}(\\pi_j) \\\\\n    Z_i & \\sim \\, \\mathcal{N}\\left(\\mu, \\Omega^{-1} \\right) \\\\\n    \\end{array}\n\\end{equation}\n\nThe parameters to estimate are $\\theta = \\{\\mu, \\Omega, \\pi\\}$.\n\n## Data generation\n\nWe consider a simple settings in dimension $p=5$, with Toeplitz-like covariance. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 100\np <- 5\nd <- 1:p\nDsqrt <- diag(sqrt(d))\nSigma <- Dsqrt %*% toeplitz(0.75^(0:(p-1))) %*% Dsqrt\nOmega <- solve(Sigma)\nmu <- 5 + 1:p\npi <- c(0.25, 0, 0.8, 0.1, .5)\n```\n:::\n\n\n\n\nHere are some data (100 points):\n\n\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nW <- t(replicate(N, rbinom(p, prob = pi, size = 1)))\nY <- (1 - W) * rmvnorm(N, mu, Sigma)\nggplot(data.frame(y = c(Y))) + aes(x=y) + geom_histogram()\n```\n\n::: {.cell-output-display}\n![](01_nimble_files/figure-html/data-generation-1.png){width=672}\n:::\n:::\n\n\n\n\n## Auxiliary functions \n\nWe need some auxiliary `nimble` functions to handle the density and generation of the random binomial vector $W$:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndbinom_vector <- nimbleFunction(\n  run = function( x = double(1),\n                  size = double(1),\n                  prob = double(1), \n                  log = integer(0, default = 0)\n  ) {\n    returnType(double(0))\n    logProb <- sum(dbinom(x, prob = prob, size = size, log = TRUE))\n    if(log) return(logProb) else return(exp(logProb))\n  })\n\nrbinom_vector <- nimbleFunction(\n  run = function( n = integer(0, default = 1),\n                  size = double(1),\n                  prob = double(1)\n  ) {\n    returnType(double(1))\n    return(rbinom(length(size), prob = prob, size = size))\n  })\n```\n:::\n\n\n\n\n## Nimble code and model for ZI-normal: V1\n\nRather than defining a probability density function for this model (which is in fact a bit complicated...), we adopt a generative approach:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZInormal_code <- nimbleCode({\n  \n  for (j in 1:p) {\n    mean[j] ~ dnorm(0,1)  \n  }\n  for (j in 1:p) {\n    zeroProb[j] ~ dunif(0,1)\n  }\n  \n  prec[1:p,1:p] ~ dwish(Ip[1:p,1:p], p)\n\n  for (i in 1:N) {\n    w[i, 1:p] ~ dbinom_vector(onep[1:p], zeroProb[1:p])\n    z[i, 1:p] ~ dmnorm(mean[1:p], prec[1:p,1:p])\n    ytilde[i, 1:p] <- (1 - w[i,1:p]) * z[i,1:p]\n    ## P. Barbillon/M.-P. Ãtienne: astuce en zero \n    ## a.k.a \"I got a trick at zero\"\n    y[i, 1:p] ~ dmnorm(ytilde[i, 1:p], prec_inf[1:p,1:p])\n  }\n  \n})\n```\n:::\n\n\n\n\nWe can now define the `nimble` model for the ZI-normal model. We give some sound intial values for the parameters and latent variable, define some constants and provide the data:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nZInormal_model <- nimbleModel(\n  ZInormal_code, \n  constants = \n    list(N = N, p = p, Ip = diag(1,p,p),\n         onep = rep(1,p), prec_inf = diag(1e5,p,p)),\n  data = list(y = Y, w = W),\n  inits = list(mean = rep(5,p), prec = diag(1,p,p), zeroProb=rep(0.5,p), z = Y))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Note] Registering 'dbinom_vector' as a distribution based on its use in BUGS code. If you make changes to the nimbleFunctions for the distribution, you must call 'deregisterDistributions' before using the distribution in BUGS code for those changes to take effect.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n:::\n\n\n\n\n## MCMC estimation\n\nLet us run a simple 2-chain MCMC estimation\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_MCMC <- nimbleMCMC(\n  ZInormal_model, \n  monitors = c(\"mean\", \"prec\", \"zeroProb\"),\n  nchains = 2, \n  niter = 1000, \n  samplesAsCodaMCMC = TRUE,\n  nburnin=100)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Estimation of the mean $\\mu$](01_nimble_files/figure-html/posterior-mean-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(mu)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  7  8  9 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Estimation of the zero inflation probabilities $\\pi$](01_nimble_files/figure-html/posterior-zeroProb-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.25 0.00 0.80 0.10 0.50\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Estimation of the precision matrix $\\Omega$](01_nimble_files/figure-html/posterior-prec-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(round(Omega,3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       [,1]   [,2]   [,3]   [,4]   [,5]\n[1,]  2.286 -1.212  0.000  0.000  0.000\n[2,] -1.212  1.786 -0.700  0.000  0.000\n[3,]  0.000 -0.700  1.190 -0.495  0.000\n[4,]  0.000  0.000 -0.495  0.893 -0.383\n[5,]  0.000  0.000  0.000 -0.383  0.457\n```\n\n\n:::\n:::\n\n\n\n\n\n# Zero inflated multivariate normal revisited\n\nAll the above code uses a workaround to avoid defining a new distribution in Nimble which is a ZI multivariate normal.\n\nLet $Y$ be a random vector.\nWe denote $\\mathbf{i}_*$ the set of indexes for which $Y$ is non zero, and $\\mathbf{i}_0$ the set of indices for which $Y$ is 0.\n\nFor the zero inflated normal distribution, the p.d.f. is given by:\n$$\np(y \\vert \\mu, \\Sigma, \\pi) = \\varphi(y_{\\mathbf{i}_*}\\vert \\mu_{\\mathbf{i}_*}, \\Sigma_{\\mathbf{i}_*;\\mathbf{i}_*})\\prod_{j\\in \\mathbf{i_0}}\\pi_j \\prod_{k\\in \\mathbf{i}_*}(1 - \\pi_k)\\,,\n$$\nwhere $\\varphi(y_{\\mathbf{i}_*}\\vert \\mu_{\\mathbf{i}_*}, \\Sigma_{\\mathbf{i}_*;\\mathbf{i}_*})$ is the p.d.f. of a multivariate normal distribution restricted to the indexes where $y$ is non 0 (and to the corresponding parameters).\nThis distribution can be coded as a `nimbleFunction`.\nIt is important here that the first argument must correspond to the value at which the density is evaluated, and that the `log` argument is mandatory.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndZInormal <- nimbleFunction(\n  run = function(x = double(1),\n                 prob = double(1),\n                 mu = double(1),\n                 sigma = double(2),\n                 log = integer(0, default = 0)){\n    returnType(double(0))\n    non_nul_indexes <- which(x!=0)\n    nul_indexes <- which(x == 0)\n    p_term <- sum(log(prob[nul_indexes])) +\n      sum(log(1 - prob[non_nul_indexes])) \n    mu_term <- 0\n    if(length(non_nul_indexes) > 0){\n      chol_mat <- chol(sigma[non_nul_indexes, non_nul_indexes])\n      restricted_x = x[non_nul_indexes]\n      restricted_mu = mu[non_nul_indexes]\n      mu_term <- dmnorm_chol(restricted_x,\n                             restricted_mu,\n                             chol_mat, prec_param = FALSE, log = TRUE)\n    }\n    log_output <- p_term + mu_term\n    if(log){\n      return(log_output)\n    }\n    else{\n      return(exp(log_output))\n    }\n  }\n)\n```\n:::\n\n\n\n\nFrom my experience, it is better to register this distribution to avoid any confusion about its parameters, nature and dimension of output, etc...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nregisterDistributions(list(\n  dZInormal = list(BUGSdist = \"dZInormal(prob, mu, sigma)\", # How to call in nimble\n                   discrete = FALSE, # Distribution is not discrete\n                   pqAvail = FALSE, # CDF and quantile function are not available\n                   types = c('value = double(1)', # The random variable is a vector\n                             'prob = double(1)', # a vector\n                             'mu = double(1)', # vector\n                             'sigma = double(2)')) # double(2) is a matrix\n))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n  [Warning] Random generation function for dZInormal is not available. NIMBLE is generating a placeholder function, rZInormal, that will invoke an error if an algorithm needs to simulate from this distribution. Some algorithms (such as random-walk Metropolis MCMC sampling) will work without the ability to simulate from the distribution.  If simulation is needed, provide a nimbleFunction (with no setup code) to do it.\n```\n\n\n:::\n:::\n\n\n\n\nNote that it tells us that we do not provide any way of simulating from this distribution. This is not a problem to run a standard MCMC. \nMoreover, providing CDF and quantile function could allow some gain in efficiency (at least, that what the help pages says).\n\nThe code for the model is then direct:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_code <- nimbleCode({\n  for(j in 1:p){\n    prob[j] ~ dunif(0, 1)\n    mu[j] ~ dnorm(0, 1)\n  }\n  sigma[1:p, 1:p] ~ dwish(Ip[1:p, 1:p], p)\n  for(i in 1:n){\n    # I put my custom distribution\n    Y[i, 1:p] ~ dZInormal(prob[1:p], mu[1:p], sigma[1:p, 1:p])\n  }\n})\n```\n:::\n\n\n\n\nAnd now, let's run it!\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generating data\nset.seed(123)\nn_obs <- 1000\nn_species <- 3\n# Values\nU <- mvtnorm::rmvnorm(n = n_obs, \n                       mean = 0:(n_species - 1), \n                       sigma = diag(1, n_species))\n# Mask (matrix of zeros and ones)\nZ <- rbinom(n = n_obs * n_species, size = 1, prob = .8) %>% \n  matrix(nrow = n_obs)\n# Observations\nY <- round(U * Z, 9)\n\n\n\nmy_model <- nimbleModel(code = my_code,\n                        constants = list(p = n_species,\n                                         n = n_obs,\n                                         Ip = diag(1, n_species)),\n                        data = list(Y = Y),\n                        inits = list(mu = rep(0, n_species),\n                                     prob = rep(0.5, n_species),\n                                     sigma = diag(1, n_species)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nDefining model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBuilding model\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSetting data and initial values\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nChecking model sizes and dimensions\n```\n\n\n:::\n\n```{.r .cell-code}\nresults <- nimbleMCMC(my_model,\n                      samplesAsCodaMCMC = TRUE,\n                      nchains = 2, niter = 10000,\n                      nburnin = 1000, thin = 10)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 1...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nrunning chain 2...\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n```\n\n\n:::\n\n```{.r .cell-code}\nggs(results) %>% \n  ggplot(aes(x = Iteration, y = value, color = factor(Chain))) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](01_nimble_files/figure-html/fit-ZI-normal-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}