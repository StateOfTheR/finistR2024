{
  "hash": "f027bcebd8623e74426bb0f0419bb6a4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Graph Neural Networks for bipartite graphs with pytorch_geometric\"\nformat: \n  html: \n    number-sections: true\neditor: visual\n---\n\n\n\n\n## Graph class\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(reticulate)\n```\n:::\n\n\n\n\nThe notebook shows a classical use of the package **pytorch_numeric** which develops Graph Neural Networks based on the logics of **pytorch**.\n\nHere we show a basic graph with the library **networkx**.\\\nWe use the dataset KarateClub() which is organized as the typical object used by pytorch_geometric: it is a list of graphs where each graph must have an object `x`, that represents the features of the nodes, and an object `edge_index`, a 2-row tensor which defines the links between the nodes (plus other possible information about the graph).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport torch\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(G, color):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    nx.draw_networkx(G, pos=nx.spring_layout(G, seed=42), with_labels=False,\n                     node_color=color, cmap=\"Set2\")\n    plt.show()\n\n\ndef visualize_embedding(h, color, epoch=None, loss=None):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    h = h.detach().cpu().numpy()\n    plt.scatter(h[:, 0], h[:, 1], s=140, c=color, cmap=\"Set2\")\n    if epoch is not None and loss is not None:\n        plt.xlabel(f'Epoch: {epoch}, Loss: {loss.item():.4f}', fontsize=16)\n    plt.show()\n\n\nfrom torch_geometric.datasets import KarateClub\n\ndataset = KarateClub()\nprint(f'Dataset: {dataset}:')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataset: KarateClub():\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Number of graphs: {len(dataset)}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of graphs: 1\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Number of features: {dataset.num_features}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of features: 34\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Number of classes: {dataset.num_classes}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of classes: 4\n```\n\n\n:::\n\n```{.python .cell-code}\ndata = dataset[0]  # Get the first graph object.\n\nprint(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nData(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n```\n\n\n:::\n\n```{.python .cell-code}\n# Gather some statistics about the graph.\nprint(f'Number of nodes: {data.num_nodes}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of nodes: 34\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Number of edges: {data.num_edges}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of edges: 156\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Average node degree: {data.num_edges / data.num_nodes:.2f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAverage node degree: 4.59\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Number of training nodes: {data.train_mask.sum()}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNumber of training nodes: 4\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTraining node label rate: 0.12\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Has isolated nodes: {data.has_isolated_nodes()}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHas isolated nodes: False\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Has self-loops: {data.has_self_loops()}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHas self-loops: False\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(f'Is undirected: {data.is_undirected()}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIs undirected: True\n```\n\n\n:::\n\n```{.python .cell-code}\nedge_index = data.edge_index # the objet to give to torch_geometric, along with the features\nprint(edge_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n```\n\n\n:::\n\n```{.python .cell-code}\nfrom torch_geometric.utils import to_networkx\n\nG = to_networkx(data, to_undirected=True)\nvisualize_graph(G, color=data.y)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n## Unipartite GNN\n\nWe create the architecture of the GNN for a unipartite graph. The architecture is made of a list of graph convolutional layers (GCL, chosen among a list of possible types of convolutions) and a MLP as last layer, which performs the learning task (node classification here). All the layers are followed by an activation function.\n\n[Possible types of graph convolutional layers](https://pytorch-geometric.readthedocs.io/en/latest/cheatsheet/gnn_cheatsheet.html)\n\nThe init size of the first layer is the number of features and the output size of the last layer depends on the learning task.\n\nEach GCL is defined as a function of two parameters : input size and output size. When defining the forward function, the GCL is called with two input parameters : `x` and `edge_index`.\n\nWe show the embedding (after the GCLs and before the MLP) after one pass forward to control that no error occurs.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom torch.nn import Linear\nfrom torch_geometric.nn import GCNConv\n\nclass GCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GCNConv(dataset.num_features, 4) # num_features here is 34 (because of identity matrix), but can be 1 (for example with degree of nodes)\n        self.conv2 = GCNConv(4, 4)\n        self.conv3 = GCNConv(4, 2)\n        self.classifier = Linear(2, dataset.num_classes)\n\n    def forward(self, x, edge_index): # here the two objects needed by pytorch_geometric\n        h = self.conv1(x, edge_index)\n        h = h.tanh()\n        h = self.conv2(h, edge_index)\n        h = h.tanh()\n        h = self.conv3(h, edge_index)\n        h = h.tanh()  # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out = self.classifier(h)\n\n        return out, h\n\nmodel = GCN()\nprint(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGCN(\n  (conv1): GCNConv(34, 4)\n  (conv2): GCNConv(4, 4)\n  (conv3): GCNConv(4, 2)\n  (classifier): Linear(in_features=2, out_features=4, bias=True)\n)\n```\n\n\n:::\n\n```{.python .cell-code}\n_, h = model(data.x, data.edge_index)\nprint(f'Embedding shape: {list(h.shape)}')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nEmbedding shape: [34, 2]\n```\n\n\n:::\n\n```{.python .cell-code}\nvisualize_embedding(h, color=data.y)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n:::\n\n\n\n\nWe then train the model with using the classical **pytorch** workflow defining a loss (here Cross Entropy), an optimizer (here Adam) and the number of epochs (here 151). We show the embedding every 50 epochs.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport time\n\n# Exactly the same as in torch\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion --> for classification.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01)  # Define optimizer.\n\ndef train(data):\n    optimizer.zero_grad()  # Clear gradients.\n    out, h = model(data.x, data.edge_index)  # Perform a single forward pass.\n    loss = criterion(out[data.train_mask], data.y[data.train_mask])  # Compute the loss solely based on the training nodes.\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss, h\n\nfor epoch in range(151):\n    loss, h = train(data)\n    if epoch % 50 == 0:\n        visualize_embedding(h, color=data.y, epoch=epoch, loss=loss)\n        time.sleep(0.3)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-4-5.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-4-6.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-4-7.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-4-8.png){width=672}\n:::\n:::\n\n\n\n\n## Bipartite GNN\n\nTu generalize GNN to bipartite graphs, we first need to define the type of data as `BipartiteData` which inherits from `Data`. The two types of nodes will be called *source nodes* and *target nodes*. The new object creates the source nodes and target nodes with their respective features (`x_s` and `x_t`), possibly different in size. The 2 rows in `edges_index` correspond to the source and target nodes, respectively.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom torch_geometric.data import Data\nfrom torch_geometric.loader import DataLoader\nfrom torch_geometric.nn import SAGEConv\n\nclass BipartiteData(Data):\n    def __inc__(self, key, value, *args, **kwargs):\n        if key == 'edge_index':\n            return torch.tensor([[self.x_s.size(0)], [self.x_t.size(0)]])  # source and target (two classes of bipartite graph)\n        return super().__inc__(key, value, *args, **kwargs)\n\n\nx_s = torch.randn(2, 4)  # 2 nodes, 4 features.\nx_t = torch.randn(3, 2)  # 3 nodes, 2 features.\n\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index)\n\n# Plot of graph\nedge_list = list(zip(edge_index[0].tolist(),(edge_index[1]+1+max(edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-5-13.png){width=672}\n:::\n:::\n\n\n\n\nThe convolution layer is directed, hence it must be defined with the tuple of feature size of source and target nodes and the size of output of the layer, which will be given as new features to the nodes of the target.\n\nWe call the function with the tuple of features `(x_s, x_t)` and the \\`edge_index\\`.\n\nTo perform the inverse convolution from the target nodes to the source nodes, we must invert the values of the tuple but also invert the rows in the \\`edge_index\\`.\n\nOnly some of the GCLs are adapted to this configuration (look at the cheatsheet).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Direct and inverse convolutions\nConv_s_t = SAGEConv((4,2),7) # num of features is the tuple (s,t) and output is the num of features of target\n\nprint(Conv_s_t((x_s,x_t),edge_index))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntensor([[ 0.5198,  0.5703,  0.6759,  0.1716, -0.6514,  0.0479, -0.5577],\n        [-0.0901,  1.5395,  0.3465,  0.0784, -1.5599,  1.1494, -0.5391],\n        [-1.0943,  0.7638,  0.2591,  0.4076, -0.5398,  0.6612, -2.2322]],\n       grad_fn=<AddBackward0>)\n```\n\n\n:::\n\n```{.python .cell-code}\nConv_t_s = SAGEConv((2,4),7,aggr = \"max\")\nprint(Conv_t_s((x_t,x_s),edge_index[[1,0]])) # I need to invert the order of edge_index\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntensor([[-0.4040,  0.4052, -0.1868,  0.9336,  0.0030,  0.6546,  1.0335],\n        [ 0.5958, -0.1849,  0.2907,  1.4262, -0.9557,  0.4383,  0.6614]],\n       grad_fn=<AddBackward0>)\n```\n\n\n:::\n:::\n\n\n\n\n### Case study\n\nLatent Block Model for classification task\n\nTwo groups in sources, two groups in targets, with corresponding probability of connection.\n\nEach node has two features: `1` and its degree.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nn1= 25\nn2 = 50 \n\nW1 = np.random.randint(2,size=n1)\nW2 = np.random.randint(2,size=n2)\nP = np.array([[0.9,0.8],[0.5,0.1]])\nM = P[:,W2][W1,:]\n\nm = np.random.binomial(1, M)\nplt.imshow(m[np.argsort(W1),:][:,np.argsort(W2)],cmap=\"gray_r\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<matplotlib.image.AxesImage object at 0x00000207C83B9130>\n```\n\n\n:::\n\n```{.python .cell-code}\nedge_index = torch.LongTensor(([np.where(m)[0],np.where(m)[1]]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<string>:2: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at C:\\b\\abs_8f7uhuge1i\\croot\\pytorch-select_1717607507421\\work\\torch\\csrc\\utils\\tensor_new.cpp:277.)\n```\n\n\n:::\n\n```{.python .cell-code}\n\n# 1 (to count for how many neighbors) + degree  (random choice, but good when we have no other information on the network)\n\nx_s = torch.Tensor(m.sum(1).reshape(-1,1))\nx_s = torch.concat((x_s,torch.ones(x_s.shape[0],1)),1)\nx_t = torch.Tensor(m.sum(0).reshape(-1,1))\nx_t = torch.concat((x_t,torch.ones(x_t.shape[0],1)),1)\n\ndata = Data(x_s=x_s, x_t=x_t, edge_index=edge_index)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-7-15.png){width=672}\n:::\n:::\n\n\n\n\nWe define an architecture for the bipartite GNN.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = SAGEConv((x_s.shape[1],x_t.shape[1]),5) \n        self.conv2 = SAGEConv((x_t.shape[1],x_s.shape[1]),10)\n        \n        self.conv3 = SAGEConv((5,10), 4)\n        self.conv4 = SAGEConv((10,5), 4) \n\n        self.classifier1 = Linear(4,2)\n        self.classifier2 = Linear(4,2)\n\n    def forward(self, x, edge_index):\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) #n2 x 5\n        h1 = h1.tanh()\n        \n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]]) #n1 x 10 # invert edge_index for the inverse convolution\n        h2 = h2.tanh()\n        \n        h3 = self.conv3((h1,h2), edge_index[[1,0]])  #n1 x 4\n        h3_2 = h3.tanh()\n        \n        h4 = self.conv4((h2,h1), edge_index) #n2 x 4\n        h4_2 = h4.tanh() # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out1 = self.classifier1(h3_2) #n1 x 4\n        out2 = self.classifier2(h4_2) #n2 x 4\n\n        return out1,out2, h3,h4\n\nBGCN1 = BGCN()\nout1,out2, h3,h4= BGCN1((x_s,x_t),edge_index) \n\nH =torch.concat([h3,h4])\ncolor0 = np.concatenate([W1,W2+2])\n\nvisualize_embedding(H, color=color0)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-8-17.png){width=672}\n:::\n:::\n\n\n\n\nWe train the model as above and print the AUC for the classes of sources and targets.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport time\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(BGCN1.parameters(), lr=0.01)  # Define optimizer.\n\ntrain_mask,test_mask = train_test_split(np.arange(n1),test_size = 0.2,stratify = W1)\ntrain_mask2,test_mask2 = train_test_split(np.arange(n2),test_size = 0.2,stratify = W2)\n\ndef train():\n    optimizer.zero_grad()  # Clear gradients.\n    out1,out2, h3,h4= BGCN1((x_s,x_t),edge_index)  # Perform a single forward pass.\n    loss1 = criterion(out1[train_mask], torch.LongTensor(W1)[train_mask])  # Compute the loss solely based on the training nodes.\n    loss2 = criterion(out2[train_mask2], torch.LongTensor(W2)[train_mask2])\n    loss = loss1+loss2\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss,out1,out2, h3,h4\n\nfor epoch in range(101):\n    loss,out1,out2, h3,h4 = train()\n    if epoch % 50 == 0:\n        H =torch.concat([h3,h4])\n        color0 = np.concatenate([W1,W2+2])\n        visualize_embedding(H, color=color0, epoch=epoch, loss=loss)\n        time.sleep(0.3)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-9-19.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-9-20.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-9-21.png){width=672}\n:::\n\n```{.python .cell-code}\ny_pred1 = out1[test_mask].argmax(1).detach().numpy()\ny_pred2 = out2[test_mask2].argmax(1).detach().numpy()\nprint(\"AUC 1 : \",roc_auc_score(W1[test_mask],y_pred1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAUC 1 :  1.0\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"AUC 2 : \",roc_auc_score(W2[test_mask2],y_pred2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAUC 2 :  0.9\n```\n\n\n:::\n:::\n\n\n\n\n## Mini-batches for pooling operation in GNNs\n\nThe function `DataLoader` called with a list of graphs and the parameter `batch_size` creates a new UNCONNECTED graph with the as many different graphs as given in `batch_size`.\n\nOften, it is useful to be able to distinguish nodes from one graph to the other for different objectives such as graph classification. To keep track of which nodes belong to which graph, we can use `batch.batch`, that returns a vector of indices pairing each target node to its graph.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom torch_geometric.nn import  pool\nfrom torch_geometric.loader import DataLoader\n\nx_s = torch.randn(2, 16)  # 2 nodes.\nx_t = torch.randn(3, 10)  # 3 nodes.\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index,num_nodes = x_t.shape[0])\n    \ndata_list = [data, data, data, data, data, data] # 6 identical graphs (but can be different in size, features, ...\nloader = DataLoader(data_list, batch_size=3) # the dataloader creates a new UNCONNECTED graph with the 3 different graphs\nbatch = next(iter(loader))\n\nprint(\"batch \", batch)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nbatch  BipartiteDataBatch(edge_index=[2, 12], x_s=[6, 16], x_t=[9, 10], num_nodes=9, batch=[9], ptr=[4])\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"edge_index \", batch.edge_index)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nedge_index  tensor([[0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5],\n        [0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8]])\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"node index \", batch.batch) # these are batches for target nodes (ONLY), vector of indexes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nnode index  tensor([0, 0, 0, 1, 1, 1, 2, 2, 2])\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nedge_list = list(zip(batch.edge_index[0].tolist(),(batch.edge_index[1]+1+max(batch.edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,batch.edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n```\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-11-25.png){width=672}\n:::\n:::\n\n\n\n\nIf we want to pair also the source nodes, we can use the following code.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# code for creating batches for source nodes, vector of indexes\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nprint(pool.global_add_pool(batch.x_t,batch.batch).shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntorch.Size([3, 10])\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(pool.global_add_pool(batch.x_s,batch_s).shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntorch.Size([3, 16])\n```\n\n\n:::\n:::\n\n\n\n\n### Real case study\n\nData are a list of interactions between plants and insects collected from different studies. We also know how data were collected for each study : Transect or Timed observation. This information is encoded in the boolean `TO` (= 1 for Timed observation). The objective is to retrieve the variable TO from the networks (graph classification).\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n#%% Exemple on real dataset\nimport pandas as pandas\nfrom sknetwork.data import from_edge_list\nfrom torch_geometric.utils import degree\nfrom sklearn.model_selection import train_test_split\n\nNetworks = pandas.read_csv(\"Interaction data Mael.txt\", encoding=\"latin-1\",sep=\"\\t\")\nNetworks[\"plant\"] = Networks['plantgenus'] + \"_\"+ Networks['plantspecies']\nNetworks[\"insects\"] = Networks[\"insectgenus\"]+ \"_\"+ Networks[\"insectspecies\"]\n\nsupinfo = pandas.read_excel(\"supinfo.xlsx\",1)\n#torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values*1)\n\ndata_list = []\nid_network_aggreg= Networks[\"id_network_aggreg\"].unique()\nfor k in id_network_aggreg:\n    Networks2 =Networks[[\"plant\",\"insects\"]][Networks[\"id_network_aggreg\"]==k]\n    graph = from_edge_list(edge_list=list(Networks2.itertuples(index=False)),bipartite=True)\n    biadjacency = graph.biadjacency.tocoo()\n    edge_index = torch.LongTensor([graph.biadjacency.tocoo().row,graph.biadjacency.tocoo().col])\n    TO =  torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values)*1\n    \n    # we can add arguments in the function to add for example the class of the graph\n    data = BipartiteData(x_s=degree(edge_index[0],num_nodes=biadjacency.shape[0]).reshape(-1,1),\n                         x_t=degree(edge_index[1],num_nodes=biadjacency.shape[1]).reshape(-1,1),\n                         edge_index=edge_index,\n                         TO = TO,\n                         num_nodes =biadjacency.shape[1] ) # number of tartet nodes\n    data_list.append(data)\n\n\nprint(data_list[0])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nBipartiteData(edge_index=[2, 544], x_s=[131, 1], x_t=[113, 1], TO=[1], num_nodes=113)\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(\"data_list len : \", len(data_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata_list len :  123\n```\n\n\n:::\n:::\n\n\n\n\nWe define the model architecture. Poolings layers are described [here](https://pytorch-geometric.readthedocs.io/en/latest/modules/nn.html#pooling-layers).\n\nWe add a *pooling layer* between the CGLs and the MLP in order to agregate the features from target nodes belonging to the same graph in one feature vector for each graph.\n\nThe pooling is made thanks to the indices vector `batch.batch`.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom torch_geometric.nn import GATConv\n\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GATConv((1,1),5)\n        self.conv2 = SAGEConv((1,1),10)\n        self.conv3 = SAGEConv((self.conv2.out_channels,self.conv1.out_channels), 4)\n        \n        self.classifier1 = Linear(9,15) # 9 because 5 + 4 in the concatanation of h1 and h3\n        self.classifier2 = Linear(15,10)\n        self.classifier3 = Linear(10,1)\n        self.ReLU = torch.nn.ReLU()\n\n    def forward(self, x, edge_index,batch): #  batch is given here as input\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) \n        h1 = h1.tanh()\n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]])\n        h2 = h2.tanh()\n        h3 = self.conv3((h2,h1), edge_index)\n\n        h4 = torch.concat([h1,h3],1) # concatenation in order to have only targets and use batch as indexes \n        \n        #H = pool.global_add_pool(h4,batch) ##Pooling layer ! \n        #H = pool.global_mean_pool(h4,batch)  \n        H = pool.global_max_pool(h4,batch)  # the pooling is made graph after graph (thanks to the argument batch) \n        \n         \n        H1 = self.classifier1(H)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier2(H1)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier3(H1)\n        \n        H1 = torch.nn.Sigmoid()(H1)\n        \n        return H1\n    \n    \nloader = DataLoader(data_list, batch_size=10)\nbatch = next(iter(loader))\nprint(x_t.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntorch.Size([3, 10])\n```\n\n\n:::\n\n```{.python .cell-code}\nprint(batch.batch.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntorch.Size([1355])\n```\n\n\n:::\n\n```{.python .cell-code}\n\nBGCN2 = BGCN()\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nH=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch) # don't forget the argument batch.batch (on targets)\n```\n:::\n\n\n\n\nWe train the model and show the AUC.\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ny=[x.TO.item() for x in data_list]\ndata_train,data_test =train_test_split(data_list,stratify = y,test_size = 0.2,random_state=5)\n\nfrom tqdm import tqdm\nBGCN2 = BGCN()\ncriterion = torch.nn.BCELoss() # Binary Cross Entropy\noptimizer = torch.optim.Adam(BGCN2.parameters(), lr=0.01) # Define optimizer.\nloader = DataLoader(data_train, batch_size=10)\n\nloss_list = []\nfor K in tqdm(range(20)):\n    for batch in loader:\n        optimizer.zero_grad()  # Clear gradients.\n        H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)   # Perform a single forward pass.\n        loss = criterion(H,batch.TO.reshape(-1,1))\n        loss.backward() \n        optimizer.step()\n        loss_list.append(loss.item()) # Derive gradients.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  0%|          | 0/20 [00:00<?, ?it/s]\n 10%|#         | 2/20 [00:00<00:01, 17.78it/s]\n 20%|##        | 4/20 [00:00<00:00, 17.85it/s]\n 30%|###       | 6/20 [00:00<00:00, 18.41it/s]\n 40%|####      | 8/20 [00:00<00:00, 18.01it/s]\n 50%|#####     | 10/20 [00:00<00:00, 18.05it/s]\n 60%|######    | 12/20 [00:00<00:00, 17.98it/s]\n 70%|#######   | 14/20 [00:00<00:00, 18.29it/s]\n 80%|########  | 16/20 [00:00<00:00, 18.39it/s]\n 90%|######### | 18/20 [00:00<00:00, 18.61it/s]\n100%|##########| 20/20 [00:01<00:00, 18.82it/s]\n100%|##########| 20/20 [00:01<00:00, 18.38it/s]\n```\n\n\n:::\n\n```{.python .cell-code}\nplt.plot(loss_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[<matplotlib.lines.Line2D object at 0x00000207CFEC1910>]\n```\n\n\n:::\n\n```{.python .cell-code}\nloader_train = DataLoader(data_train, batch_size=len(data_train))\nfor batch in loader_train:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n    \nprint(\"AUC train \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAUC train  0.7997448979591836\n```\n\n\n:::\n\n```{.python .cell-code}\n    \nloader_test = DataLoader(data_test, batch_size=len(data_test))\nfor batch in loader_test:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n\nprint(\"AUC test \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAUC test  0.6753246753246753\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](Bipartite_GNN_files/figure-html/unnamed-chunk-15-27.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Bipartite_GNN_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}