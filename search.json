[
  {
    "objectID": "Readme.html",
    "href": "Readme.html",
    "title": "Ateliers Finist’R 2024",
    "section": "",
    "text": "Ateliers Finist’R 2024\n\n\n\nwebsite\n\n\nL’atelier Finist’R 2024 – ou bootcamp R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et dévelopeurs de paquets pour explorer les dernières fonctionalités du logiciel et les nouvelles pratiques de développement. A l’issu de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLa restitution se fait sous forme de site web. Le site de l’édition 2024 sera disponible ici"
  },
  {
    "objectID": "simulator_equality_test/writeup.html",
    "href": "simulator_equality_test/writeup.html",
    "title": "My Simulation",
    "section": "",
    "text": "This is a knitr report generated by the simulator to describe your simulation. Knitting this file will rerun the simulation if any of the code files have been modified since the simulation object was last created."
  },
  {
    "objectID": "simulator_equality_test/writeup.html#models",
    "href": "simulator_equality_test/writeup.html#models",
    "title": "My Simulation",
    "section": "Models",
    "text": "Models\n\nmake_my_model_normal &lt;- function(n, mu1, mu2, sig) {\n  new_model(\n    name = \"normal\", \n    label = sprintf(\"normal\"), \n    params = list(n = n, mu1 = mu1, mu2 = mu2, sig = sig),\n    simulate = function(n, mu1,mu2, sig, nsim) {\n      # this function must return a list of length nsim\n      x1 &lt;- mu1 + sig * matrix(rnorm(nsim * n), n, nsim)\n      x2 &lt;- mu2 + sig * matrix(rnorm(nsim * n), n, nsim)\n      li1 &lt;- split(x1, col(x1))\n      li2 &lt;- split(x2, col(x2))\n      lapply(1:nsim, function(i) {\n        cbind(li1[[i]], li2[[i]])\n      })\n    }\n  )\n}"
  },
  {
    "objectID": "simulator_equality_test/writeup.html#methods",
    "href": "simulator_equality_test/writeup.html#methods",
    "title": "My Simulation",
    "section": "Methods",
    "text": "Methods\n\nt_test &lt;- new_method(\n  name = \"t-test\", \n  label = \"Mean equality test\",\n  method = function(model, draw) {\n    list(pvalue = t.test(draw[, 1], draw[, 2], paired = TRUE)$p.value)\n  }\n)"
  },
  {
    "objectID": "simulator_equality_test/writeup.html#metrics",
    "href": "simulator_equality_test/writeup.html#metrics",
    "title": "My Simulation",
    "section": "Metrics",
    "text": "Metrics\n\npval_loss &lt;- new_metric(\n  name = \"p_value\", \n  label = \"pval&lt;0.05\",\n  metric = function(model, out) {\n    mean(out$pvalue &lt; 0.05)\n  }\n)"
  },
  {
    "objectID": "enseignement_restit_short.html",
    "href": "enseignement_restit_short.html",
    "title": "Suggestions from expert to beginner professors in statistics",
    "section": "",
    "text": "This document is a list of suggestions from expert to beginner professors in statistics, including how to create quiz and exams in R Markdown and shiny apps, how to make students use R on their notebooks without installing it and where to find good datasets (especially in ecology and life sciences)."
  },
  {
    "objectID": "enseignement_restit_short.html#the-idea-behind-this-document",
    "href": "enseignement_restit_short.html#the-idea-behind-this-document",
    "title": "Suggestions from expert to beginner professors in statistics",
    "section": "",
    "text": "This document is a list of suggestions from expert to beginner professors in statistics, including how to create quiz and exams in R Markdown and shiny apps, how to make students use R on their notebooks without installing it and where to find good datasets (especially in ecology and life sciences)."
  },
  {
    "objectID": "enseignement_restit_short.html#the-use-of-learnr-for-quiz",
    "href": "enseignement_restit_short.html#the-use-of-learnr-for-quiz",
    "title": "Suggestions from expert to beginner professors in statistics",
    "section": "The use of learnr for quiz",
    "text": "The use of learnr for quiz\nThe R package learnr allows to create a shiny app with quiz, questions with corrections included. A good tutorial is available on the website of Finist’R 2020 or on the learnr webpage.\nHere you can find another short example, created by myself."
  },
  {
    "objectID": "enseignement_restit_short.html#datasets-available-online",
    "href": "enseignement_restit_short.html#datasets-available-online",
    "title": "Suggestions from expert to beginner professors in statistics",
    "section": "Datasets available online",
    "text": "Datasets available online\nHere is a list of sites that can be used to download datasets for student projects.\n\nZenodo: datasets in ecology, environment, … Mainly data papers in ecology.\necologie.data.gouv Datasets in ecology. Interesting features : quality of metadata, good short description of datasets, examples of use in past projects, chat with questions/answers between users.\ndefis.data.gouv Sets of datasets already used by universities for data competitions. Multiple fields (energy, climate, social studies, …). Interesting features : complete description of the objective, difficulty of the objective (beginner, confirmed, expert), multiple datasets in each competition."
  },
  {
    "objectID": "enseignement_restit_short.html#problems-with-installation-of-r-on-student-notebooks",
    "href": "enseignement_restit_short.html#problems-with-installation-of-r-on-student-notebooks",
    "title": "Suggestions from expert to beginner professors in statistics",
    "section": "Problems with installation of R on student notebooks?",
    "text": "Problems with installation of R on student notebooks?\nIf installing R is difficult for any possible reason, a solution is to use R and Rstudio on the INRAE platform Migale. In this case, R and Rstudio are run on the server of Migale and no installation on the local notebook is needed.\nNote that creating an account is free.\nAt this webpage you can find the corresponding FAQ. https://documents.migale.inrae.fr/posts/documentation/faq/"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "",
    "text": "L’atelier Finist’R 2024 – ou bootcamp R du groupe State Of The R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nStateoftheR est un réseau du département MathNum INRAE.\n\n\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et développeurs de paquets pour explorer les dernières fonctionnalités du logiciel et les nouvelles pratiques de développement. A l’issue de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLe résultat de cette semaine est disponible sur cette page"
  },
  {
    "objectID": "index.html#où-quand",
    "href": "index.html#où-quand",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "",
    "text": "L’atelier Finist’R 2024 – ou bootcamp R du groupe State Of The R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nStateoftheR est un réseau du département MathNum INRAE.\n\n\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et développeurs de paquets pour explorer les dernières fonctionnalités du logiciel et les nouvelles pratiques de développement. A l’issue de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLe résultat de cette semaine est disponible sur cette page"
  },
  {
    "objectID": "index.html#programme",
    "href": "index.html#programme",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Programme",
    "text": "Programme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGroupe 1\nGroupe 2\nGroupe 3\nGroupe 4\nGroupe 5\nGroupe 6\n\n\n\n\n\n\nLundi Après midi\nDébut en Python\n{{Simulator}}\nGraphical Neural Network\nNimble\nCalling C++ from Python\n\n\n\n\n\nMardi Matin 1\nCours future\n\n\n\n\n\n\n\n\n\nMardi Matin 2\nPackaging/Testing\nJulia\nDiffusion\nNimble\n\n\n\n\n\n\nMardi Après midi\nPackaging/Testing\nJulia\nDiffusion\nNimble\n\n\n\n\n\n\nMercredi Matin 1\nCours future\n\n\n\n\n\n\n\n\n\nMercredi Matin 2\nRestitution\n\n\n\n\n\n\n\n\n\nJeudi Matin\n{{Rix}}\nShiny Dev\nEnergy and Optimisation\nPINNS\nCTView Network\nEnseignement\n\n\n\n\nJeudi Après Midi\n{{Rix}}\nShiny Dev\nEnergy and Optimisation\nPINNS\nCTView Network\nEnseignement\n\n\n\n\nVendredi Matin\nRestitution"
  },
  {
    "objectID": "index.html#participants",
    "href": "index.html#participants",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Participants",
    "text": "Participants\nBaptiste Alglave, Emré Anakok, Julie Aubert, Pierre Barbillon, Julien Chiquet, Lucia Clarotto, Caroline Cognot, Annaïg De Walsche, Sophie Donnet, Marie-Pierre Etienne, Armand Favrot, Hugo Gangloff, Pierre Gloaguen, Adeline Leclercq Samson, Tristan Mary-Huard, Cédric Midoux, Pierre Neuvial, Aymeric Stamm, Florian Teste, François Victor, Emily Walker."
  },
  {
    "objectID": "index.html#soutien",
    "href": "index.html#soutien",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Soutien",
    "text": "Soutien"
  },
  {
    "objectID": "c_python.html",
    "href": "c_python.html",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "On propose dans ce tutoriel une méthode pour l’utilisation de code C / C++ depuis Python. Les ressources à ce sujet sont très nombreuses, aussi nous allons nous placer dans un cas un peu particulier et moins étudié, c’est à dire :\n\nNous découvrirons bazel comme outil de compilation.\nNous utiliserons la bibliothèque pybind11_bazel et plus précisément les objets PyCapsule de cette bibliothèque.\nNous ouvrirons la PyCapsule côté Python en la reconstruisant avec la bibliothèque ctypes.\n\nNote: Ces choix sont motivés par l’objectif à plus long terme d’étendre la bibliothèque JAX avec du code C / C++ personnel, non couvert dans ce tutoriel. Voir par exemple https://github.com/dfm/extending-jax pour l’ancienne pipeline. Depuis JAX 0.4.31 sortie le 29 juillet 2024, l’intégration d’appel à du code C / C++ perso a été simplifié par jax.extend.ffi, voir par exemple https://jax.readthedocs.io/en/latest/ffi.html.\n\n\n\nNous allons travailler dans un projet structuré tel que :\nc_python/\n|___bazel-bin/\n||______ ...\n|___bazel-c_python/\n||______ ...\n|___bazel-out/\n||______ ...\n|___bazel-testlogs/\n||______ ...\n|___lib/\n||______BUILD.bazel\n||______loop.cpp\n|___loop.py\n|___MODULE.bazel\n|___WORKSPACE.bazel\nNous allons détailler la création et le contenu de chacun des éléments de l’arborescence.\n\n\n\n\nNous avons besoin d’un environnement Python simple dont nous ne détaillons pas l’installation.\nPour les utilisateurs linux, bazelisk est l’approche la plus simple pour installer bazel.\npybind11_bazel fournira pybind11.\n\n\n\n\nSoit le fichier loop.cpp :\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;cmath&gt;\n\ntemplate &lt;typename T&gt;\nvoid loop_a_lot(const std::int64_t L, T* result) {\n    *result = 0;\n    for (int l1 = 0; l1 &lt; L; ++l1) {\n        for (int l2 = 0; l2 &lt; L; ++l2) {\n            for (int l3 = 0; l3 &lt; L; ++l3) {\n                for (int l4 = 0; l4 &lt; L; ++l4) {\n                    *result += exp(3.14);\n                }\n            }\n        }\n    }\n  }\n\npybind11::dict Registrations() {\n  pybind11::dict dict;\n  dict[\"loop_f32_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;float&gt;), \"loop_plain\");\n  dict[\"loop_f64_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;double&gt;), \"loop_plain\");\n  return dict;\n}\n\nPYBIND11_MODULE(pyloop, m) {   // please match the pybind_extension target name\n  m.def(\"registrations\", &Registrations); \n}\nLes premières lignes définissent la fonction loop_a_lot simpliste que nous voulons appeler depuis Python. La deuxième partie du code utilise la bibliothèque pybind11. Nous créons un module pyloop auquel on donne une fonction registrations qui retournera un dictionnaire avec deux entrées : une fonction loop_a_lot pour chacun des types float et double. Au détail près que nous encapsulons ces fonctions dans des PyCapsules, un object Python opaque, que Python ne semble pas être censé lire (…useful for C extension modules who need to pass an opaque value (as a void * pointer) through Python code to other C code… https://docs.python.org/3/c-api/capsule.html)\n\n\n\nNous donnons l’origine des règles de compilations bazel dans le fichier WORKSPACE.bazel :\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\nhttp_archive(\n  name = \"pybind11_bazel\",\n  strip_prefix = \"pybind11_bazel-2.12.0\",\n  urls = [\"https://github.com/pybind/pybind11_bazel/archive/refs/tags/v2.12.0.zip\"],\n)\n# We still require the pybind library.\nhttp_archive(\n  name = \"pybind11\",\n  build_file = \"@pybind11_bazel//:pybind11-BUILD.bazel\",\n  strip_prefix = \"pybind11-2.13.0\",\n  urls = [\"https://github.com/pybind/pybind11/archive/refs/tags/v2.13.0.zip\"],\n)\nMODULE.bazel contient :\nbazel_dep(name = \"rules_python\", version = \"0.33.2\")\nLe fichier BUILD.bazel utilise la règle pybind_extension de pybind11_bazel :\nload(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")\n\npybind_extension(\n    name = \"pyloop\", # please match the PYBIND MODULE NAME\n    srcs = [\"loop.cpp\"],\n)\nEn se plaçant à la racine du projet et en exécutant bazel build //lib:pyloop nous obtenons directement le module Python voulu. Toute la complexité de la compilation est cachée par bazel. On voit que l’appel à build crée les quatre fichiers bazel-bin, bazel-c_python, bazel-out et bazel-testlogs. En particulier, le module d’intêret se situe dans bazel-bin/lib/.\n\n\n\nNous allons maintenant ouvrir les PyCapsules que nous avons à disposition dans le module pyloop fraîchement compilé, avec l’aide de la bibliothèque ctypes.\n\nOn rappelle que nous nous imposons les PyCapsules car ce sont les objets que nous devons manipuler pour exposer des fonctions C / C++ à JAX (notre objectif futur !). Voir par exemple (https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html)[https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html].\nOn note d’emblée que la manipulation de PyCapsule dans Python est compliquée par rapport à d’autres méthodes par lesquelles nous pouvons exposer des objets C / C++ à Python avec pybind11 (voir les tutoriels dans https://github.com/tdegeus/pybind11_examples). En effet, ces objets ne semblent pas être voués à être utilisés dans Python. Ouvrir la capsule avec ctypes constitue néanmoins un bon exercice avec cette bibliothèque.\n\nimport sys\nsys.path.insert(0, 'bazel-bin/lib/')\n\nimport ctypes\nimport numpy as np\n\nimport pyloop\n\nregistrations = pyloop.registrations()\n\nloop_f32_plain_capsule = registrations[\"loop_f32_plain\"]\nloop_f64_plain_capsule = registrations[\"loop_f64_plain\"]\n\n# Following is adapted from https://stackoverflow.com/questions/59887319/python-c-extension-exposing-a-capsule-to-ctypes-in-order-to-use-third-party-c-co\nPyCapsule_GetPointer = ctypes.pythonapi.PyCapsule_GetPointer\nPyCapsule_GetPointer.restype = ctypes.c_void_p\nPyCapsule_GetPointer.argtypes = [ctypes.py_object, ctypes.c_char_p]\n\nloop_f32_plain_ptr = PyCapsule_GetPointer(loop_f32_plain_capsule, b\"loop_plain\")\nloop_f64_plain_ptr = PyCapsule_GetPointer(loop_f64_plain_capsule, b\"loop_plain\")\n\n# This defines the functions signature\nloop_f32_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_float))(loop_f32_plain_ptr)\n\nloop_f64_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_double))(loop_f64_plain_ptr)\n\nL = ctypes.c_int64(10)\n\nresult_f32 = ctypes.c_float()\nresult_f64 = ctypes.c_double()\n\nout_buf_f32 = ctypes.pointer(result_f32)\nout_buf_f64 = ctypes.pointer(result_f64)\n\nloop_f32_plain_fn_c(L, out_buf_f32)\nloop_f64_plain_fn_c(L, out_buf_f64)\n\n# Print the results\nprint(\"Result (float):\", result_f32.value)\nprint(\"Result (double):\", result_f64.value)\n    Result (float): 231057.875\n    Result (double): 231038.66858726053"
  },
  {
    "objectID": "c_python.html#objectifs",
    "href": "c_python.html#objectifs",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "On propose dans ce tutoriel une méthode pour l’utilisation de code C / C++ depuis Python. Les ressources à ce sujet sont très nombreuses, aussi nous allons nous placer dans un cas un peu particulier et moins étudié, c’est à dire :\n\nNous découvrirons bazel comme outil de compilation.\nNous utiliserons la bibliothèque pybind11_bazel et plus précisément les objets PyCapsule de cette bibliothèque.\nNous ouvrirons la PyCapsule côté Python en la reconstruisant avec la bibliothèque ctypes.\n\nNote: Ces choix sont motivés par l’objectif à plus long terme d’étendre la bibliothèque JAX avec du code C / C++ personnel, non couvert dans ce tutoriel. Voir par exemple https://github.com/dfm/extending-jax pour l’ancienne pipeline. Depuis JAX 0.4.31 sortie le 29 juillet 2024, l’intégration d’appel à du code C / C++ perso a été simplifié par jax.extend.ffi, voir par exemple https://jax.readthedocs.io/en/latest/ffi.html."
  },
  {
    "objectID": "c_python.html#arborescence-du-projet",
    "href": "c_python.html#arborescence-du-projet",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous allons travailler dans un projet structuré tel que :\nc_python/\n|___bazel-bin/\n||______ ...\n|___bazel-c_python/\n||______ ...\n|___bazel-out/\n||______ ...\n|___bazel-testlogs/\n||______ ...\n|___lib/\n||______BUILD.bazel\n||______loop.cpp\n|___loop.py\n|___MODULE.bazel\n|___WORKSPACE.bazel\nNous allons détailler la création et le contenu de chacun des éléments de l’arborescence."
  },
  {
    "objectID": "c_python.html#installations",
    "href": "c_python.html#installations",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous avons besoin d’un environnement Python simple dont nous ne détaillons pas l’installation.\nPour les utilisateurs linux, bazelisk est l’approche la plus simple pour installer bazel.\npybind11_bazel fournira pybind11."
  },
  {
    "objectID": "c_python.html#code-c",
    "href": "c_python.html#code-c",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Soit le fichier loop.cpp :\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;cmath&gt;\n\ntemplate &lt;typename T&gt;\nvoid loop_a_lot(const std::int64_t L, T* result) {\n    *result = 0;\n    for (int l1 = 0; l1 &lt; L; ++l1) {\n        for (int l2 = 0; l2 &lt; L; ++l2) {\n            for (int l3 = 0; l3 &lt; L; ++l3) {\n                for (int l4 = 0; l4 &lt; L; ++l4) {\n                    *result += exp(3.14);\n                }\n            }\n        }\n    }\n  }\n\npybind11::dict Registrations() {\n  pybind11::dict dict;\n  dict[\"loop_f32_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;float&gt;), \"loop_plain\");\n  dict[\"loop_f64_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;double&gt;), \"loop_plain\");\n  return dict;\n}\n\nPYBIND11_MODULE(pyloop, m) {   // please match the pybind_extension target name\n  m.def(\"registrations\", &Registrations); \n}\nLes premières lignes définissent la fonction loop_a_lot simpliste que nous voulons appeler depuis Python. La deuxième partie du code utilise la bibliothèque pybind11. Nous créons un module pyloop auquel on donne une fonction registrations qui retournera un dictionnaire avec deux entrées : une fonction loop_a_lot pour chacun des types float et double. Au détail près que nous encapsulons ces fonctions dans des PyCapsules, un object Python opaque, que Python ne semble pas être censé lire (…useful for C extension modules who need to pass an opaque value (as a void * pointer) through Python code to other C code… https://docs.python.org/3/c-api/capsule.html)"
  },
  {
    "objectID": "c_python.html#compilation-en-un-module-accessible-depuis-python",
    "href": "c_python.html#compilation-en-un-module-accessible-depuis-python",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous donnons l’origine des règles de compilations bazel dans le fichier WORKSPACE.bazel :\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\nhttp_archive(\n  name = \"pybind11_bazel\",\n  strip_prefix = \"pybind11_bazel-2.12.0\",\n  urls = [\"https://github.com/pybind/pybind11_bazel/archive/refs/tags/v2.12.0.zip\"],\n)\n# We still require the pybind library.\nhttp_archive(\n  name = \"pybind11\",\n  build_file = \"@pybind11_bazel//:pybind11-BUILD.bazel\",\n  strip_prefix = \"pybind11-2.13.0\",\n  urls = [\"https://github.com/pybind/pybind11/archive/refs/tags/v2.13.0.zip\"],\n)\nMODULE.bazel contient :\nbazel_dep(name = \"rules_python\", version = \"0.33.2\")\nLe fichier BUILD.bazel utilise la règle pybind_extension de pybind11_bazel :\nload(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")\n\npybind_extension(\n    name = \"pyloop\", # please match the PYBIND MODULE NAME\n    srcs = [\"loop.cpp\"],\n)\nEn se plaçant à la racine du projet et en exécutant bazel build //lib:pyloop nous obtenons directement le module Python voulu. Toute la complexité de la compilation est cachée par bazel. On voit que l’appel à build crée les quatre fichiers bazel-bin, bazel-c_python, bazel-out et bazel-testlogs. En particulier, le module d’intêret se situe dans bazel-bin/lib/."
  },
  {
    "objectID": "c_python.html#code-python",
    "href": "c_python.html#code-python",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous allons maintenant ouvrir les PyCapsules que nous avons à disposition dans le module pyloop fraîchement compilé, avec l’aide de la bibliothèque ctypes.\n\nOn rappelle que nous nous imposons les PyCapsules car ce sont les objets que nous devons manipuler pour exposer des fonctions C / C++ à JAX (notre objectif futur !). Voir par exemple (https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html)[https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html].\nOn note d’emblée que la manipulation de PyCapsule dans Python est compliquée par rapport à d’autres méthodes par lesquelles nous pouvons exposer des objets C / C++ à Python avec pybind11 (voir les tutoriels dans https://github.com/tdegeus/pybind11_examples). En effet, ces objets ne semblent pas être voués à être utilisés dans Python. Ouvrir la capsule avec ctypes constitue néanmoins un bon exercice avec cette bibliothèque.\n\nimport sys\nsys.path.insert(0, 'bazel-bin/lib/')\n\nimport ctypes\nimport numpy as np\n\nimport pyloop\n\nregistrations = pyloop.registrations()\n\nloop_f32_plain_capsule = registrations[\"loop_f32_plain\"]\nloop_f64_plain_capsule = registrations[\"loop_f64_plain\"]\n\n# Following is adapted from https://stackoverflow.com/questions/59887319/python-c-extension-exposing-a-capsule-to-ctypes-in-order-to-use-third-party-c-co\nPyCapsule_GetPointer = ctypes.pythonapi.PyCapsule_GetPointer\nPyCapsule_GetPointer.restype = ctypes.c_void_p\nPyCapsule_GetPointer.argtypes = [ctypes.py_object, ctypes.c_char_p]\n\nloop_f32_plain_ptr = PyCapsule_GetPointer(loop_f32_plain_capsule, b\"loop_plain\")\nloop_f64_plain_ptr = PyCapsule_GetPointer(loop_f64_plain_capsule, b\"loop_plain\")\n\n# This defines the functions signature\nloop_f32_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_float))(loop_f32_plain_ptr)\n\nloop_f64_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_double))(loop_f64_plain_ptr)\n\nL = ctypes.c_int64(10)\n\nresult_f32 = ctypes.c_float()\nresult_f64 = ctypes.c_double()\n\nout_buf_f32 = ctypes.pointer(result_f32)\nout_buf_f64 = ctypes.pointer(result_f64)\n\nloop_f32_plain_fn_c(L, out_buf_f32)\nloop_f64_plain_fn_c(L, out_buf_f64)\n\n# Print the results\nprint(\"Result (float):\", result_f32.value)\nprint(\"Result (double):\", result_f64.value)\n    Result (float): 231057.875\n    Result (double): 231038.66858726053"
  },
  {
    "objectID": "Bipartite_GNN.html",
    "href": "Bipartite_GNN.html",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "",
    "text": "library(reticulate)\n\nThe notebook shows a classical use of the package pytorch_numeric which develops Graph Neural Networks based on the logics of pytorch.\nHere we show a basic graph with the library networkx.\nWe use the dataset KarateClub() which is organized as the typical object used by pytorch_geometric: it is a list of graphs where each graph must have an object x, that represents the features of the nodes, and an object edge_index, a 2-row tensor which defines the links between the nodes (plus other possible information about the graph).\n\nimport torch\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(G, color):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    nx.draw_networkx(G, pos=nx.spring_layout(G, seed=42), with_labels=False,\n                     node_color=color, cmap=\"Set2\")\n    plt.show()\n\n\ndef visualize_embedding(h, color, epoch=None, loss=None):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    h = h.detach().cpu().numpy()\n    plt.scatter(h[:, 0], h[:, 1], s=140, c=color, cmap=\"Set2\")\n    if epoch is not None and loss is not None:\n        plt.xlabel(f'Epoch: {epoch}, Loss: {loss.item():.4f}', fontsize=16)\n    plt.show()\n\n\nfrom torch_geometric.datasets import KarateClub\n\ndataset = KarateClub()\nprint(f'Dataset: {dataset}:')\n\nDataset: KarateClub():\n\nprint(f'Number of graphs: {len(dataset)}')\n\nNumber of graphs: 1\n\nprint(f'Number of features: {dataset.num_features}')\n\nNumber of features: 34\n\nprint(f'Number of classes: {dataset.num_classes}')\n\nNumber of classes: 4\n\ndata = dataset[0]  # Get the first graph object.\n\nprint(data)\n\nData(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n\n# Gather some statistics about the graph.\nprint(f'Number of nodes: {data.num_nodes}')\n\nNumber of nodes: 34\n\nprint(f'Number of edges: {data.num_edges}')\n\nNumber of edges: 156\n\nprint(f'Average node degree: {data.num_edges / data.num_nodes:.2f}')\n\nAverage node degree: 4.59\n\nprint(f'Number of training nodes: {data.train_mask.sum()}')\n\nNumber of training nodes: 4\n\nprint(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}')\n\nTraining node label rate: 0.12\n\nprint(f'Has isolated nodes: {data.has_isolated_nodes()}')\n\nHas isolated nodes: False\n\nprint(f'Has self-loops: {data.has_self_loops()}')\n\nHas self-loops: False\n\nprint(f'Is undirected: {data.is_undirected()}')\n\nIs undirected: True\n\nedge_index = data.edge_index # the objet to give to torch_geometric, along with the features\nprint(edge_index)\n\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n\nfrom torch_geometric.utils import to_networkx\n\nG = to_networkx(data, to_undirected=True)\nvisualize_graph(G, color=data.y)"
  },
  {
    "objectID": "Bipartite_GNN.html#graph-class",
    "href": "Bipartite_GNN.html#graph-class",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "",
    "text": "library(reticulate)\n\nThe notebook shows a classical use of the package pytorch_numeric which develops Graph Neural Networks based on the logics of pytorch.\nHere we show a basic graph with the library networkx.\nWe use the dataset KarateClub() which is organized as the typical object used by pytorch_geometric: it is a list of graphs where each graph must have an object x, that represents the features of the nodes, and an object edge_index, a 2-row tensor which defines the links between the nodes (plus other possible information about the graph).\n\nimport torch\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(G, color):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    nx.draw_networkx(G, pos=nx.spring_layout(G, seed=42), with_labels=False,\n                     node_color=color, cmap=\"Set2\")\n    plt.show()\n\n\ndef visualize_embedding(h, color, epoch=None, loss=None):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    h = h.detach().cpu().numpy()\n    plt.scatter(h[:, 0], h[:, 1], s=140, c=color, cmap=\"Set2\")\n    if epoch is not None and loss is not None:\n        plt.xlabel(f'Epoch: {epoch}, Loss: {loss.item():.4f}', fontsize=16)\n    plt.show()\n\n\nfrom torch_geometric.datasets import KarateClub\n\ndataset = KarateClub()\nprint(f'Dataset: {dataset}:')\n\nDataset: KarateClub():\n\nprint(f'Number of graphs: {len(dataset)}')\n\nNumber of graphs: 1\n\nprint(f'Number of features: {dataset.num_features}')\n\nNumber of features: 34\n\nprint(f'Number of classes: {dataset.num_classes}')\n\nNumber of classes: 4\n\ndata = dataset[0]  # Get the first graph object.\n\nprint(data)\n\nData(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n\n# Gather some statistics about the graph.\nprint(f'Number of nodes: {data.num_nodes}')\n\nNumber of nodes: 34\n\nprint(f'Number of edges: {data.num_edges}')\n\nNumber of edges: 156\n\nprint(f'Average node degree: {data.num_edges / data.num_nodes:.2f}')\n\nAverage node degree: 4.59\n\nprint(f'Number of training nodes: {data.train_mask.sum()}')\n\nNumber of training nodes: 4\n\nprint(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}')\n\nTraining node label rate: 0.12\n\nprint(f'Has isolated nodes: {data.has_isolated_nodes()}')\n\nHas isolated nodes: False\n\nprint(f'Has self-loops: {data.has_self_loops()}')\n\nHas self-loops: False\n\nprint(f'Is undirected: {data.is_undirected()}')\n\nIs undirected: True\n\nedge_index = data.edge_index # the objet to give to torch_geometric, along with the features\nprint(edge_index)\n\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n\nfrom torch_geometric.utils import to_networkx\n\nG = to_networkx(data, to_undirected=True)\nvisualize_graph(G, color=data.y)"
  },
  {
    "objectID": "Bipartite_GNN.html#unipartite-gnn",
    "href": "Bipartite_GNN.html#unipartite-gnn",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "2 Unipartite GNN",
    "text": "2 Unipartite GNN\nWe create the architecture of the GNN for a unipartite graph. The architecture is made of a list of graph convolutional layers (GCL, chosen among a list of possible types of convolutions) and a MLP as last layer, which performs the learning task (node classification here). All the layers are followed by an activation function.\nPossible types of graph convolutional layers\nThe init size of the first layer is the number of features and the output size of the last layer depends on the learning task.\nEach GCL is defined as a function of two parameters : input size and output size. When defining the forward function, the GCL is called with two input parameters : x and edge_index.\nWe show the embedding (after the GCLs and before the MLP) after one pass forward to control that no error occurs.\n\nfrom torch.nn import Linear\nfrom torch_geometric.nn import GCNConv\n\nclass GCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GCNConv(dataset.num_features, 4) # num_features here is 34 (because of identity matrix), but can be 1 (for example with degree of nodes)\n        self.conv2 = GCNConv(4, 4)\n        self.conv3 = GCNConv(4, 2)\n        self.classifier = Linear(2, dataset.num_classes)\n\n    def forward(self, x, edge_index): # here the two objects needed by pytorch_geometric\n        h = self.conv1(x, edge_index)\n        h = h.tanh()\n        h = self.conv2(h, edge_index)\n        h = h.tanh()\n        h = self.conv3(h, edge_index)\n        h = h.tanh()  # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out = self.classifier(h)\n\n        return out, h\n\nmodel = GCN()\nprint(model)\n\nGCN(\n  (conv1): GCNConv(34, 4)\n  (conv2): GCNConv(4, 4)\n  (conv3): GCNConv(4, 2)\n  (classifier): Linear(in_features=2, out_features=4, bias=True)\n)\n\n_, h = model(data.x, data.edge_index)\nprint(f'Embedding shape: {list(h.shape)}')\n\nEmbedding shape: [34, 2]\n\nvisualize_embedding(h, color=data.y)\n\n\n\n\n\n\n\n\nWe then train the model with using the classical pytorch workflow defining a loss (here Cross Entropy), an optimizer (here Adam) and the number of epochs (here 151). We show the embedding every 50 epochs.\n\nimport time\n\n# Exactly the same as in torch\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion --&gt; for classification.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01)  # Define optimizer.\n\ndef train(data):\n    optimizer.zero_grad()  # Clear gradients.\n    out, h = model(data.x, data.edge_index)  # Perform a single forward pass.\n    loss = criterion(out[data.train_mask], data.y[data.train_mask])  # Compute the loss solely based on the training nodes.\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss, h\n\nfor epoch in range(151):\n    loss, h = train(data)\n    if epoch % 50 == 0:\n        visualize_embedding(h, color=data.y, epoch=epoch, loss=loss)\n        time.sleep(0.3)"
  },
  {
    "objectID": "Bipartite_GNN.html#bipartite-gnn",
    "href": "Bipartite_GNN.html#bipartite-gnn",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "3 Bipartite GNN",
    "text": "3 Bipartite GNN\nTu generalize GNN to bipartite graphs, we first need to define the type of data as BipartiteData which inherits from Data. The two types of nodes will be called source nodes and target nodes. The new object creates the source nodes and target nodes with their respective features (x_s and x_t), possibly different in size. The 2 rows in edges_index correspond to the source and target nodes, respectively.\n\nfrom torch_geometric.data import Data\nfrom torch_geometric.loader import DataLoader\nfrom torch_geometric.nn import SAGEConv\n\nclass BipartiteData(Data):\n    def __inc__(self, key, value, *args, **kwargs):\n        if key == 'edge_index':\n            return torch.tensor([[self.x_s.size(0)], [self.x_t.size(0)]])  # source and target (two classes of bipartite graph)\n        return super().__inc__(key, value, *args, **kwargs)\n\n\nx_s = torch.randn(2, 4)  # 2 nodes, 4 features.\nx_t = torch.randn(3, 2)  # 3 nodes, 2 features.\n\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index)\n\n# Plot of graph\nedge_list = list(zip(edge_index[0].tolist(),(edge_index[1]+1+max(edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n\n\n\n\n\n\n\n\nThe convolution layer is directed, hence it must be defined with the tuple of feature size of source and target nodes and the size of output of the layer, which will be given as new features to the nodes of the target.\nWe call the function with the tuple of features (x_s, x_t) and the `edge_index`.\nTo perform the inverse convolution from the target nodes to the source nodes, we must invert the values of the tuple but also invert the rows in the `edge_index`.\nOnly some of the GCLs are adapted to this configuration (look at the cheatsheet).\n\n# Direct and inverse convolutions\nConv_s_t = SAGEConv((4,2),7) # num of features is the tuple (s,t) and output is the num of features of target\n\nprint(Conv_s_t((x_s,x_t),edge_index))\n\ntensor([[ 0.5198,  0.5703,  0.6759,  0.1716, -0.6514,  0.0479, -0.5577],\n        [-0.0901,  1.5395,  0.3465,  0.0784, -1.5599,  1.1494, -0.5391],\n        [-1.0943,  0.7638,  0.2591,  0.4076, -0.5398,  0.6612, -2.2322]],\n       grad_fn=&lt;AddBackward0&gt;)\n\nConv_t_s = SAGEConv((2,4),7,aggr = \"max\")\nprint(Conv_t_s((x_t,x_s),edge_index[[1,0]])) # I need to invert the order of edge_index\n\ntensor([[-0.4040,  0.4052, -0.1868,  0.9336,  0.0030,  0.6546,  1.0335],\n        [ 0.5958, -0.1849,  0.2907,  1.4262, -0.9557,  0.4383,  0.6614]],\n       grad_fn=&lt;AddBackward0&gt;)\n\n\n\n3.1 Case study\nLatent Block Model for classification task\nTwo groups in sources, two groups in targets, with corresponding probability of connection.\nEach node has two features: 1 and its degree.\n\nn1= 25\nn2 = 50 \n\nW1 = np.random.randint(2,size=n1)\nW2 = np.random.randint(2,size=n2)\nP = np.array([[0.9,0.8],[0.5,0.1]])\nM = P[:,W2][W1,:]\n\nm = np.random.binomial(1, M)\nplt.imshow(m[np.argsort(W1),:][:,np.argsort(W2)],cmap=\"gray_r\")\n\n&lt;matplotlib.image.AxesImage object at 0x7f955a89c0d0&gt;\n\nedge_index = torch.LongTensor(([np.where(m)[0],np.where(m)[1]]))\n\n&lt;string&gt;:2: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at ../torch/csrc/utils/tensor_new.cpp:278.)\n\n\n# 1 (to count for how many neighbors) + degree  (random choice, but good when we have no other information on the network)\n\nx_s = torch.Tensor(m.sum(1).reshape(-1,1))\nx_s = torch.concat((x_s,torch.ones(x_s.shape[0],1)),1)\nx_t = torch.Tensor(m.sum(0).reshape(-1,1))\nx_t = torch.concat((x_t,torch.ones(x_t.shape[0],1)),1)\n\ndata = Data(x_s=x_s, x_t=x_t, edge_index=edge_index)\n\n\n\n\n\n\n\n\nWe define an architecture for the bipartite GNN.\n\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = SAGEConv((x_s.shape[1],x_t.shape[1]),5) \n        self.conv2 = SAGEConv((x_t.shape[1],x_s.shape[1]),10)\n        \n        self.conv3 = SAGEConv((5,10), 4)\n        self.conv4 = SAGEConv((10,5), 4) \n\n        self.classifier1 = Linear(4,2)\n        self.classifier2 = Linear(4,2)\n\n    def forward(self, x, edge_index):\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) #n2 x 5\n        h1 = h1.tanh()\n        \n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]]) #n1 x 10 # invert edge_index for the inverse convolution\n        h2 = h2.tanh()\n        \n        h3 = self.conv3((h1,h2), edge_index[[1,0]])  #n1 x 4\n        h3_2 = h3.tanh()\n        \n        h4 = self.conv4((h2,h1), edge_index) #n2 x 4\n        h4_2 = h4.tanh() # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out1 = self.classifier1(h3_2) #n1 x 4\n        out2 = self.classifier2(h4_2) #n2 x 4\n\n        return out1,out2, h3,h4\n\nBGCN1 = BGCN()\nout1,out2, h3,h4= BGCN1((x_s,x_t),edge_index) \n\nH =torch.concat([h3,h4])\ncolor0 = np.concatenate([W1,W2+2])\n\nvisualize_embedding(H, color=color0)\n\n\n\n\n\n\n\n\nWe train the model as above and print the AUC for the classes of sources and targets.\n\nimport time\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(BGCN1.parameters(), lr=0.01)  # Define optimizer.\n\ntrain_mask,test_mask = train_test_split(np.arange(n1),test_size = 0.2,stratify = W1)\ntrain_mask2,test_mask2 = train_test_split(np.arange(n2),test_size = 0.2,stratify = W2)\n\ndef train():\n    optimizer.zero_grad()  # Clear gradients.\n    out1,out2, h3,h4= BGCN1((x_s,x_t),edge_index)  # Perform a single forward pass.\n    loss1 = criterion(out1[train_mask], torch.LongTensor(W1)[train_mask])  # Compute the loss solely based on the training nodes.\n    loss2 = criterion(out2[train_mask2], torch.LongTensor(W2)[train_mask2])\n    loss = loss1+loss2\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss,out1,out2, h3,h4\n\nfor epoch in range(101):\n    loss,out1,out2, h3,h4 = train()\n    if epoch % 50 == 0:\n        H =torch.concat([h3,h4])\n        color0 = np.concatenate([W1,W2+2])\n        visualize_embedding(H, color=color0, epoch=epoch, loss=loss)\n        time.sleep(0.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ny_pred1 = out1[test_mask].argmax(1).detach().numpy()\ny_pred2 = out2[test_mask2].argmax(1).detach().numpy()\nprint(\"AUC 1 : \",roc_auc_score(W1[test_mask],y_pred1))\n\nAUC 1 :  1.0\n\nprint(\"AUC 2 : \",roc_auc_score(W2[test_mask2],y_pred2))\n\nAUC 2 :  0.75"
  },
  {
    "objectID": "Bipartite_GNN.html#mini-batches-for-pooling-operation-in-gnns",
    "href": "Bipartite_GNN.html#mini-batches-for-pooling-operation-in-gnns",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "4 Mini-batches for pooling operation in GNNs",
    "text": "4 Mini-batches for pooling operation in GNNs\nThe function DataLoader called with a list of graphs and the parameter batch_size creates a new UNCONNECTED graph with the as many different graphs as given in batch_size.\nOften, it is useful to be able to distinguish nodes from one graph to the other for different objectives such as graph classification. To keep track of which nodes belong to which graph, we can use batch.batch, that returns a vector of indices pairing each target node to its graph.\n\nfrom torch_geometric.nn import  pool\nfrom torch_geometric.loader import DataLoader\n\nx_s = torch.randn(2, 16)  # 2 nodes.\nx_t = torch.randn(3, 10)  # 3 nodes.\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index,num_nodes = x_t.shape[0])\n    \ndata_list = [data, data, data, data, data, data] # 6 identical graphs (but can be different in size, features, ...\nloader = DataLoader(data_list, batch_size=3) # the dataloader creates a new UNCONNECTED graph with the 3 different graphs\nbatch = next(iter(loader))\n\nprint(\"batch \", batch)\n\nbatch  BipartiteDataBatch(edge_index=[2, 12], x_s=[6, 16], x_t=[9, 10], num_nodes=9, batch=[9], ptr=[4])\n\nprint(\"edge_index \", batch.edge_index)\n\nedge_index  tensor([[0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5],\n        [0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8]])\n\nprint(\"node index \", batch.batch) # these are batches for target nodes (ONLY), vector of indexes\n\nnode index  tensor([0, 0, 0, 1, 1, 1, 2, 2, 2])\n\n\n\nedge_list = list(zip(batch.edge_index[0].tolist(),(batch.edge_index[1]+1+max(batch.edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,batch.edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n\n\n\n\n\n\n\n\nIf we want to pair also the source nodes, we can use the following code.\n\n# code for creating batches for source nodes, vector of indexes\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nprint(pool.global_add_pool(batch.x_t,batch.batch).shape)\n\ntorch.Size([3, 10])\n\nprint(pool.global_add_pool(batch.x_s,batch_s).shape)\n\ntorch.Size([3, 16])\n\n\n\n4.1 Real case study\nData are a list of interactions between plants and insects collected from different studies. We also know how data were collected for each study : Transect or Timed observation. This information is encoded in the boolean TO (= 1 for Timed observation). The objective is to retrieve the variable TO from the networks (graph classification).\n\n#%% Exemple on real dataset\nimport pandas as pandas\nfrom sknetwork.data import from_edge_list\nfrom torch_geometric.utils import degree\nfrom sklearn.model_selection import train_test_split\n\nNetworks = pandas.read_csv(\"Interaction data Mael.txt\", encoding=\"latin-1\",sep=\"\\t\")\nNetworks[\"plant\"] = Networks['plantgenus'] + \"_\"+ Networks['plantspecies']\nNetworks[\"insects\"] = Networks[\"insectgenus\"]+ \"_\"+ Networks[\"insectspecies\"]\n\nsupinfo = pandas.read_excel(\"supinfo.xlsx\",1)\n#torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values*1)\n\ndata_list = []\nid_network_aggreg= Networks[\"id_network_aggreg\"].unique()\nfor k in id_network_aggreg:\n    Networks2 =Networks[[\"plant\",\"insects\"]][Networks[\"id_network_aggreg\"]==k]\n    graph = from_edge_list(edge_list=list(Networks2.itertuples(index=False)),bipartite=True)\n    biadjacency = graph.biadjacency.tocoo()\n    edge_index = torch.LongTensor([graph.biadjacency.tocoo().row,graph.biadjacency.tocoo().col])\n    TO =  torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values)*1\n    \n    # we can add arguments in the function to add for example the class of the graph\n    data = BipartiteData(x_s=degree(edge_index[0],num_nodes=biadjacency.shape[0]).reshape(-1,1),\n                         x_t=degree(edge_index[1],num_nodes=biadjacency.shape[1]).reshape(-1,1),\n                         edge_index=edge_index,\n                         TO = TO,\n                         num_nodes =biadjacency.shape[1] ) # number of tartet nodes\n    data_list.append(data)\n\n\nprint(data_list[0])\n\nBipartiteData(edge_index=[2, 544], x_s=[131, 1], x_t=[113, 1], TO=[1], num_nodes=113)\n\nprint(\"data_list len : \", len(data_list))\n\ndata_list len :  123\n\n\nWe define the model architecture. Poolings layers are described here.\nWe add a pooling layer between the CGLs and the MLP in order to agregate the features from target nodes belonging to the same graph in one feature vector for each graph.\nThe pooling is made thanks to the indices vector batch.batch.\n\nfrom torch_geometric.nn import GATConv\n\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GATConv((1,1),5)\n        self.conv2 = SAGEConv((1,1),10)\n        self.conv3 = SAGEConv((self.conv2.out_channels,self.conv1.out_channels), 4)\n        \n        self.classifier1 = Linear(9,15) # 9 because 5 + 4 in the concatanation of h1 and h3\n        self.classifier2 = Linear(15,10)\n        self.classifier3 = Linear(10,1)\n        self.ReLU = torch.nn.ReLU()\n\n    def forward(self, x, edge_index,batch): #  batch is given here as input\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) \n        h1 = h1.tanh()\n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]])\n        h2 = h2.tanh()\n        h3 = self.conv3((h2,h1), edge_index)\n\n        h4 = torch.concat([h1,h3],1) # concatenation in order to have only targets and use batch as indexes \n        \n        #H = pool.global_add_pool(h4,batch) ##Pooling layer ! \n        #H = pool.global_mean_pool(h4,batch)  \n        H = pool.global_max_pool(h4,batch)  # the pooling is made graph after graph (thanks to the argument batch) \n        \n         \n        H1 = self.classifier1(H)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier2(H1)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier3(H1)\n        \n        H1 = torch.nn.Sigmoid()(H1)\n        \n        return H1\n    \n    \nloader = DataLoader(data_list, batch_size=10)\nbatch = next(iter(loader))\nprint(x_t.shape)\n\ntorch.Size([3, 10])\n\nprint(batch.batch.shape)\n\ntorch.Size([1355])\n\n\nBGCN2 = BGCN()\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nH=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch) # don't forget the argument batch.batch (on targets)\n\nWe train the model and show the AUC.\n\ny=[x.TO.item() for x in data_list]\ndata_train,data_test =train_test_split(data_list,stratify = y,test_size = 0.2,random_state=5)\n\nfrom tqdm import tqdm\nBGCN2 = BGCN()\ncriterion = torch.nn.BCELoss() # Binary Cross Entropy\noptimizer = torch.optim.Adam(BGCN2.parameters(), lr=0.01) # Define optimizer.\nloader = DataLoader(data_train, batch_size=10)\n\nloss_list = []\nfor K in tqdm(range(20)):\n    for batch in loader:\n        optimizer.zero_grad()  # Clear gradients.\n        H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)   # Perform a single forward pass.\n        loss = criterion(H,batch.TO.reshape(-1,1))\n        loss.backward() \n        optimizer.step()\n        loss_list.append(loss.item()) # Derive gradients.\n\n\n  0%|          | 0/20 [00:00&lt;?, ?it/s]\n 10%|#         | 2/20 [00:00&lt;00:00, 19.48it/s]\n 25%|##5       | 5/20 [00:00&lt;00:00, 20.52it/s]\n 40%|####      | 8/20 [00:00&lt;00:00, 20.89it/s]\n 55%|#####5    | 11/20 [00:00&lt;00:00, 21.16it/s]\n 70%|#######   | 14/20 [00:00&lt;00:00, 21.30it/s]\n 85%|########5 | 17/20 [00:00&lt;00:00, 21.45it/s]\n100%|##########| 20/20 [00:00&lt;00:00, 21.52it/s]\n100%|##########| 20/20 [00:00&lt;00:00, 21.25it/s]\n\nplt.plot(loss_list)\n\n[&lt;matplotlib.lines.Line2D object at 0x7f954800d2a0&gt;]\n\nloader_train = DataLoader(data_train, batch_size=len(data_train))\nfor batch in loader_train:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n    \nprint(\"AUC train \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n\nAUC train  0.7997448979591836\n\n    \nloader_test = DataLoader(data_test, batch_size=len(data_test))\nfor batch in loader_test:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n\nprint(\"AUC test \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n\nAUC test  0.6753246753246753"
  },
  {
    "objectID": "futureverse.html",
    "href": "futureverse.html",
    "title": "Futureverse follow-up to the tutorial",
    "section": "",
    "text": "Benchmarking\n\n\n\nAll time benchmarks are done using the {tictoc} package and on a MacBook Pro 2021 with an Apple M1 Pro chip including 10 cores and 32 GB of RAM under Sonoma 14.5 macOS.\n\n\n\n\nLet us create a slow log function:\n\nslow_log &lt;- function(x) {\n  Sys.sleep(1)\n  log(x)\n}\n\nWe can apply this function to the integers from 1 to 10 for example using purrr::map_dbl():\n\nx1 &lt;- 1:10\n\n\ntic()\npurrr::map_dbl(x1, slow_log)\ntoc()\n\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851\n\n10.064 sec elapsed\nAs expected, it takes 10 seconds to run.\nWe can parallelize this computation using furrr::future_map_dbl():\n\nplan(multisession, workers = 2)\ntic()\nfurrr::future_map_dbl(x1, slow_log)\ntoc()\n\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851\n\n5.256 sec elapsed\nAs expected, it takes 5 seconds to run.\nNow, assume that the last input value has wrongly be stored as character. Then the previous run will fail with an error. Let us see this in action:\n\nx2 &lt;- c(as.list(1:9), \"10\")\ntic()\nfurrr::future_map_dbl(x2, slow_log)\ntoc()\n\nError:\nℹ In index: 5.\nCaused by error in `log()`:\n! non-numeric argument to mathematical function\n\n5.231 sec elapsed\n\n\n\n\n\n\nApparent problem\n\n\n\nWe typically parallelize long time-consuming computations. In the context of map-reduce operations, we can have a situation where one of the tasks fails possibly after a large number of computations that succeeded. This can happen for example if the input data is not as expected. In this case, the error is caught and relayed to the user but the computation stops and elements on which computation succeeded are not returned. This is not ideal as we would like (i) to continue the computation on the other tasks and (ii) to have a way to retrieve the results of the tasks that succeeded and even of the computations that succeeded on the failed task.\n\n\n\n\n\n\n\n\n\n\n\nDesign strategy\n\n\n\nThe goal of the future framework in the context of map-reduce operations, is to help with paralellizing the application of a long-running function to a large number of inputs.\nIf the long-running function fails on some inputs, the future framework chooses by design to behave consistently with the function that is applied. This means that if the function fails on some inputs, the future framework will stop the computation and return an error.\nThe reason for this design choice is that the future framework is responsible for the parallelization of the function application, but not for the function itself. The function is responsible for its own error handling. This design choice is consistent with the principle of separation of concerns.\n\n\nIndeed, the problem is already here with purrr::map_dbl():\n\ntic()\npurrr::map_dbl(x2, slow_log)\ntoc()\n\nError in `purrr::map_dbl()`:\nℹ In index: 10.\nCaused by error in `log()`:\n! non-numeric argument to mathematical function\n\n10.107 sec elapsed\nThe error is caught, the computation stops and no result is returned. One may think that this is due to the purrr::map_dbl() function and might try to use lapply() instead:\n\ntic()\nlapply(x2, slow_log)\ntoc()\n\nError in log(x): non-numeric argument to mathematical function\n\n10.048 sec elapsed\nBut the result is the same. The error is caught, the computation stops and no result is returned.\n\n\n\n\n\n\nTrue problem\n\n\n\nThe underlying problem is that, in the context of applying the long-running slow_log() function repeatedly, we are not happy with the default behavior of stopping the computation when an error occurs in the base::log() function.\n\n\n\n\n\nThe encouraged solution is therefore to handle the error in the function itself and to return a sentinel value when an error occurs. This way, the computation can continue until the end and we can retrieve the results of the tasks that succeeded.\nWe can for example implement a new version of the slow_log() function that returns NA when an error occurs and issues a warning instead of an error:\n\nslow_log2 &lt;- function(x) {\n  tryCatch({\n    slow_log(x)\n  }, error = function(e) {\n    warning(conditionMessage(e))\n    NA_real_\n  })\n}\n\nWe can then parallelize this computation using furrr::future_map_dbl():\n\nplan(multisession, workers = 2)\ntic()\nfurrr::future_map_dbl(x2, slow_log2)\ntoc()\n\nWarning in value[[3L]](cond): non-numeric argument to mathematical function\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246        NA\n\n5.279 sec elapsed\nAs expected, it takes 5 seconds to run. Futhermore, it does not stop when an error occurs and returns NA for the failed computation which allows for the computation to continue until the end and retrieve the results of the tasks that succeeded.\nHowever, one could argue that the warning message is not informative enough because it does not give an indication of which input caused the error. Ideally one would like to know the index of the input that caused the error in the original input list of values. This requires to handle the error as a warning at the level of the future_map_dbl() function and therefore one can define a future_map_log() function which may look like this:\n\nfuture_map_log &lt;- function(.x, ..., \n                           .options = furrr::furrr_options(), \n                           .env_globals = parent.frame(), \n                           .progress = FALSE) {\n  furrr::future_imap_dbl(.x, \\(x, y) {\n    tryCatch({\n      slow_log(x)\n    }, error = function(e) {\n      cli::cli_alert_warning(\"Non-numeric input at index {y}\")\n      NA_real_\n    })\n  }, .options = .options, .env_globals = .env_globals, .progress = .progress)\n}\n\nThis leads to:\n\nplan(multisession, workers = 2)\ntic()\nfuture_map_log(x2)\ntoc()\n\n! Non-numeric input at index 10\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246        NA\n\n5.301 sec elapsed\nYou can find more details in Henrik Bengsston’s vignette dedicated to common issues with futures."
  },
  {
    "objectID": "futureverse.html#error-handling",
    "href": "futureverse.html#error-handling",
    "title": "Futureverse follow-up to the tutorial",
    "section": "",
    "text": "Benchmarking\n\n\n\nAll time benchmarks are done using the {tictoc} package and on a MacBook Pro 2021 with an Apple M1 Pro chip including 10 cores and 32 GB of RAM under Sonoma 14.5 macOS.\n\n\n\n\nLet us create a slow log function:\n\nslow_log &lt;- function(x) {\n  Sys.sleep(1)\n  log(x)\n}\n\nWe can apply this function to the integers from 1 to 10 for example using purrr::map_dbl():\n\nx1 &lt;- 1:10\n\n\ntic()\npurrr::map_dbl(x1, slow_log)\ntoc()\n\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851\n\n10.064 sec elapsed\nAs expected, it takes 10 seconds to run.\nWe can parallelize this computation using furrr::future_map_dbl():\n\nplan(multisession, workers = 2)\ntic()\nfurrr::future_map_dbl(x1, slow_log)\ntoc()\n\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851\n\n5.256 sec elapsed\nAs expected, it takes 5 seconds to run.\nNow, assume that the last input value has wrongly be stored as character. Then the previous run will fail with an error. Let us see this in action:\n\nx2 &lt;- c(as.list(1:9), \"10\")\ntic()\nfurrr::future_map_dbl(x2, slow_log)\ntoc()\n\nError:\nℹ In index: 5.\nCaused by error in `log()`:\n! non-numeric argument to mathematical function\n\n5.231 sec elapsed\n\n\n\n\n\n\nApparent problem\n\n\n\nWe typically parallelize long time-consuming computations. In the context of map-reduce operations, we can have a situation where one of the tasks fails possibly after a large number of computations that succeeded. This can happen for example if the input data is not as expected. In this case, the error is caught and relayed to the user but the computation stops and elements on which computation succeeded are not returned. This is not ideal as we would like (i) to continue the computation on the other tasks and (ii) to have a way to retrieve the results of the tasks that succeeded and even of the computations that succeeded on the failed task.\n\n\n\n\n\n\n\n\n\n\n\nDesign strategy\n\n\n\nThe goal of the future framework in the context of map-reduce operations, is to help with paralellizing the application of a long-running function to a large number of inputs.\nIf the long-running function fails on some inputs, the future framework chooses by design to behave consistently with the function that is applied. This means that if the function fails on some inputs, the future framework will stop the computation and return an error.\nThe reason for this design choice is that the future framework is responsible for the parallelization of the function application, but not for the function itself. The function is responsible for its own error handling. This design choice is consistent with the principle of separation of concerns.\n\n\nIndeed, the problem is already here with purrr::map_dbl():\n\ntic()\npurrr::map_dbl(x2, slow_log)\ntoc()\n\nError in `purrr::map_dbl()`:\nℹ In index: 10.\nCaused by error in `log()`:\n! non-numeric argument to mathematical function\n\n10.107 sec elapsed\nThe error is caught, the computation stops and no result is returned. One may think that this is due to the purrr::map_dbl() function and might try to use lapply() instead:\n\ntic()\nlapply(x2, slow_log)\ntoc()\n\nError in log(x): non-numeric argument to mathematical function\n\n10.048 sec elapsed\nBut the result is the same. The error is caught, the computation stops and no result is returned.\n\n\n\n\n\n\nTrue problem\n\n\n\nThe underlying problem is that, in the context of applying the long-running slow_log() function repeatedly, we are not happy with the default behavior of stopping the computation when an error occurs in the base::log() function.\n\n\n\n\n\nThe encouraged solution is therefore to handle the error in the function itself and to return a sentinel value when an error occurs. This way, the computation can continue until the end and we can retrieve the results of the tasks that succeeded.\nWe can for example implement a new version of the slow_log() function that returns NA when an error occurs and issues a warning instead of an error:\n\nslow_log2 &lt;- function(x) {\n  tryCatch({\n    slow_log(x)\n  }, error = function(e) {\n    warning(conditionMessage(e))\n    NA_real_\n  })\n}\n\nWe can then parallelize this computation using furrr::future_map_dbl():\n\nplan(multisession, workers = 2)\ntic()\nfurrr::future_map_dbl(x2, slow_log2)\ntoc()\n\nWarning in value[[3L]](cond): non-numeric argument to mathematical function\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246        NA\n\n5.279 sec elapsed\nAs expected, it takes 5 seconds to run. Futhermore, it does not stop when an error occurs and returns NA for the failed computation which allows for the computation to continue until the end and retrieve the results of the tasks that succeeded.\nHowever, one could argue that the warning message is not informative enough because it does not give an indication of which input caused the error. Ideally one would like to know the index of the input that caused the error in the original input list of values. This requires to handle the error as a warning at the level of the future_map_dbl() function and therefore one can define a future_map_log() function which may look like this:\n\nfuture_map_log &lt;- function(.x, ..., \n                           .options = furrr::furrr_options(), \n                           .env_globals = parent.frame(), \n                           .progress = FALSE) {\n  furrr::future_imap_dbl(.x, \\(x, y) {\n    tryCatch({\n      slow_log(x)\n    }, error = function(e) {\n      cli::cli_alert_warning(\"Non-numeric input at index {y}\")\n      NA_real_\n    })\n  }, .options = .options, .env_globals = .env_globals, .progress = .progress)\n}\n\nThis leads to:\n\nplan(multisession, workers = 2)\ntic()\nfuture_map_log(x2)\ntoc()\n\n! Non-numeric input at index 10\n\n [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n [8] 2.0794415 2.1972246        NA\n\n5.301 sec elapsed\nYou can find more details in Henrik Bengsston’s vignette dedicated to common issues with futures."
  },
  {
    "objectID": "futureverse.html#wrong-index-information-upon-error-in-furrr",
    "href": "futureverse.html#wrong-index-information-upon-error-in-furrr",
    "title": "Futureverse follow-up to the tutorial",
    "section": "Wrong index information upon error in {furrr}",
    "text": "Wrong index information upon error in {furrr}\nWhen using the {purrr} package to manipulate lists instead of base R *apply() family, the user gets to know the index of the element that caused an error:\n\npurrr::map_dbl(list(1, 2, 3, \"4\"), log)\n\nError in `purrr::map_dbl()`:\nℹ In index: 4.\nCaused by error:\n! non-numeric argument to mathematical function\n\n\nParallel versions of the purrr::*map*() functions are provided by the {furrr} package. We would expect the same behavior when an error occurs in a future:\n\nplan(multisession, workers = 2)\nfurrr::future_map_dbl(list(1, 2, 3, \"4\"), log)\n\nError:\nℹ In index: 2.\nCaused by error:\n! non-numeric argument to mathematical function\n\n\nThis is not the case. The error message does not provide the correct index of the element that caused the error. What it currently does is to provide the index in the subset of the data that was sent to the worker that failed. This is not very helpful as the user is interested in the index in the original data. This is a known issue and is discussed in Issue #250 on the GitHub repository of the package.\nIn the meantime, a workaround is to use the idea behind the purrr::imap_* functions which keeps track of the index of the element in the original list:\n\nmy_future_map_dbl &lt;- function(.x, .f, ..., \n                              .options = furrr::furrr_options(), \n                              .env_globals = parent.frame(), \n                              .progress = FALSE) {\n  furrr::future_imap_dbl(.x, \\(x, y) {\n    tryCatch({\n      .f(x)\n    }, error = function(e) {\n      cli::cli_alert_danger(\"Non-numeric input at index {y} in the original input list.\", wrap = TRUE)\n      cli::cli_alert_warning(\"The index mentioned in the message below refers to the subset of the data that was sent to the worker that failed.\", wrap = TRUE)\n    })\n  }, .options = .options, .env_globals = .env_globals, .progress = .progress)\n}\n\nThis leads to:\n\nplan(multisession, workers = 2)\nmy_future_map_dbl(list(1, 2, 3, \"4\"), log)\n\n✖ Non-numeric input at index 4 in the original input list.\n\n\n! The index mentioned in the message below refers to the subset of the data\nthat was sent to the worker that failed.\n\n\nError:\nℹ In index: 2.\nCaused by error:\n! Can't coerce from a string to a double."
  },
  {
    "objectID": "futureverse.html#futureverse-optimised-blas-mkl-openblas-veclib",
    "href": "futureverse.html#futureverse-optimised-blas-mkl-openblas-veclib",
    "title": "Futureverse follow-up to the tutorial",
    "section": "Futureverse + optimised BLAS (MKL, OpenBLAS, vecLib)",
    "text": "Futureverse + optimised BLAS (MKL, OpenBLAS, vecLib)\n\n\n\n\n\n\nBenchmarking\n\n\n\nAll time benchmarks are done using the {tictoc} package and on a Dell computer with Intel(R) Xeon(R) W-10885M CPU @ 2.40GHz processor including 8 cores and 64 GB of RAM under Windows 11.\n\n\n\nContext\nIt is possible to boost matrix calculations in R by replacing the default BLAS library with an optimized one. The most popular optimized BLAS libraries are Intel’s Math Kernel Library (MKL), OpenBLAS and vecLib (on macOS). See these articles for how to setup and/or some benchmarking:\n\nhttps://thomasmcrow.com/blog/2021-08-optimized-blas-in-r/\nhttps://mpopov.com/blog/2019/06/04/faster-matrix-math-in-r-on-macos/\nhttps://csantill.github.io/RPerformanceWBLAS/\nhttps://stateofther.github.io/finistR2023/Intel_MKL.html\n\nThese optimized BLAS libraries are typically faster than the default BLAS library that comes with R by exploiting vectorization and parallelization.\n\n\nProblem setup\n\n\n\n\n\n\nProblem\n\n\n\nThe problem is that combining the optimized BLAS libraries with the future framework seems to deteriorate the performance of the optimized BLAS and leads to increased computation time.\n\n\n\n\nUse of parallelization in optimized BLAS libraries\nBy default, it uses all available cores. However, the optimization is mostly due to vectorization and rather than parallelization. See this webpage for a better understanding of the gain one can expect from MKL. Importantly, it is mentioned that:\n\nMost of the benefit of the Intel MKL is from vectorised math, not multi-threading. A big performance boost when using the MKL with just one thread. A marginal increase when using 4 threads, most notable in matrix multiply, and no benefit for singular value decomposition.\n\nAnother resource on HCP here.\n\n\nExample 1: matrix inversion\n\n## Have a look at the nb of cores / threads\n## Nb cores\nRhpcBLASctl::get_num_cores()\n## Nb threads \nRhpcBLASctl::get_num_procs()\n\n## Generate a list of matrices to inverse\nN &lt;- 16    ## Matrix number\np &lt;- 2000   ## Matrix size\nx &lt;- lapply(1:N, \\(i) matrix(rnorm(p * p), p, p) + diag(p))\n\n## Make a function that controls the number of threads used by the math lib \n## to compute the matrix inverse\ncompute_inv &lt;- function(x, nbthr = 1) {\n  RhpcBLASctl::blas_set_num_threads(threads = nbthr)\n  solve(x)\n}\n\n\n## Default \ntic()\nres &lt;- lapply(x, solve)\ntoc()\n\n2.56 sec elapsed\n\n## Then disable MKL parallel computation\ntic()\nres &lt;- lapply(x, compute_inv, nbthr = 1)\ntoc()\n\n2.71 sec elapsed\n\n## Then use future but without parallelization\nplan(sequential)\ntic()\nres &lt;- furrr::future_map(x, compute_inv, nbthr = 1)\ntoc()\n\n2.8 sec elapsed\nReducing the nb of threads does not affect the computational time! The computational cost reduction is due to vectorization, not multi-threading.\n\n## Now use 2 workers\nplan(multisession, workers = 2)\ntic()\nres &lt;- furrr::future_map(x, compute_inv, nbthr = 1)\ntoc()\n\n4.19 sec elapsed\n\n## Now use 4 workers\nplan(multisession, workers = 4)\ntic()\nres &lt;- furrr::future_map(x, compute_inv, nbthr = 1)\ntoc()\n\n5.03 sec elapsed\n\n## Now use 8 workers\nplan(multisession, workers = 8)\ntic()\nres &lt;- furrr::future_map(x, compute_inv, nbthr = 1)\ntoc()\n\n5.5 sec elapsed\n\n## Now use 16 workers\nplan(multisession, workers = 16)\ntic()\nres &lt;- furrr::future_map(x, compute_inv, nbthr = 1)\ntoc()\n\n7.68 sec elapsed\nSystematic downgrading of the performance, the higher the nb of workers, the higher the computational time.\n\n\nExample 2: matrix product\n\n## Generate a list of pairs of matrices to multiply with a ref matrix\nN &lt;- 16    ## Matrix number\nNbRow &lt;- 5000   ## Matrix nb row\nNbCol &lt;- 1000   ## Matrix nb row\n\nx &lt;- lapply(1:N, \\(i) matrix(rnorm(NbRow * NbCol), NbRow, NbCol))\nRefMat &lt;- matrix(rnorm(NbRow * NbCol), NbRow, NbCol) \n\n## Make a function that controls the number of threads used by the math lib \n## to compute the matrix crossprod\nComputeProd &lt;- function(x,nbthr=1){\n  blas_set_num_threads(threads = nbthr)\n  crossprod(x,RefMat)\n}\n\nUsing the same setup as for Example 1, we get the following computational times:\n\nDefault (MKL parallel computation): 0.67 sec;\nDisable MKL parallel computation: 2.74 sec;\nFuture without parallelization: 2.95 sec;\nFuture with 2 workers: 2.95 sec;\nFuture with 4 workers: 2.89 sec;\nFuture with 8 workers: 4 sec;\nFuture with 16 workers: 6.71 sec.\n\n\n\nCurrent understanding\nFor now the results are not intuitive at all:\n\nsolve mostly makes use of vectorization from MKL, as illustrated by the fact that changing the number of threads does not change the performance;\nin contrast, crossprod benefits from multi-threading: reducing the number of threads downgrades the computational speed.\n\nSo we expect that reducing the number of threads to \\(1\\) will not hamper solve(), allowing the use of futures for parallelization over matrices. We should observe some (significant ?) gain. However, as soon as we increase the number of workers, we downgrade the performance. Differently, in the matrix product case, if we reduce the number of threads used by MKL, we allow for parallelization over matrices via futures but at the cost of some increase in computational time for each cross product. So there seems to be a trade-off, possibly hard to deal with, between the implicit multi-threading of MKL and the explicit one of future. However we basically observe no impact when the number of workers is low, and a downgrade when it is increased…"
  },
  {
    "objectID": "futureverse.html#using-source-in-a-future",
    "href": "futureverse.html#using-source-in-a-future",
    "title": "Futureverse follow-up to the tutorial",
    "section": "Using source() in a future",
    "text": "Using source() in a future\nAccording to Henrik Bengsston’s vignette dedicated to common issues with futures:\n\nAvoid using source() inside futures. It is always better to source external R scripts at the top of your main R script, e.g.\n\n\nlibrary(future)\nsource(\"./my-script.R\")\n\nf &lt;- future({\n  ...\n})\n\n\nHowever, if you find yourself having to source a script inside a future, or inside a function, make sure to specify argument local = TRUE, e.g.\n\n\nf &lt;- future({\n  source(\"./my-script.R\", local = TRUE)\n  ...\n})\n\n\nThis is because source() defaults to local = FALSE, which has side effects. When using local = FALSE, any functions or variables defined by the R script are assigned to the global environment - not the calling environment as we might expect. This may make little different when calling source() from the R prompt, or from another script. However, when called from inside a function, inside local(), or inside a future, it might result in unexpected behavior. It is similar to using assign(\"a\", 42, envir = globalenv()), which is known be a bad practice. To be on the safe side, it is almost always better call source() with local = TRUE."
  },
  {
    "objectID": "futureverse.html#sharing-big-matrices-between-r-processes",
    "href": "futureverse.html#sharing-big-matrices-between-r-processes",
    "title": "Futureverse follow-up to the tutorial",
    "section": "Sharing big matrices between R processes",
    "text": "Sharing big matrices between R processes\n\nThe {bigmemory} package provides mechanisms for working with very large matrices that can be updated in-place, which helps save memory.\n\n\n\n\n\n\n\nProblem of non-exportable objects\n\n\n\n\nSome types of R objects can be used only in the R session they were created. If used as-is in another R process, such objects often result in an immediate error or in obscure and hard-to-troubleshoot outcomes. Because of this, they cannot be saved to file and re-used at a later time. They may also not be exported to a parallel worker when doing parallel processing. These objects are sometimes referred to as non-exportable or non-serializable objects.\n\n\n\nObjects of class big.matrix are non-exportable as-is. This means that they cannot be exported to a parallel worker when doing parallel processing. This is because the object is a reference to a memory-mapped file, and the worker does not have access to the memory-mapped file.\n\n\n\n\n\n\nThe marshalling solution\n\n\n\n\nOne solution to this problem is to use “marshalling” to encode the R object into an exportable representation that then can be used to re-create a copy of that object in another R process that imitates the original object.\n\n\n\n\nThe {marshal} package provides generic functions marshal() and unmarshal() for marshalling and unmarshalling R objects of certain class. This makes it possible to save otherwise non-exportable objects to file and then be used in a future R session, or to transfer them to another R process to be used there.\n\nAs part of the development of the marshal package, the author has listed a number of classes that are non-exportable and assessed whether they can be marshalled and whether they must be marshalled. The list is available in an article from the package website here. One can see that the class big.matrix is in the list of non-exportable classes and has been assessed as a class that can and must be marshalled. This means that the marshal package will soon be able to marshal and unmarshal objects of class big.matrix.\n\n\n\n\n\n\nActive working group on marshalling and serialization\n\n\n\nMay 2024: The R Consortium ISC Working Group ‘Marshaling and Serialization in R’ has been launched to work on this problem. So we can expect some progress in the near future."
  },
  {
    "objectID": "futureverse.html#nested-parallelization-with-future",
    "href": "futureverse.html#nested-parallelization-with-future",
    "title": "Futureverse follow-up to the tutorial",
    "section": "Nested parallelization with {future}",
    "text": "Nested parallelization with {future}\n\n\n\n\n\n\nBenchmarking\n\n\n\nAll time benchmarks are done using the {tictoc} package and on a Lenovo LOQ 15IRH8 with an Intel i5-12450H including 12 cores and 16 GB of RAM under Ubuntu 24.04.1 LTS.\n\n\n\nlibrary(future)\nlibrary(future.apply)\nlibrary(future.callr)\nlibrary(progressr)\n\n\nNested task definition\nWe define the following task where we split a sum in sub-sums and perform this multiple times. To slow down computations, we use progressr::slow_sum.\n\ndelay &lt;- 0.5\n\nlist_sums &lt;- list(1:10, 11:20)\nlist_list_sums &lt;- rep(list(list_sums), 2L)\nfuture_nested_loop &lt;- function() {\n    unlist(future.apply::future_lapply(list_list_sums, function(l_sums) {\n        v_sums &lt;- unlist(\n            future.apply::future_lapply(l_sums, slow_sum,\n                delay = delay,\n                message = FALSE\n            )\n        )\n        sum(v_sums)\n    }))\n}\n\nBelow we implement a checking function to ensure everything went fine and the returned result was correct.\n\nexpected_result &lt;- rep(sum(unlist(list_sums)), length(list_list_sums))\n\ncheck_result &lt;- function(task_time, task_result) {\n    if (!all(task_result == expected_result)) {\n        cli::cli_abort(message = c(\"{task_time$msg} result do not match expected result\",\n            \"x\" = \"Expected : {expected_result} got {task_result}\"\n        ))\n    } else {\n        cli::cli_alert_success(\"Task returned expected result\")\n    }\n}\n\n\n\nR and base plan with {future}\n\nBase R and plan(sequential)\nWith R base functions :\n\ntic(\"Base R\")\nbase_r_result &lt;- unlist(lapply(list_list_sums, function(l_sums) {\n    v_sums &lt;- unlist(\n        lapply(l_sums, slow_sum, delay = delay, message = FALSE)\n    )\n    sum(v_sums)\n}))\nbase_r_time &lt;- toc()\n\nBase R: 20.076 sec elapsed\n\ncheck_result(task_time = base_r_time, base_r_result)\n\n✔ Task returned expected result\n\n\nWith our delay values we have the following :\n\n\\(10 \\times 0.5s\\) for each sub-sum.\n\\(2 \\times 10 \\times 0.5s\\) for each sub-list of sub-sum\n\nSo \\(2 \\times 2 \\times 10 \\times 0.5 s\\) for the list of sub-lists of sub-sums, so \\(20 s\\). Which is what we approximately observe with {tictoc}:\n\\(20.076 s\\).\nAvec le plan sequential\n\nplan(sequential)\ntic(\"Future plan(sequential)\")\nsequential_result &lt;- future_nested_loop()\nsequential_time &lt;- toc()\n\nFuture plan(sequential): 20.145 sec elapsed\n\ncheck_result(\n    task_time = sequential_time,\n    task_result = sequential_result\n)\n\nWith sequential plan it takes \\(20.145\\) s, which is comparable withR base functions.\n\n\nplan(multisession)\n\nplan(tweak(\"multisession\", workers = 2L))\ntic(\"Future plan(tweak('multisession', workers = 2L))\")\nmultisession2_result &lt;- future_nested_loop()\nmultisession2_time &lt;- toc()\n\nFuture plan(tweak('multisession', workers = 2L)): 10.365 sec elapsed\n\ncheck_result(\n    task_time = multisession2_time,\n    task_result = multisession2_result\n)\n\n✔ Task returned expected result\n\n\nBy allocating 2 workers with multisession we manage to obtain a duration below sequential: \\(10.365\\) s.\n\nplan(multisession(workers = 4L))\ntic(\"Future plan(multisession(workers = 4L))\")\nmultisession4_result &lt;- future_nested_loop()\nmultisession4_time &lt;- toc()\n\nFuture plan(multisession(workers = 4L)): 10.404 sec elapsed\n\ncheck_result(\n    task_time = multisession4_time,\n    task_result = multisession4_result\n)\n\n✔ Task returned expected result\n\n\nBy allocating 4 workers, we observe no improvement, it takes: \\(10.404\\) s.\nThis is because {future} doesn’t leverage nested parallelization by default, the first future_lapply being on a two elements list, the maximal reduction time is obtained with two workers. The other two allocated in this example are not used.\n\n\n\nNested parallelization\nAccording to the documentation we can specify not only a single plan but a list of plans, that can apply to nested futures.\n\nplan(list(multisession, multisession))\ntic(\"Future plan(list(multisession, multisession))\")\nlist_multisession_result &lt;- future_nested_loop()\nlist_multisession_time &lt;- toc()\n\nFuture plan(list(multisession, multisession)): 10.651 sec elapsed\n\ncheck_result(\n    task_time = list_multisession_time,\n    task_result = list_multisession_result\n)\n\n✔ Task returned expected result\n\n\nBut at the opposite of what we expected, we do not lower the time taken but it increases ! The task takes: \\(10.651\\) s.\n\n\n\n\n\n\nNote\n\n\n\nAs Henrik Bengtsson explains in the vignette Future Topologies, {future} has a protection against recursive parallelism. And thus the second loop is not parallelized but forced to be sequential.\nThe plan must thus be specified in a specific manner to work as intended.\n\n\n\nPlan lists with explicit parameters\nGiven the structure of our task we want the first loop to run on the 2 elements of the list in parallel, thus we need 2 workers for the first future_lapply.\nEach sub-list containing 2 elements, we want to allocate each 2 workers.\nAs we want to parallelize the whole task we need: \\(2 \\times 2 =\n4\\) workers to allocate.\n\nplan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = 2L)))\ntic(\"Future plan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = 2L)))\")\nlist_multisession2_2_result &lt;- rlang::try_fetch(\n    future_nested_loop(),\n    error = function(cnd) inform(\"Task failed.\", parent = cnd)\n)\n\nWarning in checkNumberOfLocalWorkers(workers): Careful, you are setting up 2\nlocalhost parallel workers with only 1 CPU cores available for this R process\n(per ‘mc.cores’), which could result in a 200% load. The soft limit is set to\n100%. Overusing the CPUs has negative impact on the current R process, but also\non all other processes of yours and others running on the same machine. See\nhelp(\"parallelly.options\", package = \"parallelly\") for how to override the soft\nand hard limits\nWarning in checkNumberOfLocalWorkers(workers): Careful, you are setting up 2\nlocalhost parallel workers with only 1 CPU cores available for this R process\n(per ‘mc.cores’), which could result in a 200% load. The soft limit is set to\n100%. Overusing the CPUs has negative impact on the current R process, but also\non all other processes of yours and others running on the same machine. See\nhelp(\"parallelly.options\", package = \"parallelly\") for how to override the soft\nand hard limits\n\nlist_multisession2_2_time &lt;- toc()\n\nFuture plan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = 2L))): 6.349 sec elapsed\n\ncheck_result(\n    task_time = list_multisession2_2_time,\n    task_result = list_multisession2_2_result\n)\n\n✔ Task returned expected result\n\n\nWith this plan we get some warnings, explaining the we are over-parallelizing. We get this message even if we have the correct number of cores (or workers) to properly run this task.\nThis is {future} defense mecanism against recursive parallelism.\n\n\n\n\n\n\nWhy shouldn’t I ignore this warning\n\n\n\n{future} has a soft limit (that gives warnings) and a hard limit, when reaching the hard limit (of 300% load per core) the future won’t run, even if there is enough available cores.\nThe next callout block and next code block explains how to tell {future} that this plan is ok.\n\n\n\n\n\n\n\n\nLet {future} know that we want recursive parallelism\n\n\n\nTo tell the package that we know what we are doing, we must use I() which gives AsIs class to the object it wraps.\n\n\n\nplan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = I(2L))))\ntic(\"Future plan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = I(2L))))\")\nlist_multisession2_I2_result &lt;- rlang::try_fetch(\n    future_nested_loop(),\n    error = function(cnd) inform(\"Task failed.\", parent = cnd)\n)\nlist_multisession2_I2_time &lt;- toc()\n\nFuture plan(list(tweak(multisession, workers = 2L), tweak(multisession, workers = I(2L)))): 6.396 sec elapsed\n\ncheck_result(\n    task_time = list_multisession2_I2_time,\n    task_result = list_multisession2_I2_result\n)\n\n✔ Task returned expected result\n\n\nAnd this way we can specify a working nested parallelization plan.\n\n\nWith {future.callr}\nThe {future.callr} package solves some limitations of future::multisession() and do not need the use of I() as shown in the below example:\n\nplan(list(tweak(callr, workers = 2L), tweak(callr, workers = 2L)))\ntic(\"Future `plan(list(tweak(callr, workers = 2L), tweak(callr, workers = 2L)))`\")\nlist_callr2_2_result &lt;- rlang::try_fetch(\n    future_nested_loop(),\n    error = function(cnd) inform(\"Task failed.\", parent = cnd)\n)\nlist_callr2_2_time &lt;- toc()\n\nFuture `plan(list(tweak(callr, workers = 2L), tweak(callr, workers = 2L)))`: 6.299 sec elapsed\n\ncheck_result(\n    task_time = list_callr2_2_time,\n    task_result = list_callr2_2_result\n)\n\n✔ Task returned expected result\n\n\n\n\n\nExecution time summary table\n\n\n\n\n\n\n\n\n\nfuture::plan(.)\nElapsed time\n\n\n\n\nBase R\n20.076\n\n\nsequential\n20.145\n\n\nmultisession(workers = 2L)\n10.365\n\n\nmultisession(workers = 4L)\n10.404\n\n\nlist(multisession, multisession)\n10.651\n\n\nlist(tweak(multisession, workers = 2L), tweak(multisession, workers = 2L))\n6.349\n\n\nlist(tweak(multisession, workers = 2L), tweak(multisession, workers = I(2L)))\n6.396\n\n\nlist(tweak(callr, workers = 2L), tweak(callr, workers = 2L))\n6.299"
  },
  {
    "objectID": "instructions.html",
    "href": "instructions.html",
    "title": "Instructions pour le dépot sur le site web",
    "section": "",
    "text": "Protocole https :\ngit clone https://github.com/StateOfTheR/finistR2024.git\nAvec clés SSH : git clone git@github.com:git@github.com:StateOfTheR/finistR2024.git\n\n\n(Lien vers une doc complète)[https://docs.github.com/fr/get-started/getting-started-with-git/managing-remote-repositories]."
  },
  {
    "objectID": "instructions.html#cloner-le-dépôt-git-du-bootcamp",
    "href": "instructions.html#cloner-le-dépôt-git-du-bootcamp",
    "title": "Instructions pour le dépot sur le site web",
    "section": "",
    "text": "Protocole https :\ngit clone https://github.com/StateOfTheR/finistR2024.git\nAvec clés SSH : git clone git@github.com:git@github.com:StateOfTheR/finistR2024.git\n\n\n(Lien vers une doc complète)[https://docs.github.com/fr/get-started/getting-started-with-git/managing-remote-repositories]."
  },
  {
    "objectID": "instructions.html#processus-de-mise-en-commun-des-ateliers",
    "href": "instructions.html#processus-de-mise-en-commun-des-ateliers",
    "title": "Instructions pour le dépot sur le site web",
    "section": "Processus de mise en commun des ateliers",
    "text": "Processus de mise en commun des ateliers\n\nCréer une branche propre à l’atelier nommée explicitement mon_nom_parlant et basculer dessus\n\ngit checkout -b mon_nom_parlant\n\nCréer un fichier Rmarkdown de restitution de votre atelier fichier.Rmd dans votre branche\n\ngit add fichier.Rmd\ngit commit -m \"restitution atelier\"\n\nPousser vos modifications sur le serveur distant\n\ngit  push --set-upstream origin mon_nom_parlant ou\ngit  push\n\nFaire une pull request (PR) sur github\nindiquer dans le message de la PR la liste des packages ou autres besoins\nQuand la PR passe les tests, demander le merge.\ncorriger les erreurs éventuelles dans la compilation du Rmarkdown\nles admins peuvent avoir à mettre à jour l’image docker"
  },
  {
    "objectID": "instructions.html#détails-du-fonctionnement",
    "href": "instructions.html#détails-du-fonctionnement",
    "title": "Instructions pour le dépot sur le site web",
    "section": "Détails du fonctionnement",
    "text": "Détails du fonctionnement\n\nLe docker\n(Lien vers la fiche pense-bête)[https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf]\nPour créer des images Docker en local sur sa machine, voici une liste de commandes utiles\n\nPour construire une image docker, il faut créer un fichier Dockerfile qui contient la recette du Docker. Pour ce site le ficher Dockerfile a la forme suivante\n\n\n\n\nFROM rocker/geospatial:4.4\nRUN export DEBIAN_FRONTEND=noninteractive; apt-get -y update \\\n && apt-get install -y pandoc \\\n    pandoc-citeproc\nRUN R -e \"install.packages('remotes')\"\nRUN R -e \"install.packages('microbenchmark')\"\nRUN R -e \"install.packages('purrr')\" # map function\nENV R_CRAN_WEB=\"https://cran.rstudio.com/\"\nRUN R -e \"install.packages('cowplot')\" # GET function\nRUN R -e \"install.packages('torch')\"\nRUN R -e \"torch::install_torch(type = 'cpu')\"\nRUN R -e \"install.packages('PLNmodels')\"\nRUN R -e \"install.packages('torchvision')\"\n\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends \\\n  mercurial gdal-bin libgdal-dev gsl-bin libgsl-dev \\\n  libc6-i386\n\nRUN R -e \"install.packages('reticulate')\"\nRUN R -e \"install.packages(c('inlabru', 'lme4', 'ggpolypath', 'RColorBrewer', 'geoR'))\"\nRUN R -e \"install.packages(c('poissonreg'))\"\nRUN apt-get install -y --no-install-recommends unzip python3-pip dvipng pandoc wget git make python3-venv && \\\n    pip3 install jupyter jupyter-cache flatlatex matplotlib && \\\n    apt-get --purge -y remove texlive.\\*-doc$ && \\\n    apt-get clean\nRUN R -e  \"remotes::install_github('Yu-Group/simChef')\"\n\n\npuis demander la construction de l’image à l’aide de la commande\n\n docker build -t nom_depot_dockerhub/nom_du_repo:version  . ## avec un nom\n\net enfin pousser sur Dockerhub\n\n docker push nom_depot_dockerhub/nom_du_repo:version\n\n\n\nLes actions\nDans les action de Github, on peut spécifier un container docker à utiliser, c’est ce que fait la ligne container du fichier d’action suivant, utiliser pour créer ce site web\n\n\nname: website\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    name: Build website with rmarkdown and Julia\n    runs-on: ubuntu-latest\n    container: stateofther/r-finistr2024:0.2\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Install Julia\n        uses: julia-actions/setup-julia@v1\n        with:\n          version: \"1.8\" # Specify the Julia version you want to use\n      - name: Install Julia Packages\n        run: |\n          julia -e 'using Pkg; Pkg.add([\"DataFrames\", \"DataFramesMeta\", \"RDatasets\", \"CairoMakie\", \"Gadfly\", \"Compose\", \"AlgebraOfGraphics\"])'\n      - name: Additional R packages\n        run: |\n          Rscript -e \"install.packages(c('tictoc', 'nimble', 'ggmcmc', 'compareMCMCs', 'nimbleHMC', 'mvtnorm'))\"\n          Rscript -e \"install.packages(c('simulator', 'simpr', 'SimEngine', 'DT', 'withr', 'bench'))\"\n          Rscript -e \"install.packages(c('future', 'furrr', 'purrr', 'cli', 'RhpcBLASctl'))\"\n          Rscript -e \"install.packages('rix', repos = c('https://b-rodrigues.r-universe.dev', 'https://cloud.r-project.org'))\"\n      - name: Additional Python packages\n        run: |\n          pip install torch torch_geometric \n          pip install numpy==1.26.1\n          pip install scikit-learn scikit-network networkx matplotlib tqdm openpyxl pandas\n      - name: Generate slides\n        run: \"quarto render\"\n      - name: GitHub Pages action\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./_site"
  },
  {
    "objectID": "01_nimble.html",
    "href": "01_nimble.html",
    "title": "Introduction to nimble",
    "section": "",
    "text": "library(compareMCMCs)\nlibrary(ggmcmc)\nlibrary(mvtnorm)\nlibrary(nimble)\nlibrary(nimbleHMC)\nlibrary(tidyverse)"
  },
  {
    "objectID": "01_nimble.html#toy-model",
    "href": "01_nimble.html#toy-model",
    "title": "Introduction to nimble",
    "section": "Toy model",
    "text": "Toy model\nWe observe a sample \\(Y_1,\\dots, Y_n\\) of i.i.d. random variables having a negative binomial distribution with parameter \\(p \\in [0, 1]\\) and \\(\\theta \\in \\mathbb{R}_+^*\\). Formally, for \\(i \\in \\lbrace 1,\\dots, n\\rbrace\\), and \\(k \\in \\mathbb{N}\\), we have that:\n\\[\n\\mathbb{P}\\left(Y_i = k \\vert p, \\theta\\right) = \\frac{\\Gamma(k + \\theta)}{k!\\Gamma(\\theta)}p^\\theta(1 - p)^k\\,.\n\\]\nLet’s simulate data from this model with \\(n = 100, p = 0.4\\) and \\(\\theta = 12\\):\n\nset.seed(123) # For reproducibility\ndata_ex1 &lt;- rnbinom(n = 100, prob = 0.4, size = 12)\n\nOur goal is to estimate \\(p\\) and \\(\\theta\\) from these observations, within a Bayesian framework. For this tutorial, we assume the following priors: \\[\\begin{align*}\n\\theta &\\sim \\mathcal{E}(0.1)\\,,\\\\\np &\\sim \\mathcal{U}\\left[0, 1\\right]\\,.\\\\\n\\end{align*}\\]"
  },
  {
    "objectID": "01_nimble.html#defining-a-negative-binomial-model-in-nimble",
    "href": "01_nimble.html#defining-a-negative-binomial-model-in-nimble",
    "title": "Introduction to nimble",
    "section": "Defining a negative binomial model in nimble",
    "text": "Defining a negative binomial model in nimble\nBasically, as in BUGSor JAGS, the user’s role is to write the way to simulate the data and to give the prior distributions of the unkown. This is done within the nimbleCode function. This function will typically need to use built-in distributions that can be seen in the native documentation. All random variables must be assigned using the ~ symbol while deterministic quantities are assigned using the &lt;- or = as in R. Overall, the syntax is quite similar to R.\n\ncode_neg_bin &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # PRIORS\n  prob ~ dunif(0, 1)\n  theta ~ dexp(0.1)\n})\n\nNote that in this code, nothing distinguishes observed data from unknown (or latent variables). The order of lines has no importance as everything will be compiled afterwards."
  },
  {
    "objectID": "01_nimble.html#defining-the-nimble-model",
    "href": "01_nimble.html#defining-the-nimble-model",
    "title": "Introduction to nimble",
    "section": "Defining the nimble model",
    "text": "Defining the nimble model\nNow that the code exists, we define the model. That’s here that data and constants will be provided. Typically, data are quantities which are considered as realizations of random variables in the code, while constants are not.\n\nmodel_neg_bin &lt;- nimbleModel(code = code_neg_bin, \n                             name = \"Negative binomial\", \n                             constants = list(n = length(data_ex1)),\n                             data = list(y = data_ex1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n\n\nNote that the code points that we did not give initial guesses (which would typically be starting points for MCMC sampling algorithms). We will do it in the sampling step."
  },
  {
    "objectID": "01_nimble.html#basic-mcmc-sampling",
    "href": "01_nimble.html#basic-mcmc-sampling",
    "title": "Introduction to nimble",
    "section": "Basic MCMC sampling",
    "text": "Basic MCMC sampling\nA direct way to proceed is to use the nimbleMCMC function that provides basic Metropolis Hastings within Gibbs sampling.\n\nposterior_samples_neg_bin &lt;- nimbleMCMC(model_neg_bin,\n                                        inits = list(prob = 0.5, theta = 1),\n                                        nchains = 2, # Number of independent chains \n                                        niter = 10000, # Number of it. per chain\n                                        thin = 10, # Thinning\n                                        nburnin = 1000) # Number of initial iterations discarded\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|"
  },
  {
    "objectID": "01_nimble.html#exploring-the-results",
    "href": "01_nimble.html#exploring-the-results",
    "title": "Introduction to nimble",
    "section": "Exploring the results",
    "text": "Exploring the results\nNow that we have performed MCMC sampling, we can access the results, which are lists (one element per chain) of matrices having \\(n_{\\text{iter}}\\) rows and \\(n_{\\text{parameters}}\\) columns.\n\nstr(posterior_samples_neg_bin)\n\nList of 2\n $ chain1: num [1:900, 1:2] 0.334 0.328 0.333 0.334 0.315 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n $ chain2: num [1:900, 1:2] 0.343 0.363 0.379 0.336 0.352 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n\n\nTo perform any post processing or plotting results, a bit of formatting must be done.\n\nformatted_results &lt;- imap_dfr(posterior_samples_neg_bin, \n                              function(x, nm){\n                                as.data.frame(x) %&gt;% \n                                  rowid_to_column(var = \"Iteration\") %&gt;% \n                                  mutate(Chain = str_remove(nm, \"chain\"))\n                              }) %&gt;% \n  pivot_longer(cols = -c(\"Iteration\", \"Chain\"),\n               names_to = \"Parameter\", \n               values_to = \"value\")\n\nWe can then perform usual plots.\n\nggplot(formatted_results) +\n  aes(x = Iteration,\n      y = value, color = Chain) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Sample ID\", y = \"Parameter value\", color = \"\")\n\n\n\n\n\n\n\n\n\nPackage for automatic formatting of results\nFor ggplotusers, the ggmcmc package provide useful tools for plots and formatting of MCMC outputs in R (not necessarily for the nimble package). This package is suited for any coda object, which is an historic format for MCMC outputs in R. We can specify during the sampling that we want outputs to be in coda.\n\nposterior_samples_neg_bin &lt;- nimbleMCMC(model_neg_bin, \n                                        nchains = 2, \n                                        niter = 10000, \n                                        thin = 10, \n                                        nburnin = 1000,\n                                        samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nWe can see that this modifies the type of output:\n\nstr(posterior_samples_neg_bin)\n\nList of 2\n $ chain1: 'mcmc' num [1:900, 1:2] 0.286 0.31 0.301 0.304 0.348 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n $ chain2: 'mcmc' num [1:900, 1:2] 0.398 0.412 0.419 0.429 0.433 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n - attr(*, \"class\")= chr \"mcmc.list\"\n\n\nNow, we can use the ggsfunction which performs the post processing that we made above.\n\nformatted_results &lt;- ggs(posterior_samples_neg_bin)\nformatted_results # same as above\n\n# A tibble: 3,600 × 4\n   Iteration Chain Parameter value\n       &lt;int&gt; &lt;int&gt; &lt;fct&gt;     &lt;dbl&gt;\n 1         1     1 prob      0.286\n 2         2     1 prob      0.310\n 3         3     1 prob      0.301\n 4         4     1 prob      0.304\n 5         5     1 prob      0.348\n 6         6     1 prob      0.325\n 7         7     1 prob      0.308\n 8         8     1 prob      0.346\n 9         9     1 prob      0.358\n10        10     1 prob      0.383\n# ℹ 3,590 more rows\n\n\nThen, everything works as before!."
  },
  {
    "objectID": "01_nimble.html#defining-a-nimblefunction",
    "href": "01_nimble.html#defining-a-nimblefunction",
    "title": "Introduction to nimble",
    "section": "Defining a nimbleFunction",
    "text": "Defining a nimbleFunction\nWhat makes nimble’s popularity is it suitability for statistical programming.\nAs your specific model will certainly requires specific functions, we cannot expect to find all our tools in the built-in function.\nHowever, we can define new functions in a syntax which is pretty similar to R.\n\nAlternative parameterization of the negative binomial\nSuppose now we want to perform negative binomial regression. In this context, we model the expectation (typically through a link to some covariates) of the response variable. Typically, if we denote, for all \\(1\\leq i \\leq n\\), \\(\\mu = \\mathbb{E}\\left[Y_i\\right]\\), we assume the following prior:\n\\[\n\\ln \\mu \\sim \\mathcal{N}\\left(0, 1\\right)\\,.\n\\] Sadly, in nimble, we do not have access to an implementation of the negative binomial distribution parameterized by \\((\\mu,  \\theta)\\). However, we know that: \\[\n\\mu = \\theta \\times \\frac{1 - p}{p}\\,,\n\\] or, equivalently, that: \\[\np = \\frac{\\theta}{\\theta + \\mu}\n\\]\n\nget_p_from_mu &lt;- nimbleFunction(\n  run = function(mu = double(0),\n                 theta = double(0)) { # type declarations\n    returnType(double(0))  # return type declaration\n    output &lt;- theta / (theta + mu)\n    return(output)\n  })\nget_p_from_mu(18, 12) # Works as a usual R function\n\n[1] 0.4\n\n\n\ncode_alternatif &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # Alternative vectorized formulation \n  # y[1:n] ~ dnbinom(prob, theta)\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  theta ~ dexp(0.1)\n  # Quantites deterministes\n  mu &lt;- exp(log_mu)\n  prob &lt;- get_p_from_mu(mu = mu, theta = theta)\n})\n\nmodel_alternatif &lt;- nimbleModel(code = code_alternatif, \n                                name = \"Alternative negative binomial\", \n                                constants = list(n = length(data_ex1)),\n                                data = list(y = data_ex1),\n                                inits = list(mu = 0.5, theta = 1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n\nposterior_samples_alternatif &lt;- nimbleMCMC(model_alternatif, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000,\n                                           monitors = c(\"prob\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|"
  },
  {
    "objectID": "01_nimble.html#defining-new-distribution",
    "href": "01_nimble.html#defining-new-distribution",
    "title": "Introduction to nimble",
    "section": "Defining new distribution",
    "text": "Defining new distribution\nAn alternative is to define a new distribution.\n\ndmynegbin &lt;- nimbleFunction(\n  run = function(x = double(0), \n                 mu = double(0),\n                 theta = double(0),\n                 log = integer(0, default = 0)) {\n    returnType(double(0))\n    prob = get_p_from_mu(mu, theta)\n    output &lt;- dnbinom(x, size = theta, prob = prob, log = log)\n    return(output)\n  })\nregisterDistributions(list(\n  dmynegbin = list(BUGSdist = \"dmynegbin(mu, theta)\",\n                   discrete = TRUE, pqAvail = FALSE)\n))\n\n  [Warning] Random generation function for dmynegbin is not available. NIMBLE is generating a placeholder function, rmynegbin, that will invoke an error if an algorithm needs to simulate from this distribution. Some algorithms (such as random-walk Metropolis MCMC sampling) will work without the ability to simulate from the distribution.  If simulation is needed, provide a nimbleFunction (with no setup code) to do it.\n\n\n\ncode_with_my_dist &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dmynegbin(mu, theta) # my distribution\n  }\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  mu &lt;- exp(log_mu)\n  theta ~ dexp(0.1)\n})\n\nmodel_with_my_dist &lt;- nimbleModel(code = code_with_my_dist, \n                                  name = \"Alternative negative binomial\", \n                                  constants = list(n = length(data_ex1)),\n                                  data = list(y = data_ex1),\n                                  inits = list(log_mu = 0.5, theta = 1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\ncompileNimble(model_with_my_dist)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nDerived CmodelBaseClass created by buildModelInterface for model Alternative negative binomial\n\nposterior_samples_alternatif &lt;- nimbleMCMC(model_with_my_dist, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000, \n                                           monitors = c(\"mu\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\n\nposterior_samples_alternatif %&gt;% \n  ggs() %&gt;% \n  ggplot() +\n  aes(x = Iteration,\n      y = value, color = factor(Chain)) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Iteration\", y = \"Parameter value\", color = \"\")"
  },
  {
    "objectID": "01_nimble.html#alternative-mcmc-sampler",
    "href": "01_nimble.html#alternative-mcmc-sampler",
    "title": "Introduction to nimble",
    "section": "Alternative MCMC sampler",
    "text": "Alternative MCMC sampler\nOne big strength of nimble are the several samplers that are available in the package."
  },
  {
    "objectID": "01_nimble.html#conjuguate-priors",
    "href": "01_nimble.html#conjuguate-priors",
    "title": "Introduction to nimble",
    "section": "Conjuguate priors",
    "text": "Conjuguate priors\nFirst, nimble is able to identify conjugate priors and make the exact computation of the posterior link."
  },
  {
    "objectID": "01_nimble.html#hmc-algorithm",
    "href": "01_nimble.html#hmc-algorithm",
    "title": "Introduction to nimble",
    "section": "HMC algorithm",
    "text": "HMC algorithm\nnimble provides support for Hamiltonian Monte Carlo (HMC) and compute the derivatives of the likelihood through automatic differentiation. The nimbleHMC package implement two versions of No-U-Turn (NUTS) HMC sampling: the standard one developed in Hoffman and Gelman (link) and an updated one with improved adaptation routines and convergence criteria, which matches the HMC sampler of STAN.\nIn order to allow an algorithm to use AD for a specific model, that model must be created with buildDerivs = TRUE.\n\n# Build model with nimble\nmodel_neg_bin_HMC &lt;- nimbleModel(code = code_neg_bin, \n                                 name = \"Negative binomial\", \n                                 constants = list(n = length(data_ex1)),\n                                 data = list(y = data_ex1),\n                                 inits = list(prob = 0.5, theta = 1),\n                                 calculate = FALSE, buildDerivs = TRUE) # This is the line required for running HMC\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nChecking model sizes and dimensions\n\nC_model_neg_bin_HMC &lt;- compileNimble(model_neg_bin_HMC) # Compile the model (they require this for the compilation of the HMC object)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n# Build the MCMC algorithm which applies HMC sampling\nHMC &lt;- buildHMC(C_model_neg_bin_HMC)\n\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nNUTS sampler (1)\n  - prob, theta \n\n# Careful here, when the model has random effects\n# HMC requires to set values in the model before running the algorithm\n# One solution is to simulate with the model and set the model with these values\n# See : https://r-nimble.org/html_manual/cha-mcmc.html#subsec:HMC-example\n# Here, as the model is simple, there is no need for this and everything is handled withing nimble/nimbleHMC\n\n## Then everything is standard in nimble\nCHMC &lt;- compileNimble(HMC) # Compile the HMC model/algo\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\nsamples &lt;- runMCMC(CHMC, niter = 1000, nburnin = 500) # Short run for illustration\n\nrunning chain 1...\n\n\n  [Note] NUTS sampler (nodes: prob, theta) is using 500 warmup iterations.\n         Since `warmupMode` is 'default' and `nburnin` &gt; 0,\n         the number of warmup iterations is equal to `nburnin`.\n         The burnin samples will be discarded, and all samples returned will be post-warmup.\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nsummary(coda::as.mcmc(samples)) # Summary of the estimates\n\n\nIterations = 1:500\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 500 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n         Mean      SD Naive SE Time-series SE\nprob   0.3714 0.04763  0.00213       0.005035\ntheta 10.9433 2.20934  0.09880       0.232706\n\n2. Quantiles for each variable:\n\n       2.5%    25%     50%     75%   97.5%\nprob  0.284 0.3349  0.3756  0.4048  0.4671\ntheta 7.074 9.2270 10.7757 12.3756 15.7634\n\n\nAnd there are plenty of others samplers:\n\nParticle filters / sequential Monte Carlo and iterated filtering (package nimbleSMC)\nMonte Carlo Expectation Maximization (MCEM)\n\nSee link"
  },
  {
    "objectID": "01_nimble.html#the-laplace-approximation",
    "href": "01_nimble.html#the-laplace-approximation",
    "title": "Introduction to nimble",
    "section": "The laplace approximation",
    "text": "The laplace approximation\nnimble also implements the Laplace approximation. But be careful, it performs maximum likelihood estimation. This is not the same as INLA (fully bayesian approach), but more like TMB (or glmmTMB- maximum likelihood estimation through Laplace approximation and automatic differentiation).\n\n# We need the derivatives to build the Laplace algorithm\n# so we take the object model_neg_bin_HMC built previously\nmodel_laplace &lt;- buildLaplace(model_neg_bin_HMC)\nCmodel_laplace &lt;- compileNimble(model_laplace)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n# Get the Laplace approximation for one set of parameter values.\nCmodel_laplace$calcLaplace(c(0.5,0.5)) \n\n[1] -1499.737\n\n # Get the corresponding gradient.\nCmodel_laplace$gr_Laplace(c(0.5,0.5))\n\n[1] -3552.0000   409.7602\n\n# Search the (approximate) MLE\nMLE &lt;- Cmodel_laplace$findMLE(c(0.5,0.5)) # Find the (approximate) MLE.\nMLE$par\n\n[1]  0.366619 10.569421\n\n# Get log-likelihood value\nMLE$value\n\n[1] -333.2813\n\n# And output summaries\nCmodel_laplace$summary(MLE)\n\nnimbleList object of type AGHQuad_summary\nField \"params\":\nnimbleList object of type AGHQuad_params\nField \"names\":\n[1] \"prob\"  \"theta\"\nField \"estimates\":\n[1]  0.366619 10.569421\nField \"stdErrors\":\n[1] 0.05242939 2.35119020\nField \"randomEffects\":\nnimbleList object of type AGHQuad_params\nField \"names\":\ncharacter(0)\nField \"estimates\":\nnumeric(0)\nField \"stdErrors\":\nnumeric(0)\nField \"vcov\":\n&lt;0 x 0 matrix&gt;\nField \"scale\":\n[1] \"original\"\n\n\nN.b this example is only for illustration of the code. The Laplace approximation is relevant only when there are random effects in the model (which is not the case here).\nFor a full example see link"
  },
  {
    "objectID": "01_nimble.html#comparing-mcmc-algorithms",
    "href": "01_nimble.html#comparing-mcmc-algorithms",
    "title": "Introduction to nimble",
    "section": "Comparing MCMC algorithms",
    "text": "Comparing MCMC algorithms\nOne can compare several algorithms through the package compareMCMCs. It is possible to compare several algorithms internal to nimble with those from jags (or even STAN) algorithms. An example below for nimble and STAN.\n\n# This model code will be used for both nimble and JAGS\nmodelInfo &lt;- list(\n  code = code_neg_bin,\n  constants = list(n = length(data_ex1)),\n  data = list(y = data_ex1),\n  inits = list(prob = 0.5, theta = 1)\n)\n\n# Here is a custom MCMC configuration function for nimble\nconfigure_nimble_slice &lt;- function(model) {\n  configureMCMC(model, onlySlice = TRUE)\n}\n\n# Here is the call to compareMCMCs\nres &lt;- compareMCMCs(modelInfo,\n                    MCMCs = c('nimble',       # nimble with default samplers\n                              'nimble_slice' # nimble with slice samplers\n                              ),\n                    nimbleMCMCdefs = \n                      list(nimble_slice = 'configure_nimble_slice'),\n                    MCMCcontrol = list(inits = list(prob = 0.5, theta = 1),\n                                       niter = 10000,\n                                       burnin = 1000))\n\nbuilding nimble model...\n\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nRW sampler (2)\n  - prob\n  - theta\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nslice sampler (2)\n  - prob\n  - theta\n\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nmake_MCMC_comparison_pages(res, modelName = 'code_neg_bin',dir = \"/tmp/\",\n                           control = list(res = 75))\n\nLoading required namespace: xtable"
  },
  {
    "objectID": "01_nimble.html#data-generation",
    "href": "01_nimble.html#data-generation",
    "title": "Introduction to nimble",
    "section": "Data generation",
    "text": "Data generation\nWe consider a simple settings in dimension \\(p=5\\), with Toeplitz-like covariance.\n\nN &lt;- 100\np &lt;- 5\nd &lt;- 1:p\nDsqrt &lt;- diag(sqrt(d))\nSigma &lt;- Dsqrt %*% toeplitz(0.75^(0:(p-1))) %*% Dsqrt\nOmega &lt;- solve(Sigma)\nmu &lt;- 5 + 1:p\npi &lt;- c(0.25, 0, 0.8, 0.1, .5)\n\nHere are some data (100 points):\n\nW &lt;- t(replicate(N, rbinom(p, prob = pi, size = 1)))\nY &lt;- (1 - W) * rmvnorm(N, mu, Sigma)\nggplot(data.frame(y = c(Y))) + aes(x=y) + geom_histogram()"
  },
  {
    "objectID": "01_nimble.html#auxiliary-functions",
    "href": "01_nimble.html#auxiliary-functions",
    "title": "Introduction to nimble",
    "section": "Auxiliary functions",
    "text": "Auxiliary functions\nWe need some auxiliary nimble functions to handle the density and generation of the random binomial vector \\(W\\):\n\ndbinom_vector &lt;- nimbleFunction(\n  run = function( x = double(1),\n                  size = double(1),\n                  prob = double(1), \n                  log = integer(0, default = 0)\n  ) {\n    returnType(double(0))\n    logProb &lt;- sum(dbinom(x, prob = prob, size = size, log = TRUE))\n    if(log) return(logProb) else return(exp(logProb))\n  })\n\nrbinom_vector &lt;- nimbleFunction(\n  run = function( n = integer(0, default = 1),\n                  size = double(1),\n                  prob = double(1)\n  ) {\n    returnType(double(1))\n    return(rbinom(length(size), prob = prob, size = size))\n  })"
  },
  {
    "objectID": "01_nimble.html#nimble-code-and-model-for-zi-normal-v1",
    "href": "01_nimble.html#nimble-code-and-model-for-zi-normal-v1",
    "title": "Introduction to nimble",
    "section": "Nimble code and model for ZI-normal: V1",
    "text": "Nimble code and model for ZI-normal: V1\nRather than defining a probability density function for this model (which is in fact a bit complicated…), we adopt a generative approach:\n\nZInormal_code &lt;- nimbleCode({\n  \n  for (j in 1:p) {\n    mean[j] ~ dnorm(0,1)  \n  }\n  for (j in 1:p) {\n    zeroProb[j] ~ dunif(0,1)\n  }\n  \n  prec[1:p,1:p] ~ dwish(Ip[1:p,1:p], p)\n\n  for (i in 1:N) {\n    w[i, 1:p] ~ dbinom_vector(onep[1:p], zeroProb[1:p])\n    z[i, 1:p] ~ dmnorm(mean[1:p], prec[1:p,1:p])\n    ytilde[i, 1:p] &lt;- (1 - w[i,1:p]) * z[i,1:p]\n    ## P. Barbillon/M.-P. Étienne: astuce en zero \n    ## a.k.a \"I got a trick at zero\"\n    y[i, 1:p] ~ dmnorm(ytilde[i, 1:p], prec_inf[1:p,1:p])\n  }\n  \n})\n\nWe can now define the nimble model for the ZI-normal model. We give some sound intial values for the parameters and latent variable, define some constants and provide the data:\n\nZInormal_model &lt;- nimbleModel(\n  ZInormal_code, \n  constants = \n    list(N = N, p = p, Ip = diag(1,p,p),\n         onep = rep(1,p), prec_inf = diag(1e5,p,p)),\n  data = list(y = Y, w = W),\n  inits = list(mean = rep(5,p), prec = diag(1,p,p), zeroProb=rep(0.5,p), z = Y))\n\nDefining model\n\n\n  [Note] Registering 'dbinom_vector' as a distribution based on its use in BUGS code. If you make changes to the nimbleFunctions for the distribution, you must call 'deregisterDistributions' before using the distribution in BUGS code for those changes to take effect.\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions"
  },
  {
    "objectID": "01_nimble.html#mcmc-estimation",
    "href": "01_nimble.html#mcmc-estimation",
    "title": "Introduction to nimble",
    "section": "MCMC estimation",
    "text": "MCMC estimation\nLet us run a simple 2-chain MCMC estimation\n\nmy_MCMC &lt;- nimbleMCMC(\n  ZInormal_model, \n  monitors = c(\"mean\", \"prec\", \"zeroProb\"),\n  nchains = 2, \n  niter = 1000, \n  samplesAsCodaMCMC = TRUE,\n  nburnin=100)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\n\n\n\n\n\nEstimation of the mean \\(\\mu\\)\n\n\n\n\n\nprint(mu)\n\n[1]  6  7  8  9 10\n\n\n\n\n\n\n\nEstimation of the zero inflation probabilities \\(\\pi\\)\n\n\n\n\n\nprint(pi)\n\n[1] 0.25 0.00 0.80 0.10 0.50\n\n\n\n\n\n\n\nEstimation of the precision matrix \\(\\Omega\\)\n\n\n\n\n\nprint(round(Omega,3))\n\n       [,1]   [,2]   [,3]   [,4]   [,5]\n[1,]  2.286 -1.212  0.000  0.000  0.000\n[2,] -1.212  1.786 -0.700  0.000  0.000\n[3,]  0.000 -0.700  1.190 -0.495  0.000\n[4,]  0.000  0.000 -0.495  0.893 -0.383\n[5,]  0.000  0.000  0.000 -0.383  0.457"
  },
  {
    "objectID": "rig.html",
    "href": "rig.html",
    "title": "rig: an easy way to switch from an R version to another",
    "section": "",
    "text": "rig is an R Installation manager that allows you to easily switch between different R versions.\nTo install it, follow the instructions on the GitHub page.\nOn ubuntu, rig will “work” with R versions installed/stored at /opt/R/. It will not detect the R versions installed via apt. If you never tried to solve this question of switching between R versions, you will need to reinstall the R versions you’re interested in using rig.\nTo do this, use the add command. For example, to install R version 4.2.2:\n$ rig add 4.2.2\nAfter installing additional versions, you can check all the versions available on your computer using the list command:\n$ rig list\n* name   version  aliases\n------------------------------------------\n  4.2.2           \n  4.3.3           \n* 4.4.1           release\nThe ’*’ indicates the default version.\nThen to access the desired R version in RStudio, use the rstudio command:\n$ rig rstudio 4.2.2\nHere is a command list you can use:\nrig add        -- install a new R version [alias: install]\nrig available  -- List R versions available to install.\nrig default    -- print or set default R version [alias: switch]\nrig library    -- manage package libraries [alias: lib] (experimental)\nrig list       -- list installed R versions [alias: ls]\nrig resolve    -- resolve a symbolic R version\nrig rm         -- remove R versions [aliases: del, delete, remove]\nrig rstudio    -- start RStudio with the specified R version\nrig run        -- Run R, an R script or an R project\nrig sysreqs    -- manage R-related system libraries and tools (experimental) (macOS)\nrig system     -- manage current installations\nFor more information, check the GitHub page."
  },
  {
    "objectID": "simulator.html",
    "href": "simulator.html",
    "title": "Setting up simulations in R",
    "section": "",
    "text": "We explore several R packages for generate or structure simulations. Most statistical simulations studies includes different steps : generate data/ run one or several methods using simulated data / compare results.\nWe identified the following list of packages for data simulation:\n\n{simulator}: A framework for performing simulations such as those common in methodological statistics papers. The design principles of this package are described in greater depth in Bien, J. (2016) “The simulator: An Engine to Streamline Simulations,” which is available at doi:10.48550/arXiv.1607.00021.\n{simpr}: A general, ‘tidyverse’-friendly framework for simulation studies, design analysis, and power analysis. Specify data generation, define varying parameters, generate data, fit models, and tidy model results in a single pipeline, without needing loops or custom functions.\n{DeclareDesign}: Researchers can characterize and learn about the properties of research designs before implementation using ‘DeclareDesign’. Ex ante declaration and diagnosis of designs can help researchers clarify the strengths and limitations of their designs and to improve their properties, and can help readers evaluate a research strategy prior to implementation and without access to results. It can also make it easier for designs to be shared, replicated, and critiqued.\n{MonteCarlo}: Simplifies Monte Carlo simulation studies by automatically setting up loops to run over parameter grids and parallelising the Monte Carlo repetitions. It also generates LaTeX tables.\n{simChef}: The goal is to help you quickly cook up a fully-realized, high-quality, reproducible, and transparently-documented simulation study in a flexible, efficient, and low-code manner. It removes many of the administrative burdens of simulation design through:\n\nAn intuitive tidy grammar of data science simulations\nPowerful abstractions for distributed simulation processing backed by future\nAutomated generation of interactive R Markdown simulation documentation, situating results next to the workflows needed to reproduce them.\n\n{simEngine}: An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments. See full documentation at https://avi-kenny.github.io/SimEngine/."
  },
  {
    "objectID": "simulator.html#overview",
    "href": "simulator.html#overview",
    "title": "Setting up simulations in R",
    "section": "",
    "text": "We explore several R packages for generate or structure simulations. Most statistical simulations studies includes different steps : generate data/ run one or several methods using simulated data / compare results.\nWe identified the following list of packages for data simulation:\n\n{simulator}: A framework for performing simulations such as those common in methodological statistics papers. The design principles of this package are described in greater depth in Bien, J. (2016) “The simulator: An Engine to Streamline Simulations,” which is available at doi:10.48550/arXiv.1607.00021.\n{simpr}: A general, ‘tidyverse’-friendly framework for simulation studies, design analysis, and power analysis. Specify data generation, define varying parameters, generate data, fit models, and tidy model results in a single pipeline, without needing loops or custom functions.\n{DeclareDesign}: Researchers can characterize and learn about the properties of research designs before implementation using ‘DeclareDesign’. Ex ante declaration and diagnosis of designs can help researchers clarify the strengths and limitations of their designs and to improve their properties, and can help readers evaluate a research strategy prior to implementation and without access to results. It can also make it easier for designs to be shared, replicated, and critiqued.\n{MonteCarlo}: Simplifies Monte Carlo simulation studies by automatically setting up loops to run over parameter grids and parallelising the Monte Carlo repetitions. It also generates LaTeX tables.\n{simChef}: The goal is to help you quickly cook up a fully-realized, high-quality, reproducible, and transparently-documented simulation study in a flexible, efficient, and low-code manner. It removes many of the administrative burdens of simulation design through:\n\nAn intuitive tidy grammar of data science simulations\nPowerful abstractions for distributed simulation processing backed by future\nAutomated generation of interactive R Markdown simulation documentation, situating results next to the workflows needed to reproduce them.\n\n{simEngine}: An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments. See full documentation at https://avi-kenny.github.io/SimEngine/."
  },
  {
    "objectID": "simulator.html#how-to-choose",
    "href": "simulator.html#how-to-choose",
    "title": "Setting up simulations in R",
    "section": "How to choose?",
    "text": "How to choose?\nHere is a comparison of the different packages summarised in a table:\n\n\n\nName\nVersion\n#deps\n#rev deps\nLatest commit\nLatest release\nDoc\nOn CRAN?\nDevelopers\n\n\n\n\n{DeclareDesign}\n1.0.10\n2\n1\n2024-04-13\n2024-04-21\n\nYes\nGraeme Blair\n\n\n{MonteCarlo}\n1.0.6\n6\n0\n2019-01-31\n2019-01-31\n\nYes\nChristian Hendrik Leschinski\n\n\n{simChef}\n0.1.0\n22\n0\n2024-03-20\nNA\n\nNo\nTiffany Tang, James Duncan\n\n\n{simEngine}\n1.4.0\n6\n0\n2024-04-13\n2024-04-04\n\nYes\nAvi Kenny, Charles Wolock\n\n\n{simpr}\n0.2.6\n11\n0\n2024-07-16\n2023-04-26\n\nYes\nEthan Brown\n\n\n{simulator}\n0.2.5\n1\n0\n2023-02-02\n2023-02-04\n\nYes\nJacob Bien\n\n\n\nThis table shows that all packages are on CRAN, except for {simChef}. The latest release of {simChef} is not available, but the latest commit was in March 2024 so it is actively maintained. The number of dependencies is quite high for {simChef} and {simpr}. The number of reverse dependencies is low for all packages. The package {MonteCarlo} seams not to be maintained anymore.\nAlso, in terms of philosophy, the {DeclareDesign} package is dedicated to experimental design. It also makes it possible to simulate an experimental design of interest, in order to understand the properties of this design. As its goal is not to evaluate computational methods via simulations, it does not address the question of interest and we did not evaluate it further. The underlying experimental design principles are described in the companion book: https://book.declaredesign.org/.\nIn the following, we will therefore focus on the packages {simEngine}, {simChef}, {simpr}, and {simulator}. The next section describes the common simulation problem we will use to compare the packages. Then, we will show how to solve this problem with each package. Finally, we will compare the packages based on the code, the output, and the ease of use."
  },
  {
    "objectID": "simulator.html#a-common-simulation-problem-power-curve-for-test-calibration",
    "href": "simulator.html#a-common-simulation-problem-power-curve-for-test-calibration",
    "title": "Setting up simulations in R",
    "section": "A common simulation problem: power curve for test calibration",
    "text": "A common simulation problem: power curve for test calibration\nWe consider a common simulation problem: power curve estimation for hypothesis test calibration.\nWe consider a two-sample paired t-test simple example. The first sample is generated from a normal distribution with mean 0 and standard deviation sd. The second sample is generated from a normal distribution with mean mean_diff and standard deviation sd. The sample size is n. We want to estimate the power of the paired t-test for different values of mean_diff and ds. Specifically, we will use the following parameters:\n\nn: 100, 150, 200;\nmean_diff: 10, 20, 30;\nsd: 50, 100.\n\nWe will estimate the power by simulating the paired t-test for each combination of parameters. We will repeat the simulation 10 times for each combination of parameters.\nThe base R solution for this problem can look like this:\n\n## Set up parameters\nns &lt;- c(100L, 150L, 200L)\nmean_diffs &lt;- c(10, 20, 30)\nsds &lt;- c(50, 100)\nreps &lt;- 10L\n\n## Bring together into data frame\nresults_template &lt;- expand.grid(\n  n = ns, \n  mean_diff = mean_diffs, \n  sd = sds, \n  p.value = NA_real_\n)\nbase_r_sim &lt;- results_template[rep(1:nrow(results_template), each = reps), ]\n\n## Loop over rows of the data frame and calculate the p-value\nfor (i in 1:nrow(results_template)) {\n  params &lt;- base_r_sim[i,]\n  pre &lt;- rnorm(params$n, 0, params$sd)\n  post &lt;- pre + rnorm(params$n, params$mean_diff, params$sd)\n  base_r_sim$p.value[i] &lt;- t.test(pre, post)$p.value\n}\n\n## Display table output\nDT::datatable(base_r_sim)"
  },
  {
    "objectID": "simulator.html#simpr",
    "href": "simulator.html#simpr",
    "title": "Setting up simulations in R",
    "section": "{simpr}",
    "text": "{simpr}\nWhat is bad in the base R solution according to {simpr} authors:\n\nMost important pieces (data generating process, model specification, definitions, varying parameters) are hidden;\nWhat if there is an error?\nWhat about parallelization?\nIs this code sufficiently readable? Without the comments?\n\n\n{simpr} solution\n\nsimpr_tbl &lt;- specify(\n  pre  = ~ rnorm(n, 0, sd),\n  post = ~ pre + rnorm(n, mean_diff, sd)\n) |&gt; \n  define(n = ns, mean_diff = mean_diffs, sd = sds) |&gt; \n  generate(reps, .progress = TRUE) |&gt; \n  fit(t = ~ t.test(post, pre, paired = TRUE)) |&gt; \n  tidy_fits()\n\n\nAttaching package: 'purrr'\n\n\nThe following object is masked from 'package:magrittr':\n\n    set_names\n\nDT::datatable(simpr_tbl)\n\n\n\n\nsimpr_tbl |&gt; \n  dplyr::group_by(n, mean_diff, sd) |&gt; \n  dplyr::summarize(Power = mean(p.value &lt; 0.05)) |&gt; \n  dplyr::ungroup() |&gt; \n  ggplot(aes(n, Power)) + \n  geom_col() + \n  facet_grid(rows = dplyr::vars(sd), cols = dplyr::vars(mean_diff)) + \n  theme_bw()\n\n`summarise()` has grouped output by 'n', 'mean_diff'. You can override using\nthe `.groups` argument.\n\n\n\n\n\n\n\n\n\n\n\nPhilosophy\nThe {simpr} workflow, inspired by the {infer} package, distills a simulation study into five primary steps:\n\nspecify() your data-generating process;\ndefine() parameters that you want to systematically vary across your simulation design (e.g. n, effect size);\ngenerate() the simulation data;\nfit() models to your data (e.g. lm());\ntidy_fits() for consolidating results using broom::tidy(), such as computing power or Type I Error rates.\n\n\n\nReproducible workflows\n\nSame seed, same results;\nCan regenerate just a specific subset to see what happened in that particular dataset or fit;\nUseful in debugging and diagnosing unexpected results, etc.\n\n\nFiltering full simulation\n\nwithr::with_seed(500, {\n  specify(a = ~ runif(6)) |&gt; \n    generate(3) |&gt; \n    dplyr::filter(.sim_id == 3)\n})\n\nfull tibble\n--------------------------\n# A tibble: 1 × 3\n  .sim_id   rep sim             \n    &lt;int&gt; &lt;int&gt; &lt;list&gt;          \n1       3     3 &lt;tibble [6 × 1]&gt;\n\nsim[[1]]\n--------------------------\n# A tibble: 6 × 1\n      a\n  &lt;dbl&gt;\n1 0.371\n2 0.959\n3 0.633\n4 0.177\n5 0.803\n6 0.133\n\n\n\n\nSimulate subset only\n\nwithr::with_seed(500, {\n  specify(a = ~ runif(6)) |&gt; \n    generate(3, .sim_id == 3)\n})\n\nfull tibble\n--------------------------\n# A tibble: 1 × 3\n  .sim_id   rep sim             \n    &lt;int&gt; &lt;int&gt; &lt;list&gt;          \n1       3     3 &lt;tibble [6 × 1]&gt;\n\nsim[[1]]\n--------------------------\n# A tibble: 6 × 1\n      a\n  &lt;dbl&gt;\n1 0.371\n2 0.959\n3 0.633\n4 0.177\n5 0.803\n6 0.133\n\n\n\n\nBenchmarking\n\nbench::mark(\n  all = specify(a = ~ runif(6)) |&gt; \n    generate(1000) |&gt; \n    dplyr::filter(.sim_id == 1000),\n  subset = specify(a = ~ runif(6)) |&gt; \n    generate(1000, .sim_id == 1000),\n  check = FALSE, min_iterations = 10L, relative = TRUE\n)\n\nWarning: Some expressions had a GC in every iteration; so filtering is\ndisabled.\n\n\n# A tibble: 2 × 6\n  expression   min median `itr/sec` mem_alloc `gc/sec`\n  &lt;bch:expr&gt; &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1 all         68.0   61.6       1        1        1   \n2 subset       1      1        62.1      1.29     1.32\n\n\n\n\n\nOther features\n\n\n\n\n\n\nData munging\n\n\n\nAdd per_sim() |&gt; after generate() in your simulation pipeline and then any tidyverse function that will apply to every simulation dataset:\n\nspecify(\n  pre  = ~ rnorm(n, 0, sd), \n  post = ~ pre + rnorm(n, mean_diff, sd)\n) |&gt; \n  define(n = ns, mean_diff = mean_diffs, sd = sds) |&gt; \n  generate(reps, .progress = TRUE) |&gt; \n  ## Apply tidyverse functions to every simulation dataset\n  per_sim() |&gt; \n  ## Mutate to add a range restriction\n  dplyr::mutate(dplyr::across(dplyr::everything(), dplyr::case_when(\n    pre &gt;  100 ~ 100,\n    pre &lt; -100 ~ -100,\n    .default   ~ pre\n  ))) |&gt; \n  fit(t = ~ t.test(post, pre, paired = TRUE)) |&gt; \n  tidy_fits()\n\n\n\n\n\n\n\n\n\nError handling\n\n\n\n\nCan change error handling to keep going with simulation, stop simulation, or to skip warnings;\nDebug and recovery options to enter into simulation during error.\n\n\n\n\n\n\n\n\n\nBuilt-in parallelization\n\n\n\nJust add\n\nlibrary(future)\nplan(multisession, workers = 6) # or however many cores are reasonable to use\n\nand your simulation pipeline (actually the generate() function) will run in parallel.\n\n\n\n\nPros & cons\n\n\n\n\n\n\n\n\nPros\n\n\n\n\ntidyverse friendly;\nbeginner friendly;\nReproducibility, error handling built in;\nGeneral-purpose, customizable and can handle arbitrary R code.\n\n\n\n\n\n\n\n\n\n\nCons\n\n\n\n\nLikely not as fast/optimized as some alternatives;\nNot as customizable/powerful as DeclareDesign;\nNot specifically set up for any particular application (no MC errors, plots, reports, specific models…)."
  },
  {
    "objectID": "simulator.html#simulator",
    "href": "simulator.html#simulator",
    "title": "Setting up simulations in R",
    "section": "{simulator}",
    "text": "{simulator}\nThis is a package on the CRAN. It is described in a 2016 paper by Jacob Bien. Last update on GitHub : last year (so, 2023).\n\nGetting started\nThe function create(), with a directory that does not exist, will create the directory with 5 files and 1 folder:\n\neval_functions.R: contains metrics to be evaluated;\nfiles/: directory to store results;\nmain.R: main code to run;\nmethod_functions.R: methods to run;\nmodel_functions.R: define the models;\nwriteup.Rmd.\n\n\nsimulator_dir &lt;- \"./sims_simulator\"\nif (!file.exists(simulator_dir))\n  create(simulator_dir)\n\nNew simulation template created!  Go to ./sims_simulator/main.R to get started.\n\n\n\nwithr::with_dir(simulator_dir, {\n  list.files()\n})\n\n[1] \"eval_functions.R\"   \"main.R\"             \"method_functions.R\"\n[4] \"model_functions.R\"  \"writeup.Rmd\"       \n\n\n\nOn a typical project, one starts by defining a model in model_functions.R, one or two methods in method_functions.R, and a few metrics in eval_functions.R, and then one runs the code in main.R. After looking at some of the results, one might add an additional model or method or metric. One then returns to main.R, adds some additional lines specifying that the additional components should be run as well and looks at some more results.\nThe simplest way to look at results is by using the plot functions plot_eval(), plot_evals() and plot_evals_by(). In situations where you wish to investigate results more deeply than just looking at aggregated plots, one can use the functions model(), draws(), output(), and evals() to get at all objects generated through the course of the simulation.\n\nThe create() function also creates the template in the different files:\n\nContent of model_functions.R\n\nmake_my_model &lt;- function(n, prob) {\n  new_model(\n    name = \"contaminated-normal\", \n    label = sprintf(\"Contaminated normal (n = %s, prob = %s)\", n, prob), \n    params = list(n = n, mu = 2, prob = prob), \n    simulate = function(n, mu, prob, nsim) {\n      # this function must return a list of length nsim\n      contam &lt;- runif(n * nsim) &lt; prob\n      x &lt;- matrix(rep(NA, n * nsim), n, nsim)\n      x[contam] &lt;- rexp(sum(contam))\n      x[!contam] &lt;- rnorm(sum(!contam))\n      x &lt;- mu + x # true mean is mu\n      return(split(x, col(x))) # make each col its own list element\n    }\n  )\n}\n\nDefine a model from its different components with new_model():\n\nname;\nlabel: what will be printed in the tables later probably?\nparam: a list of different parameters for the model;\nsimulate: a function of the parameters that returns nsim simulations.\n\n\n\nContent of method_functions.R\n\nmy_method &lt;- new_method(\n  name = \"my-method\", \n  label = \"My Method\", \n  method = function(model, draw) {\n    list(fit = median(draw))\n  }\n)\n\ntheir_method &lt;- new_method(\n  name = \"their-method\", \n  label = \"Their Method\",\n  method = function(model, draw) {\n    list(fit = mean(draw))\n  }\n)\n\nDefine methods to be used on the model. The function new_method() has for arguments a name (for R) name, a pretty name label, and the method named arg for the computation we want.\n\n\nContent of eval_functions.R\n\nhis_loss &lt;- new_metric(\n  name = \"hisloss\", \n  label = \"His loss function\",\n  metric = function(model, out) {\n    return((model$mu - out$fit)^2)\n  }\n)\n\nher_loss &lt;- new_metric(\n  name = \"herloss\", \n  label = \"Her loss function\",\n  metric = function(model, out) {\n    return(abs(model$mu - out$fit))\n  }\n)\n\nMetric objects: shows how to compare model object and output of the method (method used on sim) object.\n\n\nContent of main.R\n\nsetwd(simulator_dir)\n\nsource(\"model_functions.R\")\nsource(\"method_functions.R\")\nsource(\"eval_functions.R\")\n\n## @knitr init\n\nname_of_simulation &lt;- \"normal-mean-estimation-with-contamination\"\n\n## @knitr main\n\nsim &lt;- new_simulation(\n  name = name_of_simulation,\n  label = \"Mean estimation under contaminated normal\"\n) %&gt;%\n  generate_model(\n    make_model = make_my_model, \n    seed = 123,\n    n = 50,\n    prob = as.list(seq(0, 1, length = 6)),\n    vary_along = \"prob\"\n  ) %&gt;%\n  simulate_from_model(nsim = 10) %&gt;%\n  run_method(list(my_method, their_method)) %&gt;%\n  evaluate(list(his_loss, her_loss))\n\n## @knitr plots\n\nplot_eval_by(sim = sim, metric_name = \"hisloss\", varying = \"prob\")\n\n## @knitr tables\n\ntabulate_eval(\n  object = sim, \n  metric_name = \"herloss\", \n  output_type = \"markdown\",\n  format_args = list(digits = 1)\n)\n\nThe main.R script calls the different files.\nCan plot_eval_by() be used for different metrics at once? Can tabulate_eval() be used for different metrics at once?\n\n\n\nExample: power curve\nHere is the content of the main.R file in the folder simulator_equality_test/.\n\nlibrary(simulator) # this file was created under simulator version 0.2.5\n\nsource(\"simulator_equality_test/model_functions.R\")\nsource(\"simulator_equality_test/method_functions.R\")\nsource(\"simulator_equality_test/eval_functions.R\")\n\n## @knitr init\n\nname_of_simulation &lt;- \"normal-mean-test\"\n\n## @knitr main\n\nf &lt;- file()\nsink(file = f)\n\nsim &lt;- new_simulation(\n  name = name_of_simulation, \n  label = \"Test of mean\"\n) |&gt; \n  generate_model(\n    make_model = make_my_model_normal, \n    seed = 13, \n    n = 20, \n    mu2 = as.list(seq(0, 10, by = 0.5)), \n    mu1 = 0, \n    sig = 5, \n    vary_along = \"mu2\"\n  ) |&gt; \n  simulate_from_model(nsim = 1000) |&gt; \n  run_method(list(t_test)) |&gt; \n  evaluate(list(pval_loss))\n\n..Created model and saved in normal/mu1_0/mu2_0/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_0.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_1/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_1.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_2/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_2.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_3/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_3.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_4/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_4.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_5.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_6/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_6.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_7/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_7.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_8/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_8.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_9/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_9.5/n_20/sig_5/model.Rdata\n..Created model and saved in normal/mu1_0/mu2_10/n_20/sig_5/model.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_0/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_0.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_1/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0 sec and saved in normal/mu1_0/mu2_1.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_2/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_2.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_3/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_3.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_4/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_4.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_5.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_6/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_6.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_7/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_7.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_8/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_8.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0 sec and saved in normal/mu1_0/mu2_9/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_9.5/n_20/sig_5/r1.Rdata\n..Simulated 1000 draws in 0.01 sec and saved in normal/mu1_0/mu2_10/n_20/sig_5/r1.Rdata\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Performed Mean equality test in 0 seconds (on average over 1000 sims)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n..Evaluated Mean equality test in terms of pval&lt;0.05, Computing time (sec)\n\nsink()\nclose(f)\nunlink(f)\n\n## @knitr tables\n\ntabulate_eval(\n  sim, \n  metric_name = \"p_value\", \n  output_type = \"markdown\",\n  format_args = list(digits = 5)\n)\n\n&lt;!-- generated by simulator on Tue Sep 10 16:20:27 2024. --&gt;\n\n\n\nA comparison of Mean pval&lt;0.05 (averaged over 1000 replicates).\n\n\n\nMean equality test\n\n\n\n\nnormal\n0.055 (0.0072130)\n\n\nnormal\n0.067 (0.0079103)\n\n\nnormal\n0.100 (0.0094916)\n\n\nnormal\n0.143 (0.0110758)\n\n\nnormal\n0.226 (0.0132325)\n\n\nnormal\n0.327 (0.0148422)\n\n\nnormal\n0.441 (0.0157088)\n\n\nnormal\n0.559 (0.0157088)\n\n\nnormal\n0.671 (0.0148654)\n\n\nnormal\n0.783 (0.0130415)\n\n\nnormal\n0.860 (0.0109782)\n\n\nnormal\n0.907 (0.0091889)\n\n\nnormal\n0.955 (0.0065588)\n\n\nnormal\n0.982 (0.0042064)\n\n\nnormal\n0.992 (0.0028185)\n\n\nnormal\n0.995 (0.0022316)\n\n\nnormal\n0.999 (0.0010000)\n\n\nnormal\n0.999 (0.0010000)\n\n\nnormal\n0.999 (0.0010000)\n\n\nnormal\n1.000 (0.0000000)\n\n\nnormal\n1.000 (0.0000000)\n\n\n\n\n## @knitr plots\n\nplot_eval_by(\n  sim, \n  metric_name = \"p_value\", \n  varying = \"mu2\", \n  main = \"Power curve with mu1=0 and varying mu2\"\n)\n\n\n\n\n\n\n\n\nToDo :\n\nvary n\nvary both n and mu2\n\n\n\nImportant functions\n\nnew_model();\nnew_method();\nnew_metric();\nnew_simulation();\ngenerate_model();\nsimulate_from_model();\nrun_method();\nevaluate();\nplot_eval(), plot_eval_by(), tabulate_eval()."
  },
  {
    "objectID": "simulator.html#pros-cons-1",
    "href": "simulator.html#pros-cons-1",
    "title": "Setting up simulations in R",
    "section": "Pros & cons",
    "text": "Pros & cons\nThis is not really a package that codes a method, but instead it proposes an architecture to store your codes, output simulations, results, etc.\n\n\n\n\n\n\n\n\nPros\n\n\n\n\nany model possible, if you can write it;\npossible to iterate over parameter with pretty pipes;\nparallel possible, because you choose what you use;\nstores all results in the storage with increasing depth:\n\nfiles\n└── name_of_model\n    └── name_of_first_param_value\n        └── name_of2nd_param_value ... model.Rdata out stores all sims\n            └── r?.Rdata\n\n\n\n\n\n\n\n\n\nCons\n\n\n\n\nNot an usual way to code in R, and not easy to explain. Create the directory with the create() function. Then, add the different functions, methods, models, etc., in the corresponding files;\nMixes the code of the package/template with your own code;\nStores all results in this neat way BUT if too many parameters, may exceed the depth allowed."
  },
  {
    "objectID": "simulator.html#simengine",
    "href": "simulator.html#simengine",
    "title": "Setting up simulations in R",
    "section": "{simEngine}",
    "text": "{simEngine}\n{simEngine} is an open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments. The paper describing the package is available here.\n\nExample\n\nCreate a simulation object SimEngine::new_sim()\n\n\nsim &lt;- new_sim()\n\n\nCreate functions to generate data\n\n\ncreate_data &lt;- function(n) {\n  return(rpois(n = n, lambda = 20))\n}\n\nest_lambda &lt;- function(dat, type) {\n  if (type==\"M\") {\n    return(mean(dat))\n  }\n  if (type==\"V\") {\n    return(var(dat))\n  }\n}\n\n\nSimulation set-up\n\nOne run = one simulation replicate. Features varying across simulation = simulation levels. Possible values = level values. By default, {simEngine} runs one simulation replicate for each combination of level value.\n\nsim &lt;- sim |&gt; \n  set_levels(\n    estimator = c(\"M\", \"V\"),\n    n = c(10, 100, 1000)\n  )\nsim\n\nSimEngine: simulation object (class \"sim_obj\")\n----------------------------------------------\nConfiguration: \n    num_sim: 1\n    parallel: FALSE\n    n_cores: NA\n    packages: NULL\n    stop_at_error: FALSE\n    seed: 528361534\n    progress_bar: TRUE\n    batch_levels: NA\n    return_batch_id: FALSE\nLevels: \n    estimator: c(\"M\", \"V\")\n    n: c(10, 100, 1000)\nState: pre run\n\n\n\nCreate a simulation script\n\ni.e. generation, analysis and return results\n\nsim &lt;- sim |&gt; \n  set_script(function() {\n    dat &lt;- create_data(n = L$n)\n    lambda_hat &lt;- est_lambda(dat = dat, type = L$estimator)\n    return(list(\"lambda_hat\" = lambda_hat))\n  })\n\n\nConfigure and run the simulation\n\nUsing the SimEngine::set_config() it is possible to specify the number of replicates num_sim, the parallelization type n_cores, parallel, … and the required packages packages argument.\nAnd we run the simulation with the SimEngine::run() function.\n\n### Configuration\nsim &lt;- sim |&gt; \n  set_config(\n    num_sim = 100,\n    packages = c(\"ggplot2\", \"stringr\")\n  )\n\n### Run\nsim &lt;- run(sim)\n\nDone. No errors or warnings detected.\n\n\nThe package implements a SimEngine::summarize() function to calculate usual summary statistics such as bias, variance, MSE.\n\nsim |&gt; \n  summarize(\n    list(\n      stat = \"bias\",\n      name = \"bias_lambda\",\n      estimate = \"lambda_hat\",\n      truth = 20\n    ), \n    list(\n      stat = \"mse\",\n      name = \"mse_lambda\",\n      estimate = \"lambda_hat\",\n      truth = 20\n    )\n  )\n\n  level_id estimator    n n_reps bias_lambda  mse_lambda\n1        1         M   10    100  -0.0930000  1.75850000\n2        2         V   10    100   0.3353333 96.23611111\n3        3         M  100    100  -0.0877000  0.20287100\n4        4         V  100    100  -0.3656687  9.04930168\n5        5         M 1000    100   0.0198000  0.02163858\n6        6         V 1000    100   0.1130303  0.75417061\n\n\nWe can have information on individual simulation including runtime.\n\nhead(sim$results)\n\n  sim_uid level_id rep_id estimator  n      runtime lambda_hat\n1       1        1      1         M 10 0.0007154942       20.3\n2       7        1      2         M 10 0.0005478859       20.4\n3       8        1      3         M 10 0.0006136894       19.8\n4       9        1      4         M 10 0.0005486012       19.1\n5      10        1      5         M 10 0.0005335808       19.8\n6      11        1      6         M 10 0.0005223751       20.9\n\n\nIt is possible to update simulation with more replicates or a new level. It keeps the old simulations and run only needed ones.\n\nsim &lt;- sim |&gt; \n  set_config(num_sim = 200) |&gt; \n  set_levels(\n    estimator = c(\"M\", \"V\"),\n    n = c(10, 100, 1000, 10000)\n  ) |&gt; \n  update_sim()\n\nDone. No errors or warnings detected.\n\n\n\n\nParallelization\nA specific vignette is available and the introduction precises the terminology for parallel computing (node, core, task, job, etc.). There are two modes of parallelizing code: local or cluster. The first thing is to specify set_config(parallel = TRUE).\n\nLocal: split calculations on several cores of a single computer. If the user’s computer has \\(n\\) cores available, {simEngine} will use \\(n-1\\) cores by default.\nCluster: function run_on_cluster(). To use the function, the user needs to break the code into three blocks : first (code run only once, set-up simulation object), main (a single call to run()) and last (the code will run after all simulation replicates have finished running and after SimEngine has automatically compiled the results into the simulation object.).\n\n\nrun_on_cluster(\n  first = {\n    create_data &lt;- function(n) {\n      return(rpois(n = n, lambda = 20))\n    }\n    est_lambda &lt;- function(dat, type) {\n      if (type == \"M\") {\n        return(mean(dat))\n      }\n      if (type == \"V\") {\n        return(var(dat))\n      }\n    }\n    sim &lt;- new_sim() |&gt; \n      set_levels(estimator = c(\"M\", \"V\"), n = c(10, 100, 1000)) |&gt; \n      set_script(function() {\n        dat &lt;- create_data(L$n)\n        lambda_hat &lt;- est_lambda(dat = dat, type = L$estimator)\n        return(list(\"lambda_hat\" = lambda_hat))\n      }) |&gt; \n      set_config(num_sim = 100, n_cores = 20)\n  },\n  main = {\n    sim &lt;- run(sim)\n  },\n  last = {\n    sim &lt;- summarize(sim)\n  },\n  cluster_config = list(js = \"slurm\")\n)        \n\nDone. No errors or warnings detected.\n\n\nThe cluster_config argument enables to specify options such as the choice of the scheduler.\nExample on how to give instruction to the job scheduler is on the vignette.\nBe caution: the number of cores cannot exceed the total number of simulation replicates.\nFunction to update simulation on a CSS: update_sim_on_cluster(). Difference is we do not need to create a new simulation config but load the existing simulation using readRDS() and use set_config() or set_levels() and update_sim() in the main block.\nThere is a vignette on advanced functionality such as complex results or simulation levels. It exists the batch() function to share data or objects between simulation replicates."
  },
  {
    "objectID": "simulator.html#pros-cons-2",
    "href": "simulator.html#pros-cons-2",
    "title": "Setting up simulations in R",
    "section": "Pros & cons",
    "text": "Pros & cons\n\n\n\n\n\n\n\n\nPros\n\n\n\n\nbeginner friendly;\nlocal and cluster-based computing environments;\nwell-written documentations and website with vignettes (with stat. formula of terminology for parallel computing);\ninformation-sharing across simulation replicates (not tested);\nautomatic calculation of Monte Carlo error (not tested).\n\n\n\n\n\n\n\n\n\n\nCons\n\n\n\n\n\n\n\n\n\nSimulation-based power calculation\nA [specific vignette] is available on the author’s website."
  },
  {
    "objectID": "simulator.html#simchef",
    "href": "simulator.html#simchef",
    "title": "Setting up simulations in R",
    "section": "{simChef}",
    "text": "{simChef}\nThis document describes a simulation experiment using the {simChef} package in R, including data generation, method application, evaluation, and visualization.\nA specific vignette is available on the author’s website for more detailed instructions and examples on using the {simChef} package.\n\nSetup\nThe {simChef} package is not on CRAN and must therefore be installed from GitHub using the {remotes} package as follows:\n\nremotes::install_github(\"Yu-Group/simChef\")\n\nIn {simChef}, a simulation experiment is divided into four components:\n\nDGP(): the data-generating processes (DGPs) from which to generate data;\nMethod(): the methods (or models) to fit on the data in the experiment;\nEvaluator(): the evaluation metrics used to evaluate the methods’ performance;\nVisualizer(): the visualization procedures used to visualize outputs from the method fits or evaluation results (can be tables, plots, or even R Markdown snippets to display).\n\n\n\nStep 1: Define the Data-Generating Process, Methods, and Evaluation Functions\n\nData-Generating Process\nThe following function generates pre- and post-treatment data:\n\ndgp_fun &lt;- function(n, sd, mean_diff) {\n  pre  &lt;- rnorm(n, 0, sd)\n  post &lt;- pre + rnorm(n, mean_diff, sd)\n  list(pre = pre, post = post)\n}\n\n\n\nMethod\nThe following function applies a paired t-test to the data:\n\nmethod_fun &lt;- function(pre, post) {\n  t.test(post, pre, paired = TRUE)\n}\n\n\n\nEvaluation\nThe following function evaluates the power of the test:\n\nevaluation_fun &lt;- function(fit_results) {\n  Power &lt;- fit_results |&gt; \n    dplyr::group_by(n, mean_diff, sd) |&gt; \n    dplyr::summarize(Power = mean(p.value &lt; 0.05))\n}\n\n\n\nVisualization\nThe following function creates a plot to visualize the power:\n\npower_plot_fun &lt;- function(fit_results, eval_results) {\n  fit_results |&gt; \n    dplyr::group_by(n, mean_diff, sd) |&gt; \n    dplyr::summarize(Power = mean(p.value &lt; 0.05)) |&gt; \n    ggplot(aes(n, Power)) + \n    geom_col() + \n    facet_grid(rows = dplyr::vars(sd), cols = dplyr::vars(mean_diff)) + \n    theme_bw()\n}\n\n\n\n\nStep 2: Convert Functions into {simChef} Class Objects\n\ndgp &lt;- create_dgp(\n  .dgp_fun = dgp_fun, .name = \"DGP\"\n)\n\nmethod &lt;- create_method(\n  .method_fun = method_fun, .name = \"T-test\"\n)\n\nevaluation &lt;- create_evaluator(\n  .eval_fun = evaluation_fun , .name = 'P.value'\n)\n\npower_plot &lt;- create_visualizer(\n  .viz_fun = power_plot_fun, .name = 'Power plot'\n)\n\n\n\nStep 3: Assemble the Simulation Experiment\n\nexperiment &lt;- create_experiment(name = \"Example Experiment\") |&gt; \n  add_dgp(dgp) |&gt; \n  add_method(method) |&gt; \n  add_evaluator(evaluation) |&gt; \n  add_visualizer(power_plot)\n\n## Define the grid of simulation parameters\nexperiment &lt;- experiment |&gt; \n  add_vary_across(.dgp = \"DGP\", n = ns, mean_diff = mean_diffs, sd = sds)\n\nprint(experiment)\n\nExperiment Name: Example Experiment \n   Saved results at: results/Example Experiment \n   DGPs: DGP \n   Methods: T-test \n   Evaluators: P.value \n   Visualizers: Power plot \n   Vary Across: \n      DGP: DGP \n         n:  int [1:3] 100 150 200\n         mean_diff:  num [1:3] 10 20 30\n         sd:  num [1:2] 50 100\n\n\n\n\nStep 4: Run the Experiment\n\nresults &lt;- run_experiment(experiment, n_reps = reps, save = TRUE)\n\nFitting Example Experiment...\nSaving fit results...\nFit results saved | time taken: 0.015574 seconds\n10 reps completed (totals: 10/10) | time taken: 0.778566 minutes\n==============================\nEvaluating Example Experiment...\n`summarise()` has grouped output by 'n', 'mean_diff'. You can override using the `.groups` argument.\nEvaluation completed | time taken: 0.000172 minutes\nSaving eval results...\nEval results saved | time taken: 0.053761 seconds\n==============================\nVisualizing Example Experiment...\n`summarise()` has grouped output by 'n', 'mean_diff'. You can override using the `.groups` argument.\nVisualization completed | time taken: 0.000303 minutes\nSaving viz results...\nViz results saved | time taken: 0.073451 seconds\n==============================\n\nDT::datatable(results$fit_results)\n\n\n\n\nresults$viz_results\n\n$`Power plot`"
  },
  {
    "objectID": "simulator.html#pros-cons-3",
    "href": "simulator.html#pros-cons-3",
    "title": "Setting up simulations in R",
    "section": "Pros & cons",
    "text": "Pros & cons\n\n\n\n\n\n\n\n\nPros\n\n\n\n\nAutomated generation of an interactive R Markdown document (see init_docs() and render_docs() functions);\nBeginner friendly;\nComputing experimental replicates in parallel easily with future by adding plan(multisession, workers = n_workers) before run_experiment(experiment, ...);\nFlexibility of the return fitting results of the simulation (not necessarily the same outputs for all methods);\nWe can change the evaluation metrics and the visualization without re-fitting all the simulations by saving the fit_results tibble.\n\n\n\n\n\n\n\n\n\n\nCons\n\n\n\n\nLikely not as fast/optimized as some alternatives;\nOnly save the simulation results computed from the evaluation functions. We cannot debug a strange simulation result."
  },
  {
    "objectID": "pkg.html",
    "href": "pkg.html",
    "title": "Packaging et test",
    "section": "",
    "text": "Un package est un projet (.Rproj) versionné usethis::use_git(). On peut contrôler l’environnement avec {renv}."
  },
  {
    "objectID": "pkg.html#tests",
    "href": "pkg.html#tests",
    "title": "Packaging et test",
    "section": "Tests",
    "text": "Tests\nLes tests sont définis dans le dossier test/testthat. On y accède avec usethis.\nusethis::use_testthat()\n\nusethis::use_test()\n\ndevtools::test()\nIl faut tester (bonnes pratiques) :\n\nles arguments de la fonction (type)\nle résultat attendu\nles erreurs\n…\n\nImportant : définir un test pour chaque bug observé. Définir le test avant de corriger le bug. Ensuite on est content quand le test passe (et on est sur de détecter si ce bug est toujours présent).\nPour aller plus loin, on peut faire du test first. On défini le test avant d’écrire la fonction.\nVoir la doc\n\nGitHub Actions\nPour optimiser les CI/CD on utilise les github actions (ou gitlab, mais c’est pas le même format).\nusethis::use_github() \nusethis::use_github_action()\nusethis::use_pkgdown_github_pages()"
  },
  {
    "objectID": "pkg.html#sources",
    "href": "pkg.html#sources",
    "title": "Packaging et test",
    "section": "Sources",
    "text": "Sources\n\nR Packages (2e)\nD’autres tests avant soumission"
  },
  {
    "objectID": "packaging_and_testing.html",
    "href": "packaging_and_testing.html",
    "title": "Packaging et test, R & Python",
    "section": "",
    "text": "Voici un workflow de développement de package python en intégration continue (CI) à l’aide de git et GitLab.\n\n\n\ninitialisation du repo git init\najouter un fichier .gitignore\nassocier avec un repo sur gitlab avec git remote add origin\ngit push\n\n\n\n\npre-commmit est un package python permettant de maintenir un code de qualité sur le plan de la syntaxe, du formattage du code, et des conventions de nommage. A chaque git commit, pre-commit execute une liste de “hooks”, qui permettent à chacun de vérifier et pointer des erreurs de code.\n\ninstaller pre-commit avec pip install pre-commit\ncréer le fichier .pre-commit-config.yaml (à la racine du répertoire git) avec:\n\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n      - id: black\n\n  - repo: local\n  hooks:\n    - id: pylint\n      name: pylint\n      entry: pylint\n      language: system\n      types: [python]\n      args:\n        [\n          \"-rn\",\n          \"-sn\",\n          \"--load-plugins=pylint.extensions.docparams\",\n        ]\n\n\n\n\ncréer un fichier .gitlab-ci.yml\najouter l’image python par défaut et un stage:\n\nimage: \"python:3.8\"\nstages:\n  - linting\n\najouter des jobs au stage:\n\nblack:\n  stage: linting\n  image: registry.gitlab.com/pipeline-components/black:latest\n  script:\n    - black --check --verbose -- .\n  tags:\n    - docker\npylint:\n  stage: linting\n  before_script:\n    - pip install pylint\n  script:\n    - find . -type f -name \"*.py\" |\n      xargs pylint\n          --disable=import-error\n          --load-plugins=pylint.extensions.docparams\n\n\n\nA présent le repo git devrait avoir cette structure:\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n└── README.md\nCréer un sous-dossier NOM_DE_PACKAGE, et ajouter un fichier __init__.py vide dedans:\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n├── README.md\n└── NOM_DE_PACKAGE/\n    └── __init__.py\nPlacez tous vos sous-modules dans le répertoire NOM_DE_PACKAGE :\n\ntous les modules importés lorsque le module de niveau supérieur est importé doivent être importés dans __init__.py (vous pouvez utiliser l’importation relative).\ntous les modules masqués à l’utilisateur doivent commencer par un _ (prononcé “blanc”).\ntoutes les fonctions/classes accessibles dans le module de niveau supérieur doivent être importées dans __init__.py (avec from … import …).\nsi vous avez des scripts, placez-les dans des sous-modules cachés.\n\nPar exemple, vous obtenez :\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n├── README.md\n└── NOM_DE_PACKAGE/\n├── init.py\n├── _cli.py\n├── _data.py\n├── _functions.py\n└── advanced.py\navec __init__.py contenant :\nfrom ._data import Vector, Species, Tree, Fungus\nfrom ._functions import split, cluster, drop, detect\nadvanced est un sous-module non importé par défaut.\n_cli est un sous-module caché, non importé.\n\n\n\nTestez votre package en vous rendant dans le dossier principal (votre dépôt git).\ntoto@passoir ~/the_git_repo $ ipython\nPython 3.11.9 (main, Jul 16 2024, 11:56:10)\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.26.0 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]: import NOM_DE_PACKAGE\n\nIn [2]: NOM_DE_PACKAGE.cluster\nOut[2]: &lt;function NOM_DE_PACKAGE._functions.cluster(data, values=None)&gt;\n\n\n\nAjoutez un fichier LICENSE. Pour une licence non-virale (MIT, BSD-2…), il est recommandé d’ajouter un en-tête dans chaque fichier avec la licence.\n\n\n\n\nCréez un fichier pyproject.toml :\n[build-system]\nrequires = [\"setuptools\", \"setuptools-scm\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nAvec cette configuration, la version est gérée à l’aide d’un tag git.\nComplétez la description du projet dans pyproject.toml, en conservant la ligne dynamic :\n[project]\nname = \"NOM_DE_PACKAGE\"\ndynamic = [\"version\"]\ndescription = \"La description de votre package\"\nreadme = \"README.md\"\nlicense = {text = \"MIT License\"}\nrequires-python = \"&gt;=3.7\"\nkeywords = []\nauthors = [\n  {name = \"Jean Dupont\", email = \"jean.dupont@exemple.com\"},\n]\nmaintainers = [{name = \"Jean Dupont\", email = \"jean.dupont@exemple.com\"},]\nclassifiers = [\n  \"License :: OSI Approved :: MIT License\",\n  \"Development Status :: 3 - Alpha\",\n  \"Programming Language :: Python\",\n]\ndependencies = [\"numpy\",]\n\nSi vous avez des scripts, déclarez-les dans le fichier pyproject.toml :\n[project.scripts]\nyour_program = \"NOM_DE_PACKAGE._cli:main\"\nIci :\n\nton_program est le nom du script créé\nNOM_DE_PACKAGE._cli est le module chargé pour exécuter la fonction\nmain est la fonction exécutée par le script\n\nDéclarez les URL de votre projet dans pyproject.toml :\n[project.urls]\nhomepage = \"https://example.com/\"\nrepository = \"https://example.com/\"\nVous pouvez utiliser l’URL de GitLab pour le dépôt et le site Web si vous en avez un.\n\n\n\n\nInstallez le module build (avec pip).\n\nInstallation locale :\npip install .\nLe package devrait être installé, rendez-vous dans un autre répertoire, lancez ipython et essayez d’importer votre package. Si vous avez un script, vous pouvez tester le script.\nConstruction locale :\npython3 -m build\nVous obtenez un répertoire dist/ contenant les packages construits.\n\nÀ ce stade, vous avez un packaging fonctionnel. Selon la définition du commit, vous devriez maintenant commettre tout ce travail en une fois.\nRappel : aucun fichier non suivi. Les packages construits ne doivent pas être commis. Veuillez mettre à jour .gitignore.\n\n\n\n\n\n\nDans .gitlab-ci.yml :\n\nAjoutez les étapes build et publish :\nstages:\n  - linting\n  - build\n  - publish\nAjoutez le job pour construire le package :\nbuild_package:\n  stage: build\n  before_script:\n    - pip install build\n  script:\n    - rm -rf dist/\n    - python -m build\n  artifacts:\n    untracked: true\n    expire_in: 1 week\n  tags:\n    - docker\nLe package est disponible pendant une semaine dans les artefacts du job.\nAjoutez le job pour publier le package (uniquement sur les tags) :\npublish_package:\n  stage: publish\n  before_script:\n    - pip install twine\n  script:\n    - TWINE_PASSWORD=${CI_JOB_TOKEN}\n      TWINE_USERNAME=gitlab-ci-token\n      python -m twine upload\n        --repository-url ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi dist/*\n  tags:\n    - docker\n  only:\n    - tags\nLe package est téléchargé uniquement sur les nouveaux tags.\nCommit, push, merge\n\nTestez la construction via la CI.\n\nLe job publish_package est exécuté uniquement sur un tag, un tag représente une version du package. Ensuite, ajoutez un tag avec la version ([Semantic Versioning][semver] avec major.minor.patch est recommandé) :\n git switch main\n git pull\n git tag -m 'version 0.0.1' 0.0.1\n git push --tags\nVérifiez le pipeline (sur GitLab dans CI/CD).\nVérifiez que le package est téléchargé (sur GitLab dans Packages and registries → Package and registry. Copiez l’URL de l’extra-index).\nNettoyez l’extra-index-url, l’authentification n’est pas nécessaire pour un dépôt public (supprimez __token__:&lt;your_personal_token&gt;@).\nMettez à jour le README.md, ajoutez une section Install/Upgrade avec la ligne\npip install --upgrade --extra-index-url https://…\n(Commit, push, merge)"
  },
  {
    "objectID": "packaging_and_testing.html#python-packaging",
    "href": "packaging_and_testing.html#python-packaging",
    "title": "Packaging et test, R & Python",
    "section": "",
    "text": "Voici un workflow de développement de package python en intégration continue (CI) à l’aide de git et GitLab.\n\n\n\ninitialisation du repo git init\najouter un fichier .gitignore\nassocier avec un repo sur gitlab avec git remote add origin\ngit push\n\n\n\n\npre-commmit est un package python permettant de maintenir un code de qualité sur le plan de la syntaxe, du formattage du code, et des conventions de nommage. A chaque git commit, pre-commit execute une liste de “hooks”, qui permettent à chacun de vérifier et pointer des erreurs de code.\n\ninstaller pre-commit avec pip install pre-commit\ncréer le fichier .pre-commit-config.yaml (à la racine du répertoire git) avec:\n\nrepos:\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.4.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n\n  - repo: https://github.com/psf/black\n    rev: 23.3.0\n    hooks:\n      - id: black\n\n  - repo: local\n  hooks:\n    - id: pylint\n      name: pylint\n      entry: pylint\n      language: system\n      types: [python]\n      args:\n        [\n          \"-rn\",\n          \"-sn\",\n          \"--load-plugins=pylint.extensions.docparams\",\n        ]\n\n\n\n\ncréer un fichier .gitlab-ci.yml\najouter l’image python par défaut et un stage:\n\nimage: \"python:3.8\"\nstages:\n  - linting\n\najouter des jobs au stage:\n\nblack:\n  stage: linting\n  image: registry.gitlab.com/pipeline-components/black:latest\n  script:\n    - black --check --verbose -- .\n  tags:\n    - docker\npylint:\n  stage: linting\n  before_script:\n    - pip install pylint\n  script:\n    - find . -type f -name \"*.py\" |\n      xargs pylint\n          --disable=import-error\n          --load-plugins=pylint.extensions.docparams\n\n\n\nA présent le repo git devrait avoir cette structure:\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n└── README.md\nCréer un sous-dossier NOM_DE_PACKAGE, et ajouter un fichier __init__.py vide dedans:\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n├── README.md\n└── NOM_DE_PACKAGE/\n    └── __init__.py\nPlacez tous vos sous-modules dans le répertoire NOM_DE_PACKAGE :\n\ntous les modules importés lorsque le module de niveau supérieur est importé doivent être importés dans __init__.py (vous pouvez utiliser l’importation relative).\ntous les modules masqués à l’utilisateur doivent commencer par un _ (prononcé “blanc”).\ntoutes les fonctions/classes accessibles dans le module de niveau supérieur doivent être importées dans __init__.py (avec from … import …).\nsi vous avez des scripts, placez-les dans des sous-modules cachés.\n\nPar exemple, vous obtenez :\ngit_repo/\n├── .gitignore\n├── .gitlab-ci.yml\n├── .pre-commit-config.yaml\n├── README.md\n└── NOM_DE_PACKAGE/\n├── init.py\n├── _cli.py\n├── _data.py\n├── _functions.py\n└── advanced.py\navec __init__.py contenant :\nfrom ._data import Vector, Species, Tree, Fungus\nfrom ._functions import split, cluster, drop, detect\nadvanced est un sous-module non importé par défaut.\n_cli est un sous-module caché, non importé.\n\n\n\nTestez votre package en vous rendant dans le dossier principal (votre dépôt git).\ntoto@passoir ~/the_git_repo $ ipython\nPython 3.11.9 (main, Jul 16 2024, 11:56:10)\nType 'copyright', 'credits' or 'license' for more information\nIPython 8.26.0 -- An enhanced Interactive Python. Type '?' for help.\nIn [1]: import NOM_DE_PACKAGE\n\nIn [2]: NOM_DE_PACKAGE.cluster\nOut[2]: &lt;function NOM_DE_PACKAGE._functions.cluster(data, values=None)&gt;\n\n\n\nAjoutez un fichier LICENSE. Pour une licence non-virale (MIT, BSD-2…), il est recommandé d’ajouter un en-tête dans chaque fichier avec la licence.\n\n\n\n\nCréez un fichier pyproject.toml :\n[build-system]\nrequires = [\"setuptools\", \"setuptools-scm\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools_scm]\nAvec cette configuration, la version est gérée à l’aide d’un tag git.\nComplétez la description du projet dans pyproject.toml, en conservant la ligne dynamic :\n[project]\nname = \"NOM_DE_PACKAGE\"\ndynamic = [\"version\"]\ndescription = \"La description de votre package\"\nreadme = \"README.md\"\nlicense = {text = \"MIT License\"}\nrequires-python = \"&gt;=3.7\"\nkeywords = []\nauthors = [\n  {name = \"Jean Dupont\", email = \"jean.dupont@exemple.com\"},\n]\nmaintainers = [{name = \"Jean Dupont\", email = \"jean.dupont@exemple.com\"},]\nclassifiers = [\n  \"License :: OSI Approved :: MIT License\",\n  \"Development Status :: 3 - Alpha\",\n  \"Programming Language :: Python\",\n]\ndependencies = [\"numpy\",]\n\nSi vous avez des scripts, déclarez-les dans le fichier pyproject.toml :\n[project.scripts]\nyour_program = \"NOM_DE_PACKAGE._cli:main\"\nIci :\n\nton_program est le nom du script créé\nNOM_DE_PACKAGE._cli est le module chargé pour exécuter la fonction\nmain est la fonction exécutée par le script\n\nDéclarez les URL de votre projet dans pyproject.toml :\n[project.urls]\nhomepage = \"https://example.com/\"\nrepository = \"https://example.com/\"\nVous pouvez utiliser l’URL de GitLab pour le dépôt et le site Web si vous en avez un.\n\n\n\n\nInstallez le module build (avec pip).\n\nInstallation locale :\npip install .\nLe package devrait être installé, rendez-vous dans un autre répertoire, lancez ipython et essayez d’importer votre package. Si vous avez un script, vous pouvez tester le script.\nConstruction locale :\npython3 -m build\nVous obtenez un répertoire dist/ contenant les packages construits.\n\nÀ ce stade, vous avez un packaging fonctionnel. Selon la définition du commit, vous devriez maintenant commettre tout ce travail en une fois.\nRappel : aucun fichier non suivi. Les packages construits ne doivent pas être commis. Veuillez mettre à jour .gitignore.\n\n\n\n\n\n\nDans .gitlab-ci.yml :\n\nAjoutez les étapes build et publish :\nstages:\n  - linting\n  - build\n  - publish\nAjoutez le job pour construire le package :\nbuild_package:\n  stage: build\n  before_script:\n    - pip install build\n  script:\n    - rm -rf dist/\n    - python -m build\n  artifacts:\n    untracked: true\n    expire_in: 1 week\n  tags:\n    - docker\nLe package est disponible pendant une semaine dans les artefacts du job.\nAjoutez le job pour publier le package (uniquement sur les tags) :\npublish_package:\n  stage: publish\n  before_script:\n    - pip install twine\n  script:\n    - TWINE_PASSWORD=${CI_JOB_TOKEN}\n      TWINE_USERNAME=gitlab-ci-token\n      python -m twine upload\n        --repository-url ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/pypi dist/*\n  tags:\n    - docker\n  only:\n    - tags\nLe package est téléchargé uniquement sur les nouveaux tags.\nCommit, push, merge\n\nTestez la construction via la CI.\n\nLe job publish_package est exécuté uniquement sur un tag, un tag représente une version du package. Ensuite, ajoutez un tag avec la version ([Semantic Versioning][semver] avec major.minor.patch est recommandé) :\n git switch main\n git pull\n git tag -m 'version 0.0.1' 0.0.1\n git push --tags\nVérifiez le pipeline (sur GitLab dans CI/CD).\nVérifiez que le package est téléchargé (sur GitLab dans Packages and registries → Package and registry. Copiez l’URL de l’extra-index).\nNettoyez l’extra-index-url, l’authentification n’est pas nécessaire pour un dépôt public (supprimez __token__:&lt;your_personal_token&gt;@).\nMettez à jour le README.md, ajoutez une section Install/Upgrade avec la ligne\npip install --upgrade --extra-index-url https://…\n(Commit, push, merge)"
  },
  {
    "objectID": "plotting_with_julia-1.html",
    "href": "plotting_with_julia-1.html",
    "title": "Using Julia as a R user",
    "section": "",
    "text": "Authors: - Caroline Cognot - Florian Teste"
  },
  {
    "objectID": "plotting_with_julia-1.html#list-of-available-packages",
    "href": "plotting_with_julia-1.html#list-of-available-packages",
    "title": "Using Julia as a R user",
    "section": "list of available packages",
    "text": "list of available packages\nList of packages for plots :\n\n[Plots]\n[StatsPlots] - enriches the Plots package\n[Makie]\n[TidierPlots]\n[AlgebraOfGraphics] uses Makie\n[GadFly]\n\nOther packages are available, see (https://discourse.julialang.org/t/comparison-of-plotting-packages/99860/2)\nWe tried Makie,TidierPlots,AlgebraOfGraphics and GadFly.\n\nImportant note : in the following document, every time we used a function, it was called using PackageName.functionName. This is necessary because we are using packages importing functions of the same name. For example plot is shared between most packages.\nFunctions with names that are not shared can be called by their name only."
  },
  {
    "objectID": "plotting_with_julia-1.html#installation-choose-a-backend-and-install-it.",
    "href": "plotting_with_julia-1.html#installation-choose-a-backend-and-install-it.",
    "title": "Using Julia as a R user",
    "section": "2.1 Installation : choose a backend and install it.",
    "text": "2.1 Installation : choose a backend and install it.\n\nGLMakie (OpenGL based, interactive)\nCairoMakie (Cairo based, static vector graphics)\nWGLMakie (WebGL based, displays plots in the browser)\nRPRMakie (Experimental ray-tracing using RadeonProRender)\n\nThen install it using Julia’s package manager Pkg:\nusing Pkg\n# Pkg.add(\"CairoMakie\")\nThere’s no need to install Makie.jl separately, it is re-exported by each backend package."
  },
  {
    "objectID": "plotting_with_julia-1.html#basic-plotting",
    "href": "plotting_with_julia-1.html#basic-plotting",
    "title": "Using Julia as a R user",
    "section": "2.2 Basic plotting",
    "text": "2.2 Basic plotting\nlines(x,y) scatter(x,y)\nusing CairoMakie\n\nMakie looks more like base R plots. We did not have the time to finish this part."
  },
  {
    "objectID": "plotting_with_julia-1.html#basic-plots",
    "href": "plotting_with_julia-1.html#basic-plots",
    "title": "Using Julia as a R user",
    "section": "3.1 Basic plots",
    "text": "3.1 Basic plots\nThe basic plotting function is also called plot. The syntax when using a DataFrame is as follows :\nplot(data::AbstractDataFrame, elements::Element…; mapping…)\nIt is not exactly the same as the ggplot2 syntax, but close.\nEvery information goes in the same plot() function call.\nhstack(plots) stacks the plots side by side, vstack stacks vertically.\n\n3.1.1 Geom(s) :\n\nThe default geometry is Geom.point.\nothers : https://gadflyjl.org/stable/gallery/geometries/ (with examples), or https://gadflyjl.org/stable/lib/geometries/ for all possibilities\nYou can add as much Geom as you want separated by “,”\n\np1 = Gadfly.plot(penguins, x=:bill_length_mm, y=:bill_depth_mm,color=:species, Geom.point);\np2 = Gadfly.plot(penguins, x=:bill_length_mm, y=:bill_depth_mm,color=:species, Geom.point,Geom.line);\nhstack(p1,p2)\nSaving a plot is done using the draw function.\nNotes :\n\ndefault has no background.\n\nimg = SVG(“penguin_plot.svg”, 14cm, 8cm) draw(img, p1)\nimg = SVG(“penguin_plot.png”, 14cm, 8cm) draw(img, p2)\nWhen using arrays instead of DataFrames, instead, use the data directly. However, the automatic axes do not exist and we have to add them manually using Guide.\n\n\n3.1.2 Guides:\n\nFor adding informations on the plot.\nhttps://gadflyjl.org/stable/gallery/guides/ for examples, https://gadflyjl.org/stable/lib/guides/ for an exhaustive list\n\nExample : same graph usign first arrays, then the DataFrame directly.\nbill_length=penguins.bill_length_mm\nbill_depth=penguins.bill_depth_mm\nspecies = penguins.species\np1 = Gadfly.plot(x=bill_length,y=bill_depth,color=species, Geom.point,\nGuide.xlabel(\"bill length\"),Guide.ylabel(\"bill depth\"),\nGuide.colorkey(title=\"Species\",labels=[\"my favorite specie\",\"others\",\"another one\"]),\nGadfly.Theme(key_position=:inside),Guide.title(\"I love penguins\"));\np2 = Gadfly.plot(penguins,x=:bill_length_mm,y=:bill_depth_mm,color=:species, Geom.point,\nGuide.colorkey(title=\"Species\",labels=[\"my favorite specie\",\"others\",\"another one\"]),\nGadfly.Theme(key_position=:inside),Guide.title(\"I love penguins more\"));\nhstack(p1,p2)\n\n\n3.1.3 Layers\nLayers allow several instructions in the same plot() call.\nExample of layers using the penguins dataframe :\npenguinm = @subset(penguins, :sex .== \"male\")\npenguinf = @subset(penguins, :sex .== \"female\")\n\np3 = Gadfly.plot(penguinm, x=:bill_length_mm, y=:bill_depth_mm,color=[\"male\"],shape=:species, Geom.point,\n    layer(penguinf,x=:bill_length_mm,y=:bill_depth_mm,color=[\"female\"],shape=:species,Geom.point));\n    p3\nColor, and other aesthetics, can also be mapped by using arrays with group labels or functional types e.g. [“group label”] or [colorant”red”]. [“Group labels”] are added to the key. [colorant”red”] are not added to the key, and not present in the legend of the plot.\n#example from Gadfly tutorial :\ny1 = [0.1, 0.26, NaN, 0.5, 0.4, NaN, 0.48, 0.58, 0.83]\nGadfly.plot(x=1:9, y=y1, Geom.line, Geom.point,\n        color=[\"Item 1\"], linestyle=[:dash], size=[3pt],\n    layer(x=1:10, y=rand(10), Geom.line, Geom.point,\n        color=[\"Item 2\"], size=[5pt], shape=[Shape.square]),\n    layer(x=1:10, y=rand(10), color=[colorant\"hotpink\"],\n        linestyle=[[8pt, 3pt, 2pt, 3pt]], Geom.line))\n\n\n3.1.4 Scales\nhttps://gadflyjl.org/stable/tutorial/#Continuous-Scales https://gadflyjl.org/stable/tutorial/#Discrete-Scales\nScale can be supplied with Scale.myscale for continuous and discrete scales."
  },
  {
    "objectID": "plotting_with_julia-1.html#compositing",
    "href": "plotting_with_julia-1.html#compositing",
    "title": "Using Julia as a R user",
    "section": "3.2 Compositing",
    "text": "3.2 Compositing\nhttps://gadflyjl.org/stable/man/compositing/#Compositing\nWith ggplot2, we also like using faceting and grids to represent different data.\n\n3.2.1 Grids using Geom.subplot_grid\nFor grids, we have to use “xgroup” and/or “ygroup” and “Geom.subplot_grid(Geom.mygeomIwant)” instead of just Geom.mygeomIwant. This does the work of +facet_grid().\n# Pkg.add(\"Compose\")\n\nusing Compose\np = Gadfly.plot(penguins, x=:bill_length_mm, y=:bill_depth_mm,xgroup=:species,ygroup=:sex,\n shape=:sex, color=:island, Geom.subplot_grid(Geom.point),alpha=[0.5]);\np\nAdditional Guides can be placed inside the Geom.subplot_grid :\np4 = Gadfly.plot(penguins, x=:bill_length_mm, y=:bill_depth_mm,xgroup=:species,color=:sex,\n shape=:sex,\n  Geom.subplot_grid(Geom.point,Guide.ylabel(orientation=:vertical)),\n  alpha=[0.5],Guide.title(\"I love penguins even more\"));\np4\n\n\n3.2.2 Stacks\nstackings used different plots and hstack,vstack or gridstack.\nvstack(…) puts all argument on top of each other. hstack(…) puts them side by side. gridstack(…) works with a matrix of plots such as [ p1 p2;p3 p4] combining vstack and pstack also works to define different arrangements. a blank panel can be used using only plot()\nvstack(hstack(p1,p2,p3,Gadfly.plot()),hstack(p4))"
  },
  {
    "objectID": "plotting_with_julia-1.html#conclusion-on-this-package",
    "href": "plotting_with_julia-1.html#conclusion-on-this-package",
    "title": "Using Julia as a R user",
    "section": "3.3 Conclusion on this package",
    "text": "3.3 Conclusion on this package\nThe documentation is rich with examples from the RDatasets. There are replacements for common ggplot2 functions. The library lists all available functions, Geom, Guides, Statistics, Coordinates, Scales and Shape available."
  },
  {
    "objectID": "plotting_with_julia-1.html#first-basic-plotting",
    "href": "plotting_with_julia-1.html#first-basic-plotting",
    "title": "Using Julia as a R user",
    "section": "4.1 First basic plotting",
    "text": "4.1 First basic plotting\nAlgebraOfGraphics relies on the * and + operations to combine plotting elements.\nThe plot object is defined through different blocks :\n\ndata() to declare the data used (DataFrame)\nmapping() to declare the aesthetics (aes in ggplot2 or TidierPlots)\n\nif classic plot with x,y : you can use mapping(x=:truc1,truc2) OR mapping (truc1,truc2) but not mapping(x=:truc1,y=:truc2).\n\nvisual()\nanalyses The resulting plot is then shown using draw(plt).\n\npenguin_bill = AOG.data(penguins) * AOG.mapping(:bill_length_mm, :bill_depth_mm,color=:species)\nAOG.draw(penguin_bill; axis = axis)\nTo rename x and y axis, add =&gt; “name of axis”\npenguin_bill = AOG.data(penguins) * AOG.mapping(\n    :bill_length_mm  =&gt; \"bill length (mm)\",\n    :bill_depth_mm  =&gt; \"bill depth (mm)\",\n)\nAOG.draw(penguin_bill; axis = axis)\nTo apply a transformation to the values (mm to cm in this example), add =&gt; (t-&gt;transformation(t))\npenguin_bill = AOG.data(penguins) * AOG.mapping(\n    :bill_length_mm =&gt; (t -&gt; t / 10) =&gt; \"bill length (cm)\",\n    :bill_depth_mm =&gt; (t -&gt; t / 10) =&gt; \"bill depth (cm)\",\n)\nAOG.draw(penguin_bill; axis = axis)\nTo add information, take your first plot object and add new mappings :\nplt = penguin_bill * AOG.mapping(color = :species)\nAOG.draw(plt; axis = axis)"
  },
  {
    "objectID": "plotting_with_julia-1.html#combining-and",
    "href": "plotting_with_julia-1.html#combining-and",
    "title": "Using Julia as a R user",
    "section": "4.2 Combining + and *",
    "text": "4.2 Combining + and *\n\nthe * operator adds information on a plot\nthe + operator adds a new layer\n\nWe can use factorisation to combine the two operations. In this “Algebra Of Graphics”, mapping() is the “neutral” element.\nThe linear regression removes the point plots. We have to add it back on the plot, using +\nAnd factorise this :\n\nplt = penguin_bill * (AOG.linear() + AOG.mapping()) * AOG.mapping(color = :species)\nAOG.draw(plt; axis = axis)"
  },
  {
    "objectID": "plotting_with_julia-1.html#mapping",
    "href": "plotting_with_julia-1.html#mapping",
    "title": "Using Julia as a R user",
    "section": "4.3 mapping()",
    "text": "4.3 mapping()\nExamples of mappings :\n\ncolor =: colorkey\ncol= :variablename; to use when gridding plots horizontally across variablename\nrow=: variablename; for gridding vertically\nlayout=:variablename\n\nIf no data was set, the entries of mapping have to be vectors.\nThe structure of the mapping is tied to the plotting function used with it (analysis), and the visual attribute. See documentations for more information.\n\nPair operator =&gt; is used to rename columns, transform columns, map to a custom scale"
  },
  {
    "objectID": "plotting_with_julia-1.html#visual",
    "href": "plotting_with_julia-1.html#visual",
    "title": "Using Julia as a R user",
    "section": "4.4 visual()",
    "text": "4.4 visual()\ndefault is the xy scatterplot. command : visual(plottype; attributes…)\nExamples : - BarPlot - Heatmap\npenguin_bill = AOG.data(penguins) * AOG.mapping(\n    :body_mass_g,:species,color=:sex,layout=:island\n    \n)*AOG.visual(BarPlot)\nAOG.draw(penguin_bill; axis = axis)"
  },
  {
    "objectID": "plotting_with_julia-1.html#analyses",
    "href": "plotting_with_julia-1.html#analyses",
    "title": "Using Julia as a R user",
    "section": "4.5 analyses",
    "text": "4.5 analyses\nThey do more complicated operation. Examples :\n\nhistogram()\ndensity()\nfrequency()\nlinear()\nexpectation() : compute expected value of last arg, conditionned on previous.\nsmooth\ncontours, filled_contours"
  },
  {
    "objectID": "plotting_with_julia-1.html#one-last-example",
    "href": "plotting_with_julia-1.html#one-last-example",
    "title": "Using Julia as a R user",
    "section": "4.6 One last example",
    "text": "4.6 One last example\n\npenguinsplot = AOG.data(penguins)*\n    AOG.mapping(:bill_length_mm,:bill_depth_mm,\n    col=:species,row=:sex,marker=:sex,color=:island)\nAOG.draw(penguinsplot)"
  },
  {
    "objectID": "python_practice.html",
    "href": "python_practice.html",
    "title": "Bien démarrer avec Python",
    "section": "",
    "text": "Lorsque l’on utilise Python, une bonne pratique consiste à créer un environnement spécifique par projet. L’environnement contient la version de Python que l’on souhaite utiliser ainsi que les packages/modules utiles au projet. Cette façon de faire permet de faire coexister différentes versions de python ou de packages au sein du même ordinateur. Cette pratique n’est pas spécifique à Python, on pourrait imaginer créer des environnements pour utiliser des versions différentes de R. Si le programme ou la librairie n’est pas installée dans l’environnement mais est disponible dans l’installation globale de la machine, c’est cette version globale qui sera utilisée. Il faut donc bien vérifier ce qui est dispo dans l’environnement et globalement.\nNous avons exploré deux manières de gérer les environnements soit avec conda soit avec virtual env. Nous avons testé sous Linux et sous Windows."
  },
  {
    "objectID": "python_practice.html#installation-python-et-problèmes-potentiels",
    "href": "python_practice.html#installation-python-et-problèmes-potentiels",
    "title": "Bien démarrer avec Python",
    "section": "Installation python et problèmes potentiels",
    "text": "Installation python et problèmes potentiels\nOn crée un lien symbolique pour que python 3 soit le python par défaut en utilisant les instructions suivantes:\nsudo ln -sf /usr/bin/python3 /usr/bin/python\nOn fait de même pour pip qui est un des installateurs de modules/ packages.\nsudo ln -sf /usr/bin/pip3 /usr/bin/pip"
  },
  {
    "objectID": "python_practice.html#créer-un-environnement-avec-conda-sous-linux",
    "href": "python_practice.html#créer-un-environnement-avec-conda-sous-linux",
    "title": "Bien démarrer avec Python",
    "section": "Créer un environnement avec conda sous Linux",
    "text": "Créer un environnement avec conda sous Linux\nCette partie suppose que la commande conda est disponible (installée avec anaconda ou miniconda)\nLa liste des environnement disponible est donnée par\nconda env list\nVous devez avoir au moins l’environnement de base dans cette liste. Vous avez aussi ainsi accès à l’adresse où vous trouverez vos environnements.\nOn souhaite créer un nouvel environnement nommé finistr contenant uniquement python et pip.\nIl suffit de lancer la commande conda create --name finistr python=3.11 pip\nEn listant les environnements disponibles, vous devez voir l’environnement finistr créé.\nconda env list\nIl est très important d’installer pip en meme temps, sinon c’est le pip global du systeme qui est utilisé et toutes les commades pip install lancées depuis l’environnement feront en fait des installations globales et non locales à l’environnement (plus de détails ici )\nPour utiliser cette installation, il faut activer l’environnement\nconda activate finistr\nOn peut maintenant installer les packages de son choix avec des commandes type conda install ou pip install\nPar exemple pip install numpy\nPour avoir la liste des packages installés dans l’environnemnet courant conda list\nOn quitte l’environnement avec la commande conda deactivate. Quand vous reviendrez à votre environnement (conda activate) vous aurez ces packages installés.\nIl est possible de fournir une liste de packages à installer dans l’environnement sous forme d’un fichier txt.\n\nconda create --name finistrbis python=3.11 pip \nconda activate finistrbis\npip install -r requirements.txt\n\nLe fichier requirement.txt a la forme suivante\n\n\njupyter==1.0.0\nnumpy==2.1.0\n\n\n\nAutres commandes\nIl est possible de supprimer un environnement avec la commande\n\nconda remove --name finistrbis --all\n\nLa liste des commandes conda est disponible dans la cheatsheet conda"
  },
  {
    "objectID": "python_practice.html#installation-et-création-denvironnement-avec-windows",
    "href": "python_practice.html#installation-et-création-denvironnement-avec-windows",
    "title": "Bien démarrer avec Python",
    "section": "Installation et création d’environnement avec Windows",
    "text": "Installation et création d’environnement avec Windows\nNous présentons ici 3 étapes importantes pour l’utilisation de Python sous Windows\n\nl’installation d’une version de Python,\nl’utilisation d’un éditeur de code\nla création et l’utilisation d’un environnement Python pour programmer.\n\nDifférentes approches existent pour réaliser chacune de ces tâches, nous présentons ici une approche pour chaque.\n\nInstallation de Python\nStratégie Python est nativement disponible sous Linux. Une possibilité pour utiliser Python sous Windows est donc d’installer un sous-environnement Linux via WSL2 (Windows subsystem for linux), et d’utiliser la version de Python qui vient avec.\n\nInstaller WSL2\nL’installation de WSL2 se fait via la commande (terminal PowerShell) :\n\nwsl --install\n\nAprès redémarrage, on peut vérifier quelle version de linux est installée :\n\nwsl -l -v\n\nA noter qu’il est possible de préciser l’installation Linux que l’on veut installer :\n\nwsl --instal -d &lt;Distribution&gt;\n\nDans l’exemple qui suit nous avons utilisé Ubuntu. Il est maintenant possible de lancer un terminal Linux avec la commande\n\nstart ubuntu.exe\n\net d’aller vérifier la version de Python disponible.\n\n\nPython\nOn se place maintenant dans le terminal Ubuntu. Comme précédemment mentionné Python est directement disponible sous Linux, ce qui se vérifie de la manière suivante :\n\nwhich python\npython --version\n\nNous allons par la suite utiliser deux fonctionnalités de python : l’installation de package via pip (“python install package”) et la création d’environnements virtuels via virtualenv. Ces deux fonctionnalités sont normalement directement disponibles, si ce n’est pas le cas l’installation se fait via\n\nsudo apt-get update\nsudo apt install python3-pip\npip install virtualenv  \n\nIl est parfois nécessaire de créer un alias python pour python3 et pip pour pip3:\n\nsource ~/.bashrc\nalias python=python3\nalias pip=pip3\n\nAlternativement on peut créer un lien symbolique entre pip3 et pip :\n\nsudo ln -s /usr/bin/python3 /usr/bin/python\nsudo ln -s /usr/bin/pip3 /usr/bin/pip\n\nUne fois la vérification de python et des fonctionnalités pip et virtualenv faite, on peut interagir avec python (créer des environnements, coder, tester, etc.) via le terminal de l’éditeur de code VSC, et nous n’aurons plus besoin ni de l’invite de commande Windows, ni du terminal WSL.\n\n\n\nUtilisation de VSC\nPréalable : installer VSCode (sous Windows) !\n\nChoisir un environnement distant\nA l’ouverture de VSC, la première étape consiste à préciser que l’on souhaite travailler dans le sous-environnement Linux via WSL (où se trouve python…).\nPour cela, il faut - configurer VSC en installant le module d’extension “WSL” de VSC (via l’icone d’installation d’extension) - ouvrir un environnement distant via l’icone “Open a Remote Window” en bas de la fenêtre VSC, et choisir “Connect to WSL”. Le sous-environnement de travail est maintenant “WSL:Ubuntu”\nUne fois dans cet environnement, il est conseillé d’installer le module d’extension “Python”.\n\n\nOuvrir un terminal\nUne fois l’environnement de travail défini, on peut ouvrir un terminal. Le terminal qui s’ouvre dans VSC est l’équivalent d’un terminal WSL. On peut donc executer\n\nwhich python\npython --version\n\net vérifier que l’on obtient la même version que précédemment.\n\n\n\nCréation d’un environnement python\nDans le terminal WSL ouvert dans VSC, on peut maintenant créer un environnement python via la commande\n\npython -m venv Chemin/NomEnv  \n\nce qui crée un répertoire “NomEnv” au Chemin indiqué (si besoin, pour supprimer l’env : rm -rf NomEnv).\nCet environnement peut être activé comme suit :\n\nsource Chemin/NomEnv/bin/activate\n\nou alternativement\n\n. Chemin/NomEnv/bin/activate\n\nNote L’activation de l’environnement se traduit par un changement dans le prompteur, qui mentionne maintenant “(NomEnv)” devant le nom d’utilisateur de la session.\nL’environnement va définir la version de Python ainsi que les packages/modules que l’on souhaite utiliser pour le projet. Par défaut la version de python de l’environnement nouvellement créé est la version de python utilisée pour créer l’environnement (ce que l’on peut vérifier avec python --version). Il reste donc à installer les packages nécessaires au projet, ce qui se fait avec pip. Un exemple avec le package numpy:\n\npip install numpy\n\nIl est possible de lister à tout moment les packages déjà inclus dans un projet avec l’instruction pip list Une fois l’environnement configuré, on “sort” de l’environnement avec l’instruction deactivate.\n\n\nProgrammer, exécuter… dans un environnement python\nL’environnement NomEnv étant maintenant disponible, on peut se placer dedans pour travailler et écrire nos premières lignes de code. Il suffit pour cela d’ouvrir/créer un fichier python (toujours dans VSC).\n\nExecution en ligne de commande\nTout est prêt mais l’exécution du code ligne à ligne n’est pas directement accessible sur python. Pour y avoir accès il suffit d’installer le package ipython dans l’environnement python (cf paragraphe précédent) d’une part, et d’installer l’extension “iPython for VS Code” dans VSC. Une fois ces deux étapes réalisées, l’exécution de la commande iPython dans le terminal à l’exécution en ligne.\nREMARQUE (fonctionne sur toutes les distributions en théorie, mais uniquement testé sur MacOS): Afin de retrouver la fonctionnalité d’exécution d’une ligne de code avec shift + enter dans la console de R studio, il est nécéssaire de modifier le fichier settings.json de VSC (en mode WSL). Pour cela, taper ctrl + shift + P et rechercher Open User Settings (JSON). Rajouter à la suite des options existantes:\n\"python.terminal.launchArgs\": [\n     \"-m\",\n    \"IPython\",\n    \"--no-autoindent\"\n],"
  },
  {
    "objectID": "python_practice.html#utiliser-un-environnement-de-développement-agréable-pour-un-utilisateur-de-r",
    "href": "python_practice.html#utiliser-un-environnement-de-développement-agréable-pour-un-utilisateur-de-r",
    "title": "Bien démarrer avec Python",
    "section": "Utiliser un environnement de développement agréable pour un utilisateur de R",
    "text": "Utiliser un environnement de développement agréable pour un utilisateur de R"
  },
  {
    "objectID": "python_practice.html#avec-visual-studio-code",
    "href": "python_practice.html#avec-visual-studio-code",
    "title": "Bien démarrer avec Python",
    "section": "Avec Visual Studio Code",
    "text": "Avec Visual Studio Code\nipython\n\nAvec Positron\nLe nouvel IDE Positron (disponible en version beta) semble avoir des avantages intéressants pour les gens qui aiment Rstudio mais veulent faire du python. Notamment, il est possible\n\nde choisir facilement son environnement (menu déroulant en haut à droite) et\nd’utiliser la commande Ctr+entr pour éxécuter un code Python ligne à ligne comme on le fera pour un code R dans Rstudio."
  },
  {
    "objectID": "reproducibility.html",
    "href": "reproducibility.html",
    "title": "Reproducibility with renv, docker+renv, and rix",
    "section": "",
    "text": "We consider three options to reproduce Armand’s Computo paper: Favrot and Makowski (2024)\n\nlocally, using only renv\nusing docker + renv\nusing rix\n\nThe GitHub repository for the paper is available on the Computo page."
  },
  {
    "objectID": "reproducibility.html#installation",
    "href": "reproducibility.html#installation",
    "title": "Reproducibility with renv, docker+renv, and rix",
    "section": "Installation",
    "text": "Installation\nFirst Nix should be installed, see dedicated vignette.\nThen the R package rix should be installed:\n\ninstall.packages(\"rix\", repos = c(\n  \"https://b-rodrigues.r-universe.dev\",\n  \"https://cloud.r-project.org\"\n))\n\n\nlibrary(rix)"
  },
  {
    "objectID": "reproducibility.html#using-rix-to-build-project-specific-environments",
    "href": "reproducibility.html#using-rix-to-build-project-specific-environments",
    "title": "Reproducibility with renv, docker+renv, and rix",
    "section": "Using rix to build project specific environments",
    "text": "Using rix to build project specific environments\nSee dedicated vignette\n\npath_default_nix &lt;- \"/tmp/rix-test\"\n\nrix(\n  r_ver = \"latest\",\n  r_pkgs = c(\"dplyr\", \"ggplot2\"),\n  system_pkgs = NULL,\n  git_pkgs = NULL,\n  ide = \"rstudio\",\n  project_path = path_default_nix,\n  overwrite = TRUE,\n  print = TRUE\n)\n\n# This file was generated by the {rix} R package v0.9.1 on 2024-09-10\n# with following call:\n# &gt;rix(r_ver = \"5775c2583f1801df7b790bf7f7d710a19bac66f4\",\n#  &gt; r_pkgs = c(\"dplyr\",\n#  &gt; \"ggplot2\"),\n#  &gt; system_pkgs = NULL,\n#  &gt; git_pkgs = NULL,\n#  &gt; ide = \"rstudio\",\n#  &gt; project_path = path_default_nix,\n#  &gt; overwrite = TRUE,\n#  &gt; print = TRUE)\n# It uses nixpkgs' revision 5775c2583f1801df7b790bf7f7d710a19bac66f4 for reproducibility purposes\n# which will install R version latest.\n# Report any issues to https://github.com/b-rodrigues/rix\nlet\n pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/5775c2583f1801df7b790bf7f7d710a19bac66f4.tar.gz\") {};\n \n  rpkgs = builtins.attrValues {\n    inherit (pkgs.rPackages) \n      dplyr\n      ggplot2;\n  };\n    \n  system_packages = builtins.attrValues {\n    inherit (pkgs) \n      R\n      glibcLocales\n      nix;\n  };\n \n  wrapped_pkgs = pkgs.rstudioWrapper.override {\n    packages = [  rpkgs  ];\n  };\n \nin\n\npkgs.mkShell {\n  LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then  \"${pkgs.glibcLocales}/lib/locale/locale-archive\" else \"\";\n  LANG = \"en_US.UTF-8\";\n   LC_ALL = \"en_US.UTF-8\";\n   LC_TIME = \"en_US.UTF-8\";\n   LC_MONETARY = \"en_US.UTF-8\";\n   LC_PAPER = \"en_US.UTF-8\";\n   LC_MEASUREMENT = \"en_US.UTF-8\";\n\n  buildInputs = [  rpkgs  system_packages  wrapped_pkgs ];\n  \n}\n\n### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###\n\n==&gt; Existing isolated nix-R project folder:\n /tmp/rix-test \n\n* current R session running outside Nix environment and not from RStudio\n\n==&gt; Added `.Rprofile` file and code lines for new R sessions launched from:\n/tmp/rix-test\n\n* Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:\n/nix/var/nix/profiles/default/bin\n\n==&gt; Also adjusting `PATH` via `Sys.setenv()`, so that system commands can invoke key Nix commands like `nix-build` in this RStudio session outside Nix\n\n\n\n\n### Successfully generated `default.nix` and `.Rprofile` ###\n\n\nTo start using this environment, open a terminal in the folder containing default.nix (i.e.) /tmp/rix-test and use the following Nix command:\n\ncd /tmp/rix-test\nnix-build\n\n\n\n\n\n\n\nNote: this should not be done via the Rstudio command line but from an external terminal\n\n\n\n\n\nIndeed within Rstudio this may fail with:\n\nnix-build: /usr/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.38' not found (required by nix-build)\nnix-build: /usr/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.38' not found (required by /nix/store/4z754a0vzl98asv0pa95i5d9szw5jqbs-lowdown-1.0.2-lib/lib/liblowdown.so.3)\nnix-build: /usr/lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.38' not found (required by /nix/store/hinq0w2cd8rzw32hwz3pm3x0bvv0l0qa-nix-2.23.3/lib/libnixexpr.so)\n\nwhereas it works well with GLIBC_2.35 from a standard terminal. Moreover, glibc is a system library that should not be updated manually. See also: https://github.com/NixOS/nixpkgs/issues/287764\n\n\n\nOne can then do nix-shell and use R from this shell:\n\n$ nix-shell\nunpacking 'github:NixOS/nixpkgs/36a9aeaaa17a2d4348498275f9fe530cd4f9e519' into the Git cache...\n[nix-shell:/tmp/rix-test]$ \n\nNote that the prompt specifies that we are in a Nix session.\n\n[nix-shell:/tmp/rix-test]$ R\n\nR version 4.4.1 (2024-06-14) -- \"Race for Your Life\"\nCopyright (C) 2024 The R Foundation for Statistical Computing\nPlatform: x86_64-pc-linux-gnu\n\nR is free software and comes with ABSOLUTELY NO WARRANTY.\nYou are welcome to redistribute it under certain conditions.\nType 'license()' or 'licence()' for distribution details.\n\n  Natural language support but running in an English locale\n\nR is a collaborative project with many contributors.\nType 'contributors()' for more information and\n'citation()' on how to cite R or R packages in publications.\n\nType 'demo()' for some demos, 'help()' for on-line help, or\n'help.start()' for an HTML browser interface to help.\nType 'q()' to quit R.\n\n&gt; library(\"dplyr\")\n\nAttaching package: ‘dplyr’\n\nThe following objects are masked from ‘package:stats’:\n\n    filter, lag\n\nThe following objects are masked from ‘package:base’:\n\n    intersect, setdiff, setequal, union"
  },
  {
    "objectID": "reproducibility.html#case-study-reproducing-armands-computo-paper",
    "href": "reproducibility.html#case-study-reproducing-armands-computo-paper",
    "title": "Reproducibility with renv, docker+renv, and rix",
    "section": "Case study: reproducing Armand’s Computo paper",
    "text": "Case study: reproducing Armand’s Computo paper\nWe clone the repo of the paper (in a temporary directory in order to avoid nested R projects and nested git projects)\n\n$ cd /tmp/\n$ git clone git@github.com:computorg/published-202312-favrot-hierarchical.git\nCloning into 'published-202312-favrot-hierarchical'...\nremote: Enumerating objects: 356, done.\nremote: Counting objects: 100% (22/22), done.\nremote: Compressing objects: 100% (8/8), done.\nremote: Total 356 (delta 15), reused 14 (delta 14), pack-reused 334 (from 1)\nReceiving objects: 100% (356/356), 62.41 MiB | 2.32 MiB/s, done.\nResolving deltas: 100% (182/182), done.\n\nWe install the quarto extension for computo:\n\n$ cd /tmp/published-202312-favrot-hierarchical\n$ quarto add computorg/computo-quarto-extension\nQuarto extensions may execute code when documents are rendered. If you do not \ntrust the authors of the extension, we recommend that you do not install or \nuse the extension.\n? Do you trust the authors of this extension (Y/n) › Yes\n[✓] Downloading\n[✓] Unzipping\n    Found 1 extension.\n\nThe following changes will be made:\nComputo Format Template   [Install]   0.2.5 (formats)\n? Would you like to continue (Y/n) › Yes\n\n[✓] Copying\n[✓] Extension installation complete\n\n? View documentation using default browser? (Y/n) › n\n\n\n\n\n\n\n\nInstalling system dependencies via rix\n\n\n\nAccording to https://b-rodrigues.github.io/rix/articles/building-an-environment-for-literate-programming.html it can be done via the option system_pkgs. Note that it is also possible to specify LaTeX packages to be installed, via the option tex_pkgs:\n\npath_default_nix &lt;- tempdir()\n\nrix(r_ver = \"4.3.1\",\n    r_pkgs = c(\"quarto\"),\n    system_pkgs = \"quarto\",\n    tex_pkgs = c(\"amsmath\"),\n    ide = \"other\",\n    shell_hook = \"\",\n    project_path = path_default_nix,\n    overwrite = TRUE,\n    print = TRUE)\n\n\n\nThe R packages used in this publication are managed using the R package renv. So we retrieve the R version and the packages listed in the renv.lock file (note that this cannot be done from another project, so this command is not evaluated here):\n\n&gt; status &lt;- renv::status(\"/tmp/published-202312-favrot-hierarchical\")\n&gt; R_version &lt;- status$lockfile$R$Version\n&gt; R_version\n[1] \"4.2.2\"\n&gt; pkgs &lt;- names(status$lockfile$Packages)\n&gt; str(pkgs)\n chr [1:110] \"DBI\" \"MASS\" \"Matrix\" \"R6\" \"RColorBrewer\" \"askpass\" ...\n&gt; saveRDS(list(version = R_version, pkgs = pkgs), file = \"repro_favrot.rds\")\n\nWe then use these info to setup a configuration file for Nix via rix:\n\ninfo &lt;- readRDS(\"repro_favrot.rds\")\nR_version &lt;- info[[\"version\"]]\npkgs &lt;- info[[\"pkgs\"]]\nlibrary(rix)\npath_default_nix &lt;- \"/tmp/published-202312-favrot-hierarchical\"\nrix(\n  r_ver = R_version,\n  r_pkgs = pkgs,\n  system_pkgs = \"quarto\",\n  git_pkgs = NULL,\n  ide = \"rstudio\",\n  project_path = path_default_nix,\n  overwrite = TRUE,\n  print = TRUE\n)\n\n# This file was generated by the {rix} R package v0.9.1 on 2024-09-10\n# with following call:\n# &gt;rix(r_ver = \"8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8\",\n#  &gt; r_pkgs = pkgs,\n#  &gt; system_pkgs = \"quarto\",\n#  &gt; git_pkgs = NULL,\n#  &gt; ide = \"rstudio\",\n#  &gt; project_path = path_default_nix,\n#  &gt; overwrite = TRUE,\n#  &gt; print = TRUE)\n# It uses nixpkgs' revision 8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8 for reproducibility purposes\n# which will install R version 4.2.2.\n# Report any issues to https://github.com/b-rodrigues/rix\nlet\n pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz\") {};\n \n  rpkgs = builtins.attrValues {\n    inherit (pkgs.rPackages) \n      DBI\n      MASS\n      Matrix\n      R6\n      RColorBrewer\n      askpass\n      assertthat\n      backports\n      base64enc\n      bit\n      bit64\n      blob\n      broom\n      bslib\n      callr\n      cellranger\n      cli\n      clipr\n      coda\n      colorspace\n      cowplot\n      cpp11\n      crayon\n      curl\n      data_table\n      dbplyr\n      digest\n      dplyr\n      dtplyr\n      ellipsis\n      evaluate\n      fansi\n      farver\n      fastmap\n      forcats\n      fs\n      gargle\n      generics\n      ggplot2\n      glue\n      googledrive\n      googlesheets4\n      gridExtra\n      gtable\n      haven\n      highr\n      hms\n      htmltools\n      httr\n      ids\n      isoband\n      jquerylib\n      jsonlite\n      kableExtra\n      knitr\n      labeling\n      latex2exp\n      lattice\n      lifecycle\n      lubridate\n      magrittr\n      mgcv\n      mime\n      modelr\n      munsell\n      nlme\n      openssl\n      pillar\n      pkgconfig\n      prettyunits\n      processx\n      progress\n      ps\n      purrr\n      rappdirs\n      readr\n      readxl\n      rematch\n      rematch2\n      renv\n      reprex\n      rjags\n      rlang\n      rmarkdown\n      rstudioapi\n      rvest\n      sass\n      scales\n      selectr\n      stringi\n      stringr\n      svglite\n      sys\n      systemfonts\n      tibble\n      tidyr\n      tidyselect\n      tidyverse\n      tinytex\n      tzdb\n      utf8\n      uuid\n      vctrs\n      viridisLite\n      vroom\n      webshot\n      withr\n      xfun\n      xml2\n      yaml;\n  };\n    \n  system_packages = builtins.attrValues {\n    inherit (pkgs) \n      quarto\n      R\n      glibcLocales\n      nix;\n  };\n \n  wrapped_pkgs = pkgs.rstudioWrapper.override {\n    packages = [  rpkgs  ];\n  };\n \nin\n\npkgs.mkShell {\n  LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then  \"${pkgs.glibcLocales}/lib/locale/locale-archive\" else \"\";\n  LANG = \"en_US.UTF-8\";\n   LC_ALL = \"en_US.UTF-8\";\n   LC_TIME = \"en_US.UTF-8\";\n   LC_MONETARY = \"en_US.UTF-8\";\n   LC_PAPER = \"en_US.UTF-8\";\n   LC_MEASUREMENT = \"en_US.UTF-8\";\n\n  buildInputs = [  rpkgs  system_packages  wrapped_pkgs ];\n  \n}\n\n### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###\n\n==&gt; Existing isolated nix-R project folder:\n /tmp/published-202312-favrot-hierarchical \n\n* current R session running outside Nix environment and not from RStudio\n\n==&gt; Added `.Rprofile` file and code lines for new R sessions launched from:\n/tmp/published-202312-favrot-hierarchical\n\n* Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:\n/nix/var/nix/profiles/default/bin\n\n==&gt; Also adjusting `PATH` via `Sys.setenv()`, so that system commands can invoke key Nix commands like `nix-build` in this RStudio session outside Nix\n\n\n\n\n### Successfully generated `default.nix` and `.Rprofile` ###\n\n\nNote that the above triggers the following warning because an .Rprofile``` file already exists.  In this case this file is only used byrenvand we will not needrenv` so we do not follow the advice to ‘append’ and instead choose to ‘overwrite’:\n\nlibrary(\"rix\")\npath_default_nix &lt;- \"/tmp/published-202312-favrot-hierarchical\"\nrix_init(rprofile_action = 'overwrite', project_path = path_default_nix)\n# ### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###\n# ==&gt; Existing isolated nix-R project folder:\n#  /tmp/published-202312-favrot-hierarchical \n# \n# * current R session running outside Nix environment and not from RStudio\n# \n# ==&gt; Overwrote `.Rprofile` file and code lines for new R sessions launched from:\n# /tmp/published-202312-favrot-hierarchical\n# \n# * Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:\n# /nix/var/nix/profiles/default/bin&gt; \n\nWe are now ready to build and launch the corresponding Nix environment:\n\nnix-build \nnix-shell\n\nAnd to try to render the publication:\n\n[nix-shell:/tmp/published-202312-favrot-hierarchical]$quarto render\n\nUnfortunately codetools is needed (why??) and was not specified in the renv.lock file, so it is missing and compilation fails:\n\nQuitting from lines 343-346 (published-202312-favrot-hierarchical.qmd) \nError in loadNamespace(x) : there is no package called 'codetools'\nCalls: .main ... loadNamespace -&gt; withRestarts -&gt; withOneRestart -&gt; doWithOneRestart\n\nExecution halted\n\nNote that it is not possible to install packages directly from within Nix\n\n&gt; install.packages(\"codetools\")\nError in install.packages(\"codetools\") : \n  You are currently in an R session running from Nix.\nDon't install packages using install.packages(),\nadd them to the default.nix file instead.\n\nSo we go back to the configuration of our Nix environment:\n\ninfo &lt;- readRDS(\"repro_favrot.rds\")\nR_version &lt;- info[[\"version\"]]\npkgs &lt;- info[[\"pkgs\"]]\nlibrary(rix)\npath_default_nix &lt;- \"/tmp/published-202312-favrot-hierarchical\"\nrix_init(rprofile_action = 'overwrite', project_path = path_default_nix)\n\n\n### Bootstrapping isolated, project-specific, and runtime-pure R setup via Nix ###\n\n==&gt; Existing isolated nix-R project folder:\n /tmp/published-202312-favrot-hierarchical \n\n* current R session running outside Nix environment and not from RStudio\n\n==&gt; Overwrote `.Rprofile` file and code lines for new R sessions launched from:\n/tmp/published-202312-favrot-hierarchical\n\n* Added the location of the Nix store to `PATH` environmental variable for new R sessions on host/docker RStudio:\n/nix/var/nix/profiles/default/bin\n\nrix(\n  r_ver = R_version,\n  r_pkgs = c(pkgs, \"codetools\"),\n  system_pkgs = NULL,\n  git_pkgs = NULL,\n  ide = \"rstudio\",\n  project_path = path_default_nix,\n  overwrite = TRUE,\n  print = TRUE\n)\n\n# This file was generated by the {rix} R package v0.9.1 on 2024-09-10\n# with following call:\n# &gt;rix(r_ver = \"8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8\",\n#  &gt; r_pkgs = c(pkgs,\n#  &gt; \"codetools\"),\n#  &gt; system_pkgs = NULL,\n#  &gt; git_pkgs = NULL,\n#  &gt; ide = \"rstudio\",\n#  &gt; project_path = path_default_nix,\n#  &gt; overwrite = TRUE,\n#  &gt; print = TRUE)\n# It uses nixpkgs' revision 8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8 for reproducibility purposes\n# which will install R version 4.2.2.\n# Report any issues to https://github.com/b-rodrigues/rix\nlet\n pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/8ad5e8132c5dcf977e308e7bf5517cc6cc0bf7d8.tar.gz\") {};\n \n  rpkgs = builtins.attrValues {\n    inherit (pkgs.rPackages) \n      DBI\n      MASS\n      Matrix\n      R6\n      RColorBrewer\n      askpass\n      assertthat\n      backports\n      base64enc\n      bit\n      bit64\n      blob\n      broom\n      bslib\n      callr\n      cellranger\n      cli\n      clipr\n      coda\n      colorspace\n      cowplot\n      cpp11\n      crayon\n      curl\n      data_table\n      dbplyr\n      digest\n      dplyr\n      dtplyr\n      ellipsis\n      evaluate\n      fansi\n      farver\n      fastmap\n      forcats\n      fs\n      gargle\n      generics\n      ggplot2\n      glue\n      googledrive\n      googlesheets4\n      gridExtra\n      gtable\n      haven\n      highr\n      hms\n      htmltools\n      httr\n      ids\n      isoband\n      jquerylib\n      jsonlite\n      kableExtra\n      knitr\n      labeling\n      latex2exp\n      lattice\n      lifecycle\n      lubridate\n      magrittr\n      mgcv\n      mime\n      modelr\n      munsell\n      nlme\n      openssl\n      pillar\n      pkgconfig\n      prettyunits\n      processx\n      progress\n      ps\n      purrr\n      rappdirs\n      readr\n      readxl\n      rematch\n      rematch2\n      renv\n      reprex\n      rjags\n      rlang\n      rmarkdown\n      rstudioapi\n      rvest\n      sass\n      scales\n      selectr\n      stringi\n      stringr\n      svglite\n      sys\n      systemfonts\n      tibble\n      tidyr\n      tidyselect\n      tidyverse\n      tinytex\n      tzdb\n      utf8\n      uuid\n      vctrs\n      viridisLite\n      vroom\n      webshot\n      withr\n      xfun\n      xml2\n      yaml\n      codetools;\n  };\n    \n  system_packages = builtins.attrValues {\n    inherit (pkgs) \n      R\n      glibcLocales\n      nix;\n  };\n \n  wrapped_pkgs = pkgs.rstudioWrapper.override {\n    packages = [  rpkgs  ];\n  };\n \nin\n\npkgs.mkShell {\n  LOCALE_ARCHIVE = if pkgs.system == \"x86_64-linux\" then  \"${pkgs.glibcLocales}/lib/locale/locale-archive\" else \"\";\n  LANG = \"en_US.UTF-8\";\n   LC_ALL = \"en_US.UTF-8\";\n   LC_TIME = \"en_US.UTF-8\";\n   LC_MONETARY = \"en_US.UTF-8\";\n   LC_PAPER = \"en_US.UTF-8\";\n   LC_MEASUREMENT = \"en_US.UTF-8\";\n\n  buildInputs = [  rpkgs  system_packages  wrapped_pkgs ];\n  \n}\n\n\n\n\n### Successfully generated `default.nix` in /tmp/published-202312-favrot-hierarchical. Keeping `.Rprofile` generated by `rix::rix_init()`###\n\n\nand rebuild and restart the environment (fortunately the build is very fast because it only takes the missing package to be installed):\n\nnix-build\nnix-shell\n\n\n[nix-shell:/tmp/published-202312-favrot-hierarchical]$ quarto render\n\n… and this is a victory!\n\nOutput created: _site/published-202312-favrot-hierarchical.html"
  },
  {
    "objectID": "precommit.html",
    "href": "precommit.html",
    "title": "Pre-commit pour R",
    "section": "",
    "text": "Pre-commit permet de faciliter les tâches annexes au développement de notre code en les externalisant en dehors de notre dépôt. Pre-commit s’assure que notre code est propre avant chaque commit, i.e :\n\nLes fichiers de code ont un style cohérent, et ne contiennent pas d’erreurs de syntaxe simples (par exemple, oubli de crochets).\nDans le cas d’un package, la documentation (fichiers .rd dans le dossier man/) est à jour et sans erreur d’orthographe."
  },
  {
    "objectID": "precommit.html#pourquoi-pre-commit",
    "href": "precommit.html#pourquoi-pre-commit",
    "title": "Pre-commit pour R",
    "section": "",
    "text": "Pre-commit permet de faciliter les tâches annexes au développement de notre code en les externalisant en dehors de notre dépôt. Pre-commit s’assure que notre code est propre avant chaque commit, i.e :\n\nLes fichiers de code ont un style cohérent, et ne contiennent pas d’erreurs de syntaxe simples (par exemple, oubli de crochets).\nDans le cas d’un package, la documentation (fichiers .rd dans le dossier man/) est à jour et sans erreur d’orthographe."
  },
  {
    "objectID": "precommit.html#installation",
    "href": "precommit.html#installation",
    "title": "Pre-commit pour R",
    "section": "Installation",
    "text": "Installation\nL’installation est en deux étapes :\n\nInstallation de l’outil pre-commit écrit en python en utilisant :\n\n\npip install pre-commit\n\n\nInstallation du package R {precommit} en utilisant :\n\n\ninstall.packages(\"precommit\")"
  },
  {
    "objectID": "precommit.html#dans-notre-projet-r",
    "href": "precommit.html#dans-notre-projet-r",
    "title": "Pre-commit pour R",
    "section": "Dans notre projet R",
    "text": "Dans notre projet R\nUne fois pre-commit installé, on peut se rendre dans le répertoire de notre Rprojet versionné avec Git, et exécuter la commande R:\n\nprecommit::use_precommit()\n\nCette commande créer le fichier de configuration .pre-commit-config.yaml, et prépare le répertoire à utiliser pre-commit. Une page web d’authentification GitHub s’ouvre, elle n’est utile que pour mettre à jour automatiquement les versions de hooks que l’on utilise. On peut l’ignorer sans problèmes.\nMais il faut alors penser à les mettre à jour manuellement de temps à autre:\n\nprecommit::autoupdate()"
  },
  {
    "objectID": "precommit.html#configuration-de-pre-commit-pour-notre-projet-r",
    "href": "precommit.html#configuration-de-pre-commit-pour-notre-projet-r",
    "title": "Pre-commit pour R",
    "section": "Configuration de pre-commit pour notre projet R",
    "text": "Configuration de pre-commit pour notre projet R\nLe fichier de configuration par défaut est :\n\n# All available hooks: https://pre-commit.com/hooks.html\n# R specific hooks: https://github.com/lorenzwalthert/precommit\nrepos:\n-   repo: https://github.com/lorenzwalthert/precommit\n    rev: v0.4.3\n    hooks: \n    -   id: style-files\n        args: [--style_pkg=styler, --style_fun=tidyverse_style] \n    -   id: roxygenize #uniquement lorsque le projet est un package\n    -   id: spell-check\n        exclude: &gt;\n          (?x)^(\n          .*\\.[rR]|\n          .*\\.feather|\n          .*\\.jpeg|\n          .*\\.pdf|\n          .*\\.png|\n          .*\\.py|\n          .*\\.RData|\n          .*\\.rds|\n          .*\\.Rds|\n          .*\\.Rproj|\n          .*\\.sh|\n          (.*/|)\\.gitignore|\n          (.*/|)\\.gitlab-ci\\.yml|\n          (.*/|)\\.lintr|\n          (.*/|)\\.pre-commit-.*|\n          (.*/|)\\.Rbuildignore|\n          (.*/|)\\.Renviron|\n          (.*/|)\\.Rprofile|\n          (.*/|)\\.travis\\.yml|\n          (.*/|)appveyor\\.yml|\n          (.*/|)NAMESPACE|\n          (.*/|)renv/settings\\.dcf|\n          (.*/|)renv\\.lock|\n          (.*/|)WORDLIST|\n          \\.github/workflows/.*|\n          data/.*|\n          )$\n    -   id: lintr\n    -   id: readme-rmd-rendered\n    -   id: parsable-R\n    -   id: no-browser-statement\n    -   id: no-debug-statement\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.6.0\n    hooks: \n    -   id: check-added-large-files\n        args: ['--maxkb=200']\n    -   id: end-of-file-fixer\n        exclude: '\\.Rd'\n-   repo: https://github.com/pre-commit-ci/pre-commit-ci-config\n    rev: v1.6.1\n    hooks:\n    # Only required when https://pre-commit.ci is used for config validation\n    -   id: check-pre-commit-ci-config\n-   repo: local\n    hooks:\n    -   id: forbid-to-commit\n        name: Don't commit common R artifacts\n        entry: Cannot commit .Rhistory, .RData, .Rds or .rds.\n        language: fail\n        files: '\\.(Rhistory|RData|Rds|rds)$'\n        # `exclude: &lt;regex&gt;` to allow committing specific files\n\nci:\n    autoupdate_schedule: monthly\n\nCe fichier indique les hooks que l’on veut utiliser en précisant les répertoires Git où l’on peut les trouver.\nUn hook est un programme réalisant un test sur les fichiers que l’on souhaite commit. Celui-ci peut ou non modifier un fichier, mais renvoie un état : skipped, passed, failed… La déclaration de chaque hook selon le répertoire Git où il se trouve se fait en renseignant son id et d’éventuels arguments, le tout en respectant la syntaxe yaml, par exemple :\n\n-   repo: https://github.com/lorenzwalthert/precommit #répertoire 1 des hooks\n    rev: v0.4.3 #version du répertoire 1s\n    hooks: \n    -   id: style-files #nom du hook 1\n        args: [--style_pkg=styler, --style_fun=tidyverse_style]  #arguments du hook 1\n    -   id: lintr #nom du hook 2\n-   repo: https://github.com/pre-commit/pre-commit-hooks #répertoire 2 des hooks\n    rev: v4.6.0\n    hooks: \n    -   id: check-added-large-files\n        args: ['--maxkb=200']\n\nOn peut retrouver les hooks disponibles pour du code R ici."
  },
  {
    "objectID": "precommit.html#hook-roxygenize",
    "href": "precommit.html#hook-roxygenize",
    "title": "Pre-commit pour R",
    "section": "Hook roxygenize",
    "text": "Hook roxygenize\nLe but du hook est de mettre à jour la documentation lorsqu’elle est modifiée dans le code source. Cela passe par l’utilisation de {roxygen2}.\nPar défaut la configuration du hook est la suivante:\n\n-   id: roxygenize\n\nSi le package utilise des dépendances, le hook va générer une erreur car il a besoin de connaitre les dépendances pour mettre à jour la documentation. Le package {precommit} propose une fonction renvoyant le texte à ajouter dans le fichier de configuration si il détecte que les dépendances ne sont pas fournies :\n\nprecommit::snippet_generate('additional-deps-roxygenize')\n\nPar exemple :\n\n\nGenerating snippet using CRAN versions. If you need another source, specify with syntax that `renv::install()` understands (see examples in help file). \n\n    -   id: roxygenize\n        # roxygen requires loading pkg -&gt; add dependencies from DESCRIPTION\n        additional_dependencies:\n        -    rlang\n        -    stringr\n\n• Replace the `id: roxygenize` key in `.pre-commit-config.yaml` with the above code.\nℹ Note that CI services like &lt;pre-commit.ci&gt; have build-time restrictions and installing the above dependencies may exceed those, resulting in a timeout. In addition, system dependencies are not supported for &lt;pre-commit.ci&gt;. See `vignette('ci', package = 'precommit')` for details and solutions.\n\n\nIl faut alors ajouter les dépendances fournies dans le hook roxygenize du fichier de configuration :\n\n-   id: roxygenize\n        # roxygen requires loading pkg -&gt; add dependencies from DESCRIPTION\n        additional_dependencies:\n        -    rlang\n        -    stringr\n\n\n\n\n\n\n\nPour les packages hors du CRAN\n\n\n\nPar défaut si l’on met le nom d’un package le hook suppose qu’il est sur le CRAN. S’il ne l’est pas, il faut donner un format particulier, par exemple :\n\npour GitHub : NomDuDeveloppeur/NomDuPackage (pour un répertoire dont l’url est le suivant : https://github.com/NomDuDeveloppeur/NomDuPackage)\npour BioConductor : bioc::NomDuPackage\npour un URL vers le package au format archive : url::https://sitedupackage.example.com/nomdupackage.zip\n\nPour plus de détails voir ici"
  },
  {
    "objectID": "precommit.html#désactiver-pre-commit",
    "href": "precommit.html#désactiver-pre-commit",
    "title": "Pre-commit pour R",
    "section": "Désactiver pre-commit",
    "text": "Désactiver pre-commit\nPour désactiver pre-commit de son projet R, il suffit d’exécuter la commande suivante qui supprime le fichier .git/hooks/pre-commit :\n\nrm .git/hooks/pre-commit\n\nNB: Cette commande ne supprime pas le fichier de configuration .pre-commit-config.yaml permettant de sauvegarder nos configurations.\nPour ré-activer pre-commit, il suffit d’utiliser la commande suivante dans le répertoire du projet :\n\nprecommit::use_precommit()"
  },
  {
    "objectID": "precommit.html#conseils-dutilisation",
    "href": "precommit.html#conseils-dutilisation",
    "title": "Pre-commit pour R",
    "section": "Conseils d’utilisation",
    "text": "Conseils d’utilisation\nPre-commit peut s’exécuter depuis la fenêtre Git de Rstudio. Cependant le rendu graphique des messages de pre-commit n’est pas très optimal, nous conseillons d’exécuter les commandes git sur le terminal bash de Rstudio.\n\n\n\n\n\n\nNe pas interrompre le processus de pre-commit\n\n\n\nS’il y a d’autres fichiers modifiés mais non ajoutés au commit en cours, pre-commit les met de côté (stash) pendant la durée d’execution des hooks, et les remet dans l’arbre de travail (un-stash) une fois le l’execution terminée. Interrompre avant la fin, empêche pre-commit de les remettre.\nIl est toujours possible d’utiliser git apply sur le fichier de patch se trouvant dans le dossier .cache/pre-commit/ le plus récent."
  },
  {
    "objectID": "quarto_parametre.html",
    "href": "quarto_parametre.html",
    "title": "Documents paramétrés en quarto",
    "section": "",
    "text": "Ci dessous, vous trouverez un modèle de document paramétré en quarto.\n\nInclusion de paramètres personnalisés dans un document quarto\nIl est probable que l’exécution de l’exemple ainsi que son adaptation soit suffisant pour tout comprendre. Cependant, après m’être un peu cassé les dents, quelques points importants.\n\nLa liste des paramètres doit être spécifiée dans l’en tête yaml.\n\n\nparams:\n  correction: true # or false\n\n\nAfin d’interagir avec le code, il me semble qu’il est impératif d’utiliser knitr comme moteur de rendu, et non jupyter, même quand l’on utilise pas de R (notamment, quand tout est en python).\n\n\nengine: knitr\n\n\nAccès aux paramètres dans un code R Pour accéder aux éléments de params dans un code R, il suffit d’y accéder comme dans n’importe quelle liste. Autrement dit, une liste params est créée au rendu, et on peut accéder à l’élément correction avec params$correction (voir l’exemple ci dessous).\nAccès aux paramètres dans un code python Pour accéder aux éléments de params dans un code R, il faut accéder à l’objet R params dans python. Ceci est fait grâce au package reticulate. Dans la pratique, au rendu, un dictionnaire python nommé r.params est créé. On peut accéder à l’élément correction avec r.params[\"correction\"] (voir l’exemple ci dessous).\nAccès aux paramètres dans les options d’un chunk Pour faire appel au paramètre dans les options des chunks, il faut utiliser le préfixe !expr et appeler l’argument comme on le ferait en R. Ceci est vrai pour les chunks R et python. Dans l’exemple ci dessous, on évalue un chunk conditionnellement à la correction en écrivant #| eval:!expr \"params$correction\".\nAccès aux paramètres dans le texte pour des affichages conditionnels Lorsque le paramètre est une condition qui doit gérer l’affichage (typiquement, affiche t’“on la correction ou non ci dessous) il faut utiliser les environnements quarto .content-visible dans lequel on utilisera l’option when-meta=\"params.correction\".\n\n---\ntitle: \"Exemple de document paramétré\"\nformat: pdf\nparams:\ncorrection: true\nengine: knitr # Obligatoire pour interagir avec le code, même si on ne fait que du python\n---\n  \n# Exemple dans du texte\n  \n:::{#exr-densite-loi-normale}\n## 1 point\n    \nSoit $X \\in \\mathbb{R}$ une variable aléatoire de loi $\\mathcal{N}(\\mu, \\sigma^2)$. \nDonner l'expression de $p(x)$, la densité de $X$.\n:::\n\n::: {.content-visible when-meta=\"params.correction\"}\n\n:::{#sol-densite-loi-normale}\nLa densité de $X$ est donnée par:\n$$\np(x)=\\frac{1}{\\sqrt{2\\pi \\sigma^2}}\\text{e}^{-\\frac{1}{2\\sigma^2}(x - \\mu)^2}\\,.\n$$\n:::\n\n:::\n\n# Exemple avec code conditionnel\n\n## Avec du `R`\n\n```{r}\n#| label: chunk-R-parametre\n#| eval: !expr \"params$correction\"\nifelse(params$correction,\n       \"Ce chunk est executé en mode correction\",\n       \"Ce chunk n'est pas executé en mode correction\")\n```\n\n## Avec du python\n\n```{python}\n#| label: exemple-python \n#| echo: fenced\n#| eval: !expr \"params$correction\"\nif r.params[\"correction\"]:\n  print(\"Ce texte s'affiche en mode correction\")\n```\n  \n\n\nCompilation du document\nPour compiler le document (dans R) avec la liste des paramètres voulus, on utilisera la fonction quarto_render du package quarto.\n\n# Pour compiler le document avec toutes les valeurs possibles du paramètres\npurrr::map(c(FALSE, TRUE), function(cor_){\n  # On rajoute les traitements dépendant de l'argument\n  output_name &lt;- ifelse(cor_, \"sujet.pdf\", \"correction.pdf\") \n  quarto::quarto_render(input = \"mon_document.qmd\",  \n                        execute_params = list(correction  = cor_), \n                        output_format = \"pdf\",\n                        output_file = output_name)\n})"
  },
  {
    "objectID": "01_extract_env_data.html",
    "href": "01_extract_env_data.html",
    "title": "Extract environmental data from MODIS",
    "section": "",
    "text": "Extracting environmental data (such as temperature, land cover, and NDVI) from the web can be very challenging. Many platforms are available, such as Copernicus and MODIS.\nThese platforms offer a wide range of products that can be highly heterogeneous for a single variable, meaning they may differ in spatial/temporal resolution and extents. They also come with their own routines, which can be technically complex and resource-intensive.\nThis brief document describes a simple and efficient, though likely not yet perfect, method for extracting certain environmental variables from MODIS.\nTwo approaches are possible:\n\nUse the package MODIStsp in R.\n\nBe aware that the package may have installation issues on Linux, and it is no longer maintained. Additionally, not all products are available. When it does work, it is still very useful for extracting MODIS data within a specific spatio-temporal window.\n\nUse the command line to download the data based on the URL link where the data is stored.# Extracting data with MODIStsp\n\n\nDowload MODIS data with the package MODIStsp\nTo install the package use:\n\nremotes::install_github(\"ropensci/MODIStsp\")\nThe base function of the package is MODIStsp().\n\nMODIStsp(\n  gui = FALSE, # Do not open GUI before processing\n  spatmeth = \"tiles\", # Type of spatial extent\n  out_folder = \"folder/\", # Folder to store the data\n  start_x = 17,end_x = 18, # Geographic rectangles/tiles to download the data\n  start_y = 3,end_y = 4,\n  start_date = \"2000.01.01\", # Beginning of the time series\n  end_date = \"2020.12.01\", # End of the time series,\n  selprod = \"Vegetation_Indexes_Monthly_005dg (M*D13C2)\", # Product to download \n  bandsel = c(\"NDVI\"), # MODIS layers to be processed\n  quality_bandsel = NULL,\n  indexes_bandsel = NULL,\n  user = \"mstp_test\", # put your ID\n  password = \"MSTP_test_01\", # and login\n  verbose = TRUE,\n  parallel = FALSE\n)\nThe argument spatmeth allows you to select the spatial extent of the data to download. It can be defined by a set of tiles that reference rectangles covering the world (specified through the arguments start_x, end_x, start_y, end_y) link. It can also be a bbox or a shapefile contained in a file.\nselprod is the product to select (variable, spatial, and temporal resolution). All products available through MODIStsp can be obtained with the function MODIStsp_get_prodnames().\nYou will need an ID and a login to extract the data. Here we took test codes.\nThe products will be available in the folder/ specified in the function. They provide a .RData file with all the extracted rasters (usually one per time step) or, alternatively, one raster per time step in .tiff (or a similar) format.\n\n\nDowload MODIS data from the command line\nThe package is quite limited in terms of available products (for example, there is no land cover data) and is no longer maintained, so there are several bugs (e.g., during installation).\nA more robust way to extract the data is to use the data access portal link. The key point is to find the right product in the catalog [catalog link].\nAfter finding the product, such as land cover &gt; click on “Access the data” &gt; click on the download icon in the “Data Pool” to directly download the data.\n\nThis redirects you to a page with all the files related to the product (which can be extensive).\nFor land cover data, here is the link https://e4ftl01.cr.usgs.gov/MOTA/MCD12C1.061/.\nThe following steps are summarized for Ubuntu. Detailed instructions for different operating systems can be found here.\nFirst, you will need to create a user profile at https://urs.earthdata.nasa.gov/home.\nNext, create a .netrc file in your home directory.\nThen, write the following lines with your earthdata.nasa ID and password in the terminal.\necho \"machine urs.earthdata.nasa.gov login YOUR_USERNAME password YOUR_PASSWORD\" &gt; ~/.netrc\nchmod 0600 ~/.netrc\nUse wget to download the whole data:\nwget -r -np -nH --cut-dirs=3 --reject \"index.html*\" --no-check-certificate https://e4ftl01.cr.usgs.gov/MOTA/MCD12C1.061/\nHere is an explanation of the argument:\n\n-r: Recursive download.\n-np: No parent, prevents wget from following links to the parent directory.\n-nH: Disables the creation of host-prefixed directories.\n–cut-dirs=3: Removes the first three directory levels from the downloaded file paths.\n–reject “index.html*”: Excludes the index.html files from the download.\n–no-check-certificate: Prevents wget from checking the SSL certificate (useful if there are issues with certificate validation).\n\nIt will download the data in .hdf format files. To download data for only a single year (e.g., 2001), navigate through the file tree by entering:\nwget -r -np -nH --cut-dirs=3 --reject \"index.html*\" --no-check-certificate \nhttps://e4ftl01.cr.usgs.gov/MOTA/MCD12C1.061/2001.01.01/\nFiles will be downloaded to the home directory. To download them to a specific folder, navigate to the desired directory using the cd command, choose the directory of interest, and run the previous command. Alternatively, you can use the -P argument.\nwget -r -np -nH --cut-dirs=3 -P \"file_name\" --reject \"index.html*\" --no-check-certificate https://e4ftl01.cr.usgs.gov/MOTA/MCD12C1.061/2001.01.01/\nThis option should be preferred over the R package MODIStsp because it provides access to more products and does not depend on package maintenance."
  },
  {
    "objectID": "c_jax.html",
    "href": "c_jax.html",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Dans ce tutoriel, qui constitue le suite de Du C++ depuis Python, nous étudions le module jax.extend.ffi dont un tutoriel est donné ici. Plus précisément, nous allons adapter ce dernier pour l’utilisation d’un algorithme naïf d’échantillonneur de Gibbs écrit en C++ depuis JAX.\n\n\n\nTous les fichiers du projet sont disponibles sur ce dépôt Github. Les outils et l’arborescence sont similaires au tutoriel C++ depuis Python.\n\n\n\nNous avons à disposition une mini bibliothèque C++ implémentant une version naïve de l’échantillonneur de Gibbs. Les trois fonctions qu’elle offre sont disponibles dans lib/gibbs_sampler.h :\nvoid initialize(int* image, int rows, int cols, int Q);\nvoid printImage(int* image, int rows, int cols);\nvoid RunGibbsSampler(int* image, int rows, int cols, int Q, float beta, int iter);\nLe fichier gibbs_sampler_cpp.cpp chronomètre cette implémentation de l’échantillonneur de Gibbs pour \\(1000\\) itérations, sur une image de \\(200\\times200\\), pour un modèle de Potts à \\(3\\) classes où \\(\\beta=1.0\\) :\n// Thanks chatgpt for the quick gibbs sampler implementation\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;chrono&gt;\n\n#include \"lib/gibbs_sampler.h\"\n\nusing namespace std;\nusing namespace std::chrono;  // Use the chrono namespace\n\n// Main function\nint main() {\n    int rows = 200;\n    int cols = 200;\n    int Q = 3; // Number of possible labels (states)\n    float beta = 1.0; // Coupling strength\n    int iter = 1000;\n\n    // Allocate memory for the image\n    int* image = new int[rows * cols];\n\n    auto start = high_resolution_clock::now();\n    // Initialize the image with random states\n    initialize(image, rows, cols, Q);\n\n    // cout &lt;&lt; \"Initial image:\" &lt;&lt; endl;\n    // printImage(image, rows, cols);\n\n    RunGibbsSampler(image, rows, cols, Q, beta, iter);\n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast&lt;milliseconds&gt;(stop - start);\n\n    cout &lt;&lt; \"Execution time: \" &lt;&lt; duration.count() &lt;&lt; \" milliseconds\" &lt;&lt; endl;\n\n    // cout &lt;&lt; \"Final image after Gibbs sampling:\" &lt;&lt; endl;\n    // printImage(image, rows, cols);\n\n    // Free allocated memory\n    delete[] image;\n\n    return 0;\n}\nLe fichier ci-dessus est compilé et exécuté avec la commande :\nbazel build main && bazel-bin/main\nL’instruction build main se trouve dans BUILD.bazel (il s’agit d’une simple compilation d’exécutable cc_binary) :\ncc_binary( # no header here, we are not building a library\n    name = \"main\",\n    srcs = [\"gibbs_sampler_cpp.cpp\"],\n    visibility = [\"//visibility:public\"],\n    deps = [\"//lib:gibbs_sampler_lib\"]\n)\nMais on remarque que cette règle de compilation dépend d’une autre règle de compilation qui est celle de la bibliothèque de l’échantillonneur de Gibbs gibbs_sampler_lib. Cette règle, exécutée automatiquement par dépendance, se situe dans lib/BUILD.bazel :\ncc_library(\n    name = \"gibbs_sampler_lib\",\n    srcs = [\"gibbs_sampler.cpp\"],\n    hdrs = [\n        \"gibbs_sampler.h\", # These headers are intended to be included by other libraries or binaries that depend on this library.\n    ],\n    copts = [\"-std=c++17\"],\n    visibility = [\"//visibility:public\"],\n)\nFinalement, l’exécution du programme donne :\nExecution time: 3718 milliseconds\nRetenons cette valeur à laquelle nous allons nous comparer plus tard. Retenons également l’illustration (voir le dépôt git pour le code C++ incluant la sauvegarde de l’image) :\n\n\n\nRésultat de gibbs_sampler_cpp.cpp\n\n\n\n\n\n\n\nComme indiqué dans les deux seuls tuto sur le sujet actuellement disponibles (sur la doc de JAX et sur la doc XLA), il va nous falloir wrapper les fonctions de notre bibliothèque dans l’API des custom call de XLA.\nNous commençons par télécharger l’API en trois fichiers, api.h, c_api.h et ffi.h, que nous plaçons dans lib/xla/ffi/api/. Nous créons ensuite une fonction GibbsSamplerImpl qui va envelopper initialize et RunGibbsSampler disponibles dans gibbs_sampler.h. Ce wrapping s’effectue à l’aide d’objets particuliers : Buffer (représentant les jax.numpy arrays), Datatype, Error, Bind et Attr. Ces objets sont à l’intermédiaire des structures de données de jax.numpy et de C++. Leur utilisation est décrite dans les tuto cités plus hauts. On note de manière intéressante que GibbsSamplerImpl ne prend pas de tableau (jnp.array) en entrée, i.e., pas de Bind.Arg&lt;&gt;() ; les seuls arguments d’entrée sont des attributs nommés, i.e., Bind().Attr&lt;&gt;(). Il y aura cependant un retour qui sera le tableau du résultat de l’échantillonneur, i.e., Bind().Ret&lt;&gt;(). Finalement, la vraie fonction d’intérêt qui pourra être utilisable via le module jax.extend est construite par la macro XLA_FFI_DEFINE_HANDLER_SYMBOL et s’appelera GibbsSampler.\nToutes ces opérations sont écrites dans lib/gibbs_sampler_xla.cpp :\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;numeric&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;functional&gt;\n\n#include \"xla/ffi/api/c_api.h\"\n#include \"xla/ffi/api/ffi.h\"\n\nextern void initialize(int* image, int rows, int cols, int Q);\nextern void RunGibbsSampler(int* image, int rows, int cols, int Q, float beta, int iter);\n\nnamespace ffi = xla::ffi;\n\nffi::Error GibbsSamplerImpl(\n    //ffi::BufferR1&lt;ffi::DataType::S32&gt; in_img,\n    ffi::Result&lt;ffi::BufferR2&lt;ffi::DataType::S32&gt;&gt; img,\n    int rows,\n    int cols,\n    int Q,\n    float beta,\n    int iter\n) {\n    initialize(img-&gt;typed_data(), rows, cols, Q);\n    RunGibbsSampler(img-&gt;typed_data(), rows, cols, Q, beta, iter);\n    return ffi::Error::Success();\n}\n\nXLA_FFI_DEFINE_HANDLER_SYMBOL(\n    GibbsSampler, GibbsSamplerImpl,\n    ffi::Ffi::Bind()\n        // .Arg&lt;ffi::BufferR1&lt;ffi::DataType::S32&gt;&gt;()\n        .Ret&lt;ffi::BufferR2&lt;ffi::DataType::S32&gt;&gt;()\n        .Attr&lt;int&gt;(\"rows\")\n        .Attr&lt;int&gt;(\"cols\")\n        .Attr&lt;int&gt;(\"Q\")\n        .Attr&lt;float&gt;(\"beta\")\n        .Attr&lt;int&gt;(\"iter\")\n);\nAfin d’alléger le code, le wrapping de la bibliothèque gibbs_sampler.h à l’aide de l’API XLA, constitue une bibliothèque intermédiaire dont le header est gibbs_sampler_xla.h. On la compile avec la règle gibbs_sampler_xla_lib définie dans lib/BUILD.bazel :\ncc_library(\n    name = \"gibbs_sampler_xla_lib\",\n    srcs = [\n        \"xla/ffi/api/c_api.h\",\n        \"xla/ffi/api/ffi.h\",\n        \"xla/ffi/api/api.h\",\n        \"gibbs_sampler_xla.cpp\",\n            ], # When deciding whether to put a header into hdrs or srcs, you should ask whether you want consumers of this library to be able to directly include it\n    hdrs = [\n        \"gibbs_sampler_xla.h\",\n    ],\n    includes = [ # need to use include -I option is not available due to sandbox stuff\n            \".\", # adding to srcs or hdrs does not include\n    ],\n    copts = [\"-std=c++17 -rdynamic\"], # -rdynamic to use extern\n    deps = [\"//lib:gibbs_sampler_lib\"],\n    visibility = [\"//visibility:public\"],\n)\nOn note que cette règle nécessite l’exécution de la règle gibbs_sampler_lib.\n\n\n\nComme dans le tuto C++ depuis Python nous allons utiliser pybind et les PyCapsule pour cette partie des opérations. Nous créons alors un module python appelé gibbs_sampler contiendra une fonction elle-même appelée gibbs_sampler. L’appel de cette dernière retournera une PyCapsule contenant la fonction GibbsSampler définie à la fin de la section précédente. Le code effectuant tout cela est dans lib/gibbs_sampler_xla_pybind.cc.\n#include &lt;pybind11/pybind11.h&gt;\n#include \"gibbs_sampler_xla.h\"\n\ntemplate &lt;typename T&gt;\npybind11::capsule EncapsulateFunction(T* fn) {\n  return pybind11::capsule(reinterpret_cast&lt;void*&gt;(fn));\n}\n\nPYBIND11_MODULE(gibbs_sampler, m) {   // please match the pybind_extension target name\n  m.def(\"gibbs_sampler\", []() { return EncapsulateFunction(GibbsSampler); });\n}\nLe code se compile en un module python avec la règle gibbs_sampler définie dans lib/BUILD.bazel :\npybind_extension( # must be in two steps (first cc_library then pybind_extension)\n    name = \"gibbs_sampler\", # must match the pybind module name\n    srcs = [\"gibbs_sampler_xla_pybind.cc\"],\n    deps = [\"//lib:gibbs_sampler_xla_lib\"],\n    copts = [\"-std=c++17 -rdynamic\"]\n)\nOn note la dépendance sur la règle gibbs_sampler_xla_lib.\nFinalement le module Python peut se compiler avec la simple commande\nbazel build //lib:gibbs_sampler\n\n\n\nNous sommes enfin en mesure d’utiliser la fonction C++ depuis JAX !\nDans le fichier gibbs_sampler_c_from_JAX.py :\n\nNous enregistrons notre appel FFI (nom, PyCapsule, platform) :\n\njex.ffi.register_ffi_target(\"gibbs_sampler\", gibbs_sampler_lib.gibbs_sampler(), platform=\"cpu\")\n\nNous définissons une fonction Python gibbs_sampler_cpp qui effectue l’appel à GibbsSampler, la fonction cachée dans la PyCapsule, à l’aide de jax.ffi.ffi_call. On note que cet appel est maintenant plutôt simple. Il faut préciser les dimensions et le type du résultat retourné avec un object jax.ShapeDtypeStruct, il ne nous faut pas préciser d’argument en entrée car nous n’avons que des attributs qui sont passés en keyword argument.\nNous instruisons l’appel avec les mêmes paramètres qu’auparavant et le chronométrons :\n\nrows = 200\ncols = 200\nQ = 3\nbeta = 1\nn_iter = 1000\n\nstart = time.time()\nres = gibbs_sampler_cpp(rows, cols, Q, beta, n_iter)\nend = time.time()\n\nprint(f\"Time: {end - start} seconds\")\nL’exécution de ce script Python donne :\nTime: 3.9689433574676514 seconds\nCe qui est un temps très légèrement supérieur à l’appel directement depuis C++ à la même fonction avec les mêmes paramètres. Nous obtenons donc le résultat espéré et terme de temps, ainsi qu’en illustration :\n\n\n\nRésultat de gibbs_sampler_c_from_JAX.py\n\n\n\n\n\n\nLa bibliothèque JAX de Python offre la fonctionnalité clé de compilation à la volée (Just In Time compilation) qui permet une compilation du code Python à la première exécution pour des exécutions ultérieures bien plus rapides, en général.\n\n\nLa bibliothèque mrfx offre une implémentation en pur JAX de l’échantillonneur de Gibbs et de l’échantillonneur de Gibbs chromatique. Nous pouvons obtenir un chronométrage de l’échantillonneur de Gibbs grâce au code du fichier gibbs_sampler_JAX_cpu.py :\nimport os\nos.environ[\"JAX_PLATFORMS\"] = \"cpu\"\nimport time\n\nimport jax\n\nkey = jax.random.PRNGKey(0)\n\nfrom mrfx.models import Potts\nfrom mrfx.samplers import GibbsSampler\nfrom mrfx.experiments import time_complete_sampling\n\nrows = 200\ncols = 200\nQ = 3\nbeta = 1\nn_iter = 1000\n\nkey, subkey = jax.random.split(key, 2)\ntimes, n_iterations = time_complete_sampling(\n    GibbsSampler,\n    Potts,\n    subkey,\n    [Q],\n    [(rows, cols)],\n    5,\n    kwargs_sampler={\"eps\": 0.01, \"max_iter\":n_iter, \"cv_type\":\"iter_only\"},\n    kwargs_model={\"beta\":1.}\n)\nprint(\"JAX on CPU\", times)\nOn note un temps de compilation et d’exécution affiché de \\(7.7714\\) secondes et un temps d’exécution seule de \\(7.3613\\).\n\n\n\nLe fichier gibbs_sampler_JAX_gpu.py permet d’excécuter le code précédent sur GPU. En revanche, il apparaît que l’algorithme est environ 10 fois plus lent à la compilation et à l’exécution. C’est probablement dû à l’aspect hautement itératif de l’algorithme étudié qui s’adapte mal à une architecture GPU…\n\n\n\n\nNous avons avec succès appelé du code C++ depuis JAX. Nous pouvons conclure que pour cette algorithme d’échantillonnage de Gibbs hautement itératif, la compilation à la volée de JAX ne surpasse pas un appel à du code C++. Le gain à l’utilisation de jax.extend.ffi est ici très important."
  },
  {
    "objectID": "c_jax.html#objectifs",
    "href": "c_jax.html#objectifs",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Dans ce tutoriel, qui constitue le suite de Du C++ depuis Python, nous étudions le module jax.extend.ffi dont un tutoriel est donné ici. Plus précisément, nous allons adapter ce dernier pour l’utilisation d’un algorithme naïf d’échantillonneur de Gibbs écrit en C++ depuis JAX."
  },
  {
    "objectID": "c_jax.html#le-projet",
    "href": "c_jax.html#le-projet",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Tous les fichiers du projet sont disponibles sur ce dépôt Github. Les outils et l’arborescence sont similaires au tutoriel C++ depuis Python."
  },
  {
    "objectID": "c_jax.html#code-c",
    "href": "c_jax.html#code-c",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Nous avons à disposition une mini bibliothèque C++ implémentant une version naïve de l’échantillonneur de Gibbs. Les trois fonctions qu’elle offre sont disponibles dans lib/gibbs_sampler.h :\nvoid initialize(int* image, int rows, int cols, int Q);\nvoid printImage(int* image, int rows, int cols);\nvoid RunGibbsSampler(int* image, int rows, int cols, int Q, float beta, int iter);\nLe fichier gibbs_sampler_cpp.cpp chronomètre cette implémentation de l’échantillonneur de Gibbs pour \\(1000\\) itérations, sur une image de \\(200\\times200\\), pour un modèle de Potts à \\(3\\) classes où \\(\\beta=1.0\\) :\n// Thanks chatgpt for the quick gibbs sampler implementation\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;ctime&gt;\n#include &lt;chrono&gt;\n\n#include \"lib/gibbs_sampler.h\"\n\nusing namespace std;\nusing namespace std::chrono;  // Use the chrono namespace\n\n// Main function\nint main() {\n    int rows = 200;\n    int cols = 200;\n    int Q = 3; // Number of possible labels (states)\n    float beta = 1.0; // Coupling strength\n    int iter = 1000;\n\n    // Allocate memory for the image\n    int* image = new int[rows * cols];\n\n    auto start = high_resolution_clock::now();\n    // Initialize the image with random states\n    initialize(image, rows, cols, Q);\n\n    // cout &lt;&lt; \"Initial image:\" &lt;&lt; endl;\n    // printImage(image, rows, cols);\n\n    RunGibbsSampler(image, rows, cols, Q, beta, iter);\n    auto stop = high_resolution_clock::now();\n    auto duration = duration_cast&lt;milliseconds&gt;(stop - start);\n\n    cout &lt;&lt; \"Execution time: \" &lt;&lt; duration.count() &lt;&lt; \" milliseconds\" &lt;&lt; endl;\n\n    // cout &lt;&lt; \"Final image after Gibbs sampling:\" &lt;&lt; endl;\n    // printImage(image, rows, cols);\n\n    // Free allocated memory\n    delete[] image;\n\n    return 0;\n}\nLe fichier ci-dessus est compilé et exécuté avec la commande :\nbazel build main && bazel-bin/main\nL’instruction build main se trouve dans BUILD.bazel (il s’agit d’une simple compilation d’exécutable cc_binary) :\ncc_binary( # no header here, we are not building a library\n    name = \"main\",\n    srcs = [\"gibbs_sampler_cpp.cpp\"],\n    visibility = [\"//visibility:public\"],\n    deps = [\"//lib:gibbs_sampler_lib\"]\n)\nMais on remarque que cette règle de compilation dépend d’une autre règle de compilation qui est celle de la bibliothèque de l’échantillonneur de Gibbs gibbs_sampler_lib. Cette règle, exécutée automatiquement par dépendance, se situe dans lib/BUILD.bazel :\ncc_library(\n    name = \"gibbs_sampler_lib\",\n    srcs = [\"gibbs_sampler.cpp\"],\n    hdrs = [\n        \"gibbs_sampler.h\", # These headers are intended to be included by other libraries or binaries that depend on this library.\n    ],\n    copts = [\"-std=c++17\"],\n    visibility = [\"//visibility:public\"],\n)\nFinalement, l’exécution du programme donne :\nExecution time: 3718 milliseconds\nRetenons cette valeur à laquelle nous allons nous comparer plus tard. Retenons également l’illustration (voir le dépôt git pour le code C++ incluant la sauvegarde de l’image) :\n\n\n\nRésultat de gibbs_sampler_cpp.cpp"
  },
  {
    "objectID": "c_jax.html#c-depuis-jax",
    "href": "c_jax.html#c-depuis-jax",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Comme indiqué dans les deux seuls tuto sur le sujet actuellement disponibles (sur la doc de JAX et sur la doc XLA), il va nous falloir wrapper les fonctions de notre bibliothèque dans l’API des custom call de XLA.\nNous commençons par télécharger l’API en trois fichiers, api.h, c_api.h et ffi.h, que nous plaçons dans lib/xla/ffi/api/. Nous créons ensuite une fonction GibbsSamplerImpl qui va envelopper initialize et RunGibbsSampler disponibles dans gibbs_sampler.h. Ce wrapping s’effectue à l’aide d’objets particuliers : Buffer (représentant les jax.numpy arrays), Datatype, Error, Bind et Attr. Ces objets sont à l’intermédiaire des structures de données de jax.numpy et de C++. Leur utilisation est décrite dans les tuto cités plus hauts. On note de manière intéressante que GibbsSamplerImpl ne prend pas de tableau (jnp.array) en entrée, i.e., pas de Bind.Arg&lt;&gt;() ; les seuls arguments d’entrée sont des attributs nommés, i.e., Bind().Attr&lt;&gt;(). Il y aura cependant un retour qui sera le tableau du résultat de l’échantillonneur, i.e., Bind().Ret&lt;&gt;(). Finalement, la vraie fonction d’intérêt qui pourra être utilisable via le module jax.extend est construite par la macro XLA_FFI_DEFINE_HANDLER_SYMBOL et s’appelera GibbsSampler.\nToutes ces opérations sont écrites dans lib/gibbs_sampler_xla.cpp :\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;numeric&gt;\n#include &lt;type_traits&gt;\n#include &lt;utility&gt;\n#include &lt;functional&gt;\n\n#include \"xla/ffi/api/c_api.h\"\n#include \"xla/ffi/api/ffi.h\"\n\nextern void initialize(int* image, int rows, int cols, int Q);\nextern void RunGibbsSampler(int* image, int rows, int cols, int Q, float beta, int iter);\n\nnamespace ffi = xla::ffi;\n\nffi::Error GibbsSamplerImpl(\n    //ffi::BufferR1&lt;ffi::DataType::S32&gt; in_img,\n    ffi::Result&lt;ffi::BufferR2&lt;ffi::DataType::S32&gt;&gt; img,\n    int rows,\n    int cols,\n    int Q,\n    float beta,\n    int iter\n) {\n    initialize(img-&gt;typed_data(), rows, cols, Q);\n    RunGibbsSampler(img-&gt;typed_data(), rows, cols, Q, beta, iter);\n    return ffi::Error::Success();\n}\n\nXLA_FFI_DEFINE_HANDLER_SYMBOL(\n    GibbsSampler, GibbsSamplerImpl,\n    ffi::Ffi::Bind()\n        // .Arg&lt;ffi::BufferR1&lt;ffi::DataType::S32&gt;&gt;()\n        .Ret&lt;ffi::BufferR2&lt;ffi::DataType::S32&gt;&gt;()\n        .Attr&lt;int&gt;(\"rows\")\n        .Attr&lt;int&gt;(\"cols\")\n        .Attr&lt;int&gt;(\"Q\")\n        .Attr&lt;float&gt;(\"beta\")\n        .Attr&lt;int&gt;(\"iter\")\n);\nAfin d’alléger le code, le wrapping de la bibliothèque gibbs_sampler.h à l’aide de l’API XLA, constitue une bibliothèque intermédiaire dont le header est gibbs_sampler_xla.h. On la compile avec la règle gibbs_sampler_xla_lib définie dans lib/BUILD.bazel :\ncc_library(\n    name = \"gibbs_sampler_xla_lib\",\n    srcs = [\n        \"xla/ffi/api/c_api.h\",\n        \"xla/ffi/api/ffi.h\",\n        \"xla/ffi/api/api.h\",\n        \"gibbs_sampler_xla.cpp\",\n            ], # When deciding whether to put a header into hdrs or srcs, you should ask whether you want consumers of this library to be able to directly include it\n    hdrs = [\n        \"gibbs_sampler_xla.h\",\n    ],\n    includes = [ # need to use include -I option is not available due to sandbox stuff\n            \".\", # adding to srcs or hdrs does not include\n    ],\n    copts = [\"-std=c++17 -rdynamic\"], # -rdynamic to use extern\n    deps = [\"//lib:gibbs_sampler_lib\"],\n    visibility = [\"//visibility:public\"],\n)\nOn note que cette règle nécessite l’exécution de la règle gibbs_sampler_lib.\n\n\n\nComme dans le tuto C++ depuis Python nous allons utiliser pybind et les PyCapsule pour cette partie des opérations. Nous créons alors un module python appelé gibbs_sampler contiendra une fonction elle-même appelée gibbs_sampler. L’appel de cette dernière retournera une PyCapsule contenant la fonction GibbsSampler définie à la fin de la section précédente. Le code effectuant tout cela est dans lib/gibbs_sampler_xla_pybind.cc.\n#include &lt;pybind11/pybind11.h&gt;\n#include \"gibbs_sampler_xla.h\"\n\ntemplate &lt;typename T&gt;\npybind11::capsule EncapsulateFunction(T* fn) {\n  return pybind11::capsule(reinterpret_cast&lt;void*&gt;(fn));\n}\n\nPYBIND11_MODULE(gibbs_sampler, m) {   // please match the pybind_extension target name\n  m.def(\"gibbs_sampler\", []() { return EncapsulateFunction(GibbsSampler); });\n}\nLe code se compile en un module python avec la règle gibbs_sampler définie dans lib/BUILD.bazel :\npybind_extension( # must be in two steps (first cc_library then pybind_extension)\n    name = \"gibbs_sampler\", # must match the pybind module name\n    srcs = [\"gibbs_sampler_xla_pybind.cc\"],\n    deps = [\"//lib:gibbs_sampler_xla_lib\"],\n    copts = [\"-std=c++17 -rdynamic\"]\n)\nOn note la dépendance sur la règle gibbs_sampler_xla_lib.\nFinalement le module Python peut se compiler avec la simple commande\nbazel build //lib:gibbs_sampler\n\n\n\nNous sommes enfin en mesure d’utiliser la fonction C++ depuis JAX !\nDans le fichier gibbs_sampler_c_from_JAX.py :\n\nNous enregistrons notre appel FFI (nom, PyCapsule, platform) :\n\njex.ffi.register_ffi_target(\"gibbs_sampler\", gibbs_sampler_lib.gibbs_sampler(), platform=\"cpu\")\n\nNous définissons une fonction Python gibbs_sampler_cpp qui effectue l’appel à GibbsSampler, la fonction cachée dans la PyCapsule, à l’aide de jax.ffi.ffi_call. On note que cet appel est maintenant plutôt simple. Il faut préciser les dimensions et le type du résultat retourné avec un object jax.ShapeDtypeStruct, il ne nous faut pas préciser d’argument en entrée car nous n’avons que des attributs qui sont passés en keyword argument.\nNous instruisons l’appel avec les mêmes paramètres qu’auparavant et le chronométrons :\n\nrows = 200\ncols = 200\nQ = 3\nbeta = 1\nn_iter = 1000\n\nstart = time.time()\nres = gibbs_sampler_cpp(rows, cols, Q, beta, n_iter)\nend = time.time()\n\nprint(f\"Time: {end - start} seconds\")\nL’exécution de ce script Python donne :\nTime: 3.9689433574676514 seconds\nCe qui est un temps très légèrement supérieur à l’appel directement depuis C++ à la même fonction avec les mêmes paramètres. Nous obtenons donc le résultat espéré et terme de temps, ainsi qu’en illustration :\n\n\n\nRésultat de gibbs_sampler_c_from_JAX.py"
  },
  {
    "objectID": "c_jax.html#comparaison-avec-python-jax",
    "href": "c_jax.html#comparaison-avec-python-jax",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "La bibliothèque JAX de Python offre la fonctionnalité clé de compilation à la volée (Just In Time compilation) qui permet une compilation du code Python à la première exécution pour des exécutions ultérieures bien plus rapides, en général.\n\n\nLa bibliothèque mrfx offre une implémentation en pur JAX de l’échantillonneur de Gibbs et de l’échantillonneur de Gibbs chromatique. Nous pouvons obtenir un chronométrage de l’échantillonneur de Gibbs grâce au code du fichier gibbs_sampler_JAX_cpu.py :\nimport os\nos.environ[\"JAX_PLATFORMS\"] = \"cpu\"\nimport time\n\nimport jax\n\nkey = jax.random.PRNGKey(0)\n\nfrom mrfx.models import Potts\nfrom mrfx.samplers import GibbsSampler\nfrom mrfx.experiments import time_complete_sampling\n\nrows = 200\ncols = 200\nQ = 3\nbeta = 1\nn_iter = 1000\n\nkey, subkey = jax.random.split(key, 2)\ntimes, n_iterations = time_complete_sampling(\n    GibbsSampler,\n    Potts,\n    subkey,\n    [Q],\n    [(rows, cols)],\n    5,\n    kwargs_sampler={\"eps\": 0.01, \"max_iter\":n_iter, \"cv_type\":\"iter_only\"},\n    kwargs_model={\"beta\":1.}\n)\nprint(\"JAX on CPU\", times)\nOn note un temps de compilation et d’exécution affiché de \\(7.7714\\) secondes et un temps d’exécution seule de \\(7.3613\\).\n\n\n\nLe fichier gibbs_sampler_JAX_gpu.py permet d’excécuter le code précédent sur GPU. En revanche, il apparaît que l’algorithme est environ 10 fois plus lent à la compilation et à l’exécution. C’est probablement dû à l’aspect hautement itératif de l’algorithme étudié qui s’adapte mal à une architecture GPU…"
  },
  {
    "objectID": "c_jax.html#conclusion",
    "href": "c_jax.html#conclusion",
    "title": "Du C++ depuis JAX",
    "section": "",
    "text": "Nous avons avec succès appelé du code C++ depuis JAX. Nous pouvons conclure que pour cette algorithme d’échantillonnage de Gibbs hautement itératif, la compilation à la volée de JAX ne surpasse pas un appel à du code C++. Le gain à l’utilisation de jax.extend.ffi est ici très important."
  },
  {
    "objectID": "shiny-deployment.html",
    "href": "shiny-deployment.html",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "besoin de déploiement d’appli shiny pour utilisation sans programmation\nsolution proposée par shinyapps.io: limitation à 25h/mois et 5 applications concurrentes pour la version gratuite, et 1Gb de RAM. Les étapes du déploiement sont illustrées dans la Section 1.6\nsolution proposée par Posit (anciennement par Shiny Server Pro): PositConnect: payant (cher)\nintérêt d’avoir une solution institutionnelle\n\n\n\n\n\n\nOutil\nInstitution\nRéférences\n\n\n\n\nplmshift\nCNRS\n\n\n\nSK8\nINRAE\nMaigné et al. (2023)\n\n\nShiny-K8s\nInstitut Pasteur\nBrancotte and Chapeaublanc (2024)\n\n\n\n\n\n\nCes trois outils sont dédiés au déploiement d’applications shiny via Kubernetes (aka K8s). Le développeur de l’application shiny doit fournir un dépôt git contenant le code source de l’application et spécifier les dépendances (via un fichier csv dédié pour shiny-K8s et plmshift, ou automatiquement via renv pour SK8).\n\n\n\nEtapes pour le déploiement d’une application shiny via SK8 (INRAE)\n\n\n\n\n\nC’est ici que les trois solutions se différencient:\n\nPour plmshift, on demande également au développeur de l’application de configurer et d’administrer lui-même son instance ShinyServer, via l’interface d’OpenShift. Ces étapes sont documentées ici\n\nIdem pour Shiny-K8s, avec (semble-t-il) moins de compétences techniques requises. Ces étapes sont documentées ici\nSK8 propose une interface simplifiée pour la configuration du serveur shiny, qui permet au développeur de l’application shiny spécifier directement les paramètres (RAM, CPU) sans avoir besoin de compétences en déploiement.\n\n\n\n\nplmshift, SK8 et Shiny-K8s sont respectivement accessibles seulement pour des projets développés par le CNRS, INRAE et l’Institut Pasteur.\nAujourd’hui, SK8 semble la solution la plus simple d’utilisation pour le développeur shiny. Les paramètres de configuration sont relativement proches de ceux demandés pour le dépoiements sur shinyapps.io (voir Section 1.6). Afin de rendre ce type d’outil accessible à d’autres institutions qu’’INRAE, on peut envisager soit l’ouverture d’un des services existants à ces institutions, soit la mise à disposition de ce type de service directement par chaque institution. Les deux solutions nécessitent des ressources matérielles et humaines; la première solution peut permettre des économies d’échelle mais peut poser des questions sur le partage des données de recherche entre institutions.\n\n\n\n\ncode d’une application démo pour déploiement avec shiny-K8s\nprésentation d’Elise Maigné aux rencontres R 2024\n\n\n\n\n\n\n\nVue d’ensemble\n\n\n\n\n\nConfiguration: paramètres de base\n\n\n\n\n\nConfiguration: paramètres avancés\n\n\n\n\n\nStatistiques d’utilisation\n\n\n\n\n\nLa procédure de déploiement consiste à:\n\nPréparer le code de l’application shiny dans un repository git selon un template fourni par PLMShift;\nCréer une instance ShinyR à partir de l’interface OpenShift en:\n\nRenseignant l’adresse du repository git;\nConfigurant des secrets pour l’authentification (communication GitHub - OpenShift);\nConfigurant des variables d’environnement pour l’application (nom de l’application, ressources nécessaires etc.);\nConfigurant des paramètres de déploiement (nombre de réplicas, stratégie de déploiement etc.);\nConfigurant des paramètres de monitoring (alertes, logs etc.).\n\nTester l’application déployée.\n\nLes étapes 2 et 3 sont réalisées par le développeur de l’application. L’interface OpenShift est complexe et nécessite des compétences techniques. Il serait intéressant de simplifier cette interface pour la rendre plus accessible aux utilisateurs non-experts. Par exemple, en proposant une interface graphique pour la configuration des secrets, des variables d’environnement, des paramètres de déploiement et de monitoring."
  },
  {
    "objectID": "shiny-deployment.html#outils-institutionnels-existants",
    "href": "shiny-deployment.html#outils-institutionnels-existants",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Outil\nInstitution\nRéférences\n\n\n\n\nplmshift\nCNRS\n\n\n\nSK8\nINRAE\nMaigné et al. (2023)\n\n\nShiny-K8s\nInstitut Pasteur\nBrancotte and Chapeaublanc (2024)"
  },
  {
    "objectID": "shiny-deployment.html#préparation-de-lappli-au-déploiement",
    "href": "shiny-deployment.html#préparation-de-lappli-au-déploiement",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Ces trois outils sont dédiés au déploiement d’applications shiny via Kubernetes (aka K8s). Le développeur de l’application shiny doit fournir un dépôt git contenant le code source de l’application et spécifier les dépendances (via un fichier csv dédié pour shiny-K8s et plmshift, ou automatiquement via renv pour SK8).\n\n\n\nEtapes pour le déploiement d’une application shiny via SK8 (INRAE)"
  },
  {
    "objectID": "shiny-deployment.html#configuration-du-serveur-shiny",
    "href": "shiny-deployment.html#configuration-du-serveur-shiny",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "C’est ici que les trois solutions se différencient:\n\nPour plmshift, on demande également au développeur de l’application de configurer et d’administrer lui-même son instance ShinyServer, via l’interface d’OpenShift. Ces étapes sont documentées ici\n\nIdem pour Shiny-K8s, avec (semble-t-il) moins de compétences techniques requises. Ces étapes sont documentées ici\nSK8 propose une interface simplifiée pour la configuration du serveur shiny, qui permet au développeur de l’application shiny spécifier directement les paramètres (RAM, CPU) sans avoir besoin de compétences en déploiement."
  },
  {
    "objectID": "shiny-deployment.html#accessibilité",
    "href": "shiny-deployment.html#accessibilité",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "plmshift, SK8 et Shiny-K8s sont respectivement accessibles seulement pour des projets développés par le CNRS, INRAE et l’Institut Pasteur.\nAujourd’hui, SK8 semble la solution la plus simple d’utilisation pour le développeur shiny. Les paramètres de configuration sont relativement proches de ceux demandés pour le dépoiements sur shinyapps.io (voir Section 1.6). Afin de rendre ce type d’outil accessible à d’autres institutions qu’’INRAE, on peut envisager soit l’ouverture d’un des services existants à ces institutions, soit la mise à disposition de ce type de service directement par chaque institution. Les deux solutions nécessitent des ressources matérielles et humaines; la première solution peut permettre des économies d’échelle mais peut poser des questions sur le partage des données de recherche entre institutions."
  },
  {
    "objectID": "shiny-deployment.html#autres-ressources",
    "href": "shiny-deployment.html#autres-ressources",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "code d’une application démo pour déploiement avec shiny-K8s\nprésentation d’Elise Maigné aux rencontres R 2024"
  },
  {
    "objectID": "shiny-deployment.html#sec-shinyapps.io",
    "href": "shiny-deployment.html#sec-shinyapps.io",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Vue d’ensemble\n\n\n\n\n\nConfiguration: paramètres de base\n\n\n\n\n\nConfiguration: paramètres avancés\n\n\n\n\n\nStatistiques d’utilisation"
  },
  {
    "objectID": "shiny-deployment.html#idées-damelioration-de-la-solution-plmshift",
    "href": "shiny-deployment.html#idées-damelioration-de-la-solution-plmshift",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "La procédure de déploiement consiste à:\n\nPréparer le code de l’application shiny dans un repository git selon un template fourni par PLMShift;\nCréer une instance ShinyR à partir de l’interface OpenShift en:\n\nRenseignant l’adresse du repository git;\nConfigurant des secrets pour l’authentification (communication GitHub - OpenShift);\nConfigurant des variables d’environnement pour l’application (nom de l’application, ressources nécessaires etc.);\nConfigurant des paramètres de déploiement (nombre de réplicas, stratégie de déploiement etc.);\nConfigurant des paramètres de monitoring (alertes, logs etc.).\n\nTester l’application déployée.\n\nLes étapes 2 et 3 sont réalisées par le développeur de l’application. L’interface OpenShift est complexe et nécessite des compétences techniques. Il serait intéressant de simplifier cette interface pour la rendre plus accessible aux utilisateurs non-experts. Par exemple, en proposant une interface graphique pour la configuration des secrets, des variables d’environnement, des paramètres de déploiement et de monitoring."
  }
]