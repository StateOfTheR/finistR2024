[
  {
    "objectID": "Bipartite_GNN.html",
    "href": "Bipartite_GNN.html",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "",
    "text": "library(reticulate)\n\nThe notebook shows a classical use of the package pytorch_numeric which develops Graph Neural Networks based on the logics of pytorch.\nHere we show a basic graph with the library networkx.\nWe use the dataset KarateClub() which is organized as the typical object used by pytorch_geometric: it is a list of graphs where each graph must have an object x, that represents the features of the nodes, and an object edge_index, a 2-row tensor which defines the links between the nodes (plus other possible information about the graph).\n\nimport torch\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(G, color):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    nx.draw_networkx(G, pos=nx.spring_layout(G, seed=42), with_labels=False,\n                     node_color=color, cmap=\"Set2\")\n    plt.show()\n\n\ndef visualize_embedding(h, color, epoch=None, loss=None):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    h = h.detach().cpu().numpy()\n    plt.scatter(h[:, 0], h[:, 1], s=140, c=color, cmap=\"Set2\")\n    if epoch is not None and loss is not None:\n        plt.xlabel(f'Epoch: {epoch}, Loss: {loss.item():.4f}', fontsize=16)\n    plt.show()\n\n\nfrom torch_geometric.datasets import KarateClub\n\ndataset = KarateClub()\nprint(f'Dataset: {dataset}:')\n\nDataset: KarateClub():\n\nprint(f'Number of graphs: {len(dataset)}')\n\nNumber of graphs: 1\n\nprint(f'Number of features: {dataset.num_features}')\n\nNumber of features: 34\n\nprint(f'Number of classes: {dataset.num_classes}')\n\nNumber of classes: 4\n\ndata = dataset[0]  # Get the first graph object.\n\nprint(data)\n\nData(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n\n# Gather some statistics about the graph.\nprint(f'Number of nodes: {data.num_nodes}')\n\nNumber of nodes: 34\n\nprint(f'Number of edges: {data.num_edges}')\n\nNumber of edges: 156\n\nprint(f'Average node degree: {data.num_edges / data.num_nodes:.2f}')\n\nAverage node degree: 4.59\n\nprint(f'Number of training nodes: {data.train_mask.sum()}')\n\nNumber of training nodes: 4\n\nprint(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}')\n\nTraining node label rate: 0.12\n\nprint(f'Has isolated nodes: {data.has_isolated_nodes()}')\n\nHas isolated nodes: False\n\nprint(f'Has self-loops: {data.has_self_loops()}')\n\nHas self-loops: False\n\nprint(f'Is undirected: {data.is_undirected()}')\n\nIs undirected: True\n\nedge_index = data.edge_index # the objet to give to torch_geometric, along with the features\nprint(edge_index)\n\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n\nfrom torch_geometric.utils import to_networkx\n\nG = to_networkx(data, to_undirected=True)\nvisualize_graph(G, color=data.y)"
  },
  {
    "objectID": "Bipartite_GNN.html#graph-class",
    "href": "Bipartite_GNN.html#graph-class",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "",
    "text": "library(reticulate)\n\nThe notebook shows a classical use of the package pytorch_numeric which develops Graph Neural Networks based on the logics of pytorch.\nHere we show a basic graph with the library networkx.\nWe use the dataset KarateClub() which is organized as the typical object used by pytorch_geometric: it is a list of graphs where each graph must have an object x, that represents the features of the nodes, and an object edge_index, a 2-row tensor which defines the links between the nodes (plus other possible information about the graph).\n\nimport torch\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize_graph(G, color):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    nx.draw_networkx(G, pos=nx.spring_layout(G, seed=42), with_labels=False,\n                     node_color=color, cmap=\"Set2\")\n    plt.show()\n\n\ndef visualize_embedding(h, color, epoch=None, loss=None):\n    plt.figure(figsize=(7,7))\n    plt.xticks([])\n    plt.yticks([])\n    h = h.detach().cpu().numpy()\n    plt.scatter(h[:, 0], h[:, 1], s=140, c=color, cmap=\"Set2\")\n    if epoch is not None and loss is not None:\n        plt.xlabel(f'Epoch: {epoch}, Loss: {loss.item():.4f}', fontsize=16)\n    plt.show()\n\n\nfrom torch_geometric.datasets import KarateClub\n\ndataset = KarateClub()\nprint(f'Dataset: {dataset}:')\n\nDataset: KarateClub():\n\nprint(f'Number of graphs: {len(dataset)}')\n\nNumber of graphs: 1\n\nprint(f'Number of features: {dataset.num_features}')\n\nNumber of features: 34\n\nprint(f'Number of classes: {dataset.num_classes}')\n\nNumber of classes: 4\n\ndata = dataset[0]  # Get the first graph object.\n\nprint(data)\n\nData(x=[34, 34], edge_index=[2, 156], y=[34], train_mask=[34])\n\n# Gather some statistics about the graph.\nprint(f'Number of nodes: {data.num_nodes}')\n\nNumber of nodes: 34\n\nprint(f'Number of edges: {data.num_edges}')\n\nNumber of edges: 156\n\nprint(f'Average node degree: {data.num_edges / data.num_nodes:.2f}')\n\nAverage node degree: 4.59\n\nprint(f'Number of training nodes: {data.train_mask.sum()}')\n\nNumber of training nodes: 4\n\nprint(f'Training node label rate: {int(data.train_mask.sum()) / data.num_nodes:.2f}')\n\nTraining node label rate: 0.12\n\nprint(f'Has isolated nodes: {data.has_isolated_nodes()}')\n\nHas isolated nodes: False\n\nprint(f'Has self-loops: {data.has_self_loops()}')\n\nHas self-loops: False\n\nprint(f'Is undirected: {data.is_undirected()}')\n\nIs undirected: True\n\nedge_index = data.edge_index # the objet to give to torch_geometric, along with the features\nprint(edge_index)\n\ntensor([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,\n          1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,\n          3,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,\n          7,  7,  8,  8,  8,  8,  8,  9,  9, 10, 10, 10, 11, 12, 12, 13, 13, 13,\n         13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 20, 20, 21,\n         21, 22, 22, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 27, 27,\n         27, 27, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31, 31,\n         31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33,\n         33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33],\n        [ 1,  2,  3,  4,  5,  6,  7,  8, 10, 11, 12, 13, 17, 19, 21, 31,  0,  2,\n          3,  7, 13, 17, 19, 21, 30,  0,  1,  3,  7,  8,  9, 13, 27, 28, 32,  0,\n          1,  2,  7, 12, 13,  0,  6, 10,  0,  6, 10, 16,  0,  4,  5, 16,  0,  1,\n          2,  3,  0,  2, 30, 32, 33,  2, 33,  0,  4,  5,  0,  0,  3,  0,  1,  2,\n          3, 33, 32, 33, 32, 33,  5,  6,  0,  1, 32, 33,  0,  1, 33, 32, 33,  0,\n          1, 32, 33, 25, 27, 29, 32, 33, 25, 27, 31, 23, 24, 31, 29, 33,  2, 23,\n         24, 33,  2, 31, 33, 23, 26, 32, 33,  1,  8, 32, 33,  0, 24, 25, 28, 32,\n         33,  2,  8, 14, 15, 18, 20, 22, 23, 29, 30, 31, 33,  8,  9, 13, 14, 15,\n         18, 19, 20, 22, 23, 26, 27, 28, 29, 30, 31, 32]])\n\nfrom torch_geometric.utils import to_networkx\n\nG = to_networkx(data, to_undirected=True)\nvisualize_graph(G, color=data.y)"
  },
  {
    "objectID": "Bipartite_GNN.html#unipartite-gnn",
    "href": "Bipartite_GNN.html#unipartite-gnn",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "2 Unipartite GNN",
    "text": "2 Unipartite GNN\nWe create the architecture of the GNN for a unipartite graph. The architecture is made of a list of graph convolutional layers (GCL, chosen among a list of possible types of convolutions) and a MLP as last layer, which performs the learning task (node classification here). All the layers are followed by an activation function.\nPossible types of graph convolutional layers\nThe init size of the first layer is the number of features and the output size of the last layer depends on the learning task.\nEach GCL is defined as a function of two parameters : input size and output size. When defining the forward function, the GCL is called with two input parameters : x and edge_index.\nWe show the embedding (after the GCLs and before the MLP) after one pass forward to control that no error occurs.\n\nfrom torch.nn import Linear\nfrom torch_geometric.nn import GCNConv\n\nclass GCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GCNConv(dataset.num_features, 4) # num_features here is 34 (because of identity matrix), but can be 1 (for example with degree of nodes)\n        self.conv2 = GCNConv(4, 4)\n        self.conv3 = GCNConv(4, 2)\n        self.classifier = Linear(2, dataset.num_classes)\n\n    def forward(self, x, edge_index): # here the two objects needed by pytorch_geometric\n        h = self.conv1(x, edge_index)\n        h = h.tanh()\n        h = self.conv2(h, edge_index)\n        h = h.tanh()\n        h = self.conv3(h, edge_index)\n        h = h.tanh()  # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out = self.classifier(h)\n\n        return out, h\n\nmodel = GCN()\nprint(model)\n\nGCN(\n  (conv1): GCNConv(34, 4)\n  (conv2): GCNConv(4, 4)\n  (conv3): GCNConv(4, 2)\n  (classifier): Linear(in_features=2, out_features=4, bias=True)\n)\n\n_, h = model(data.x, data.edge_index)\nprint(f'Embedding shape: {list(h.shape)}')\n\nEmbedding shape: [34, 2]\n\nvisualize_embedding(h, color=data.y)\n\n\n\n\n\n\n\n\nWe then train the model with using the classical pytorch workflow defining a loss (here Cross Entropy), an optimizer (here Adam) and the number of epochs (here 151). We show the embedding every 50 epochs.\n\nimport time\n\n# Exactly the same as in torch\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion --&gt; for classification.\noptimizer = torch.optim.Adam(model.parameters(), lr=0.01)  # Define optimizer.\n\ndef train(data):\n    optimizer.zero_grad()  # Clear gradients.\n    out, h = model(data.x, data.edge_index)  # Perform a single forward pass.\n    loss = criterion(out[data.train_mask], data.y[data.train_mask])  # Compute the loss solely based on the training nodes.\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss, h\n\nfor epoch in range(151):\n    loss, h = train(data)\n    if epoch % 50 == 0:\n        visualize_embedding(h, color=data.y, epoch=epoch, loss=loss)\n        time.sleep(0.3)"
  },
  {
    "objectID": "Bipartite_GNN.html#bipartite-gnn",
    "href": "Bipartite_GNN.html#bipartite-gnn",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "3 Bipartite GNN",
    "text": "3 Bipartite GNN\nTu generalize GNN to bipartite graphs, we first need to define the type of data as BipartiteData which inherits from Data. The two types of nodes will be called source nodes and target nodes. The new object creates the source nodes and target nodes with their respective features (x_s and x_t), possibly different in size. The 2 rows in edges_index correspond to the source and target nodes, respectively.\n\nfrom torch_geometric.data import Data\nfrom torch_geometric.loader import DataLoader\nfrom torch_geometric.nn import SAGEConv\n\nclass BipartiteData(Data):\n    def __inc__(self, key, value, *args, **kwargs):\n        if key == 'edge_index':\n            return torch.tensor([[self.x_s.size(0)], [self.x_t.size(0)]])  # source and target (two classes of bipartite graph)\n        return super().__inc__(key, value, *args, **kwargs)\n\n\nx_s = torch.randn(2, 4)  # 2 nodes, 4 features.\nx_t = torch.randn(3, 2)  # 3 nodes, 2 features.\n\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index)\n\n# Plot of graph\nedge_list = list(zip(edge_index[0].tolist(),(edge_index[1]+1+max(edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n\n\n\n\n\n\n\n\nThe convolution layer is directed, hence it must be defined with the tuple of feature size of source and target nodes and the size of output of the layer, which will be given as new features to the nodes of the target.\nWe call the function with the tuple of features (x_s, x_t) and the `edge_index`.\nTo perform the inverse convolution from the target nodes to the source nodes, we must invert the values of the tuple but also invert the rows in the `edge_index`.\nOnly some of the GCLs are adapted to this configuration (look at the cheatsheet).\n\n# Direct and inverse convolutions\nConv_s_t = SAGEConv((4,2),7) # num of features is the tuple (s,t) and output is the num of features of target\n\nprint(Conv_s_t((x_s,x_t),edge_index))\n\ntensor([[ 0.5198,  0.5703,  0.6759,  0.1716, -0.6514,  0.0479, -0.5577],\n        [-0.0901,  1.5395,  0.3465,  0.0784, -1.5599,  1.1494, -0.5391],\n        [-1.0943,  0.7638,  0.2591,  0.4076, -0.5398,  0.6612, -2.2322]],\n       grad_fn=&lt;AddBackward0&gt;)\n\nConv_t_s = SAGEConv((2,4),7,aggr = \"max\")\nprint(Conv_t_s((x_t,x_s),edge_index[[1,0]])) # I need to invert the order of edge_index\n\ntensor([[-0.4040,  0.4052, -0.1868,  0.9336,  0.0030,  0.6546,  1.0335],\n        [ 0.5958, -0.1849,  0.2907,  1.4262, -0.9557,  0.4383,  0.6614]],\n       grad_fn=&lt;AddBackward0&gt;)\n\n\n\n3.1 Case study\nLatent Block Model for classification task\nTwo groups in sources, two groups in targets, with corresponding probability of connection.\nEach node has two features: 1 and its degree.\n\nn1= 25\nn2 = 50 \n\nW1 = np.random.randint(2,size=n1)\nW2 = np.random.randint(2,size=n2)\nP = np.array([[0.9,0.8],[0.5,0.1]])\nM = P[:,W2][W1,:]\n\nm = np.random.binomial(1, M)\nplt.imshow(m[np.argsort(W1),:][:,np.argsort(W2)],cmap=\"gray_r\")\n\n&lt;matplotlib.image.AxesImage object at 0x7f1d415222f0&gt;\n\nedge_index = torch.LongTensor(([np.where(m)[0],np.where(m)[1]]))\n\n&lt;string&gt;:2: UserWarning: Creating a tensor from a list of numpy.ndarrays is extremely slow. Please consider converting the list to a single numpy.ndarray with numpy.array() before converting to a tensor. (Triggered internally at ../torch/csrc/utils/tensor_new.cpp:278.)\n\n\n# 1 (to count for how many neighbors) + degree  (random choice, but good when we have no other information on the network)\n\nx_s = torch.Tensor(m.sum(1).reshape(-1,1))\nx_s = torch.concat((x_s,torch.ones(x_s.shape[0],1)),1)\nx_t = torch.Tensor(m.sum(0).reshape(-1,1))\nx_t = torch.concat((x_t,torch.ones(x_t.shape[0],1)),1)\n\ndata = Data(x_s=x_s, x_t=x_t, edge_index=edge_index)\n\n\n\n\n\n\n\n\nWe define an architecture for the bipartite GNN.\n\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = SAGEConv((x_s.shape[1],x_t.shape[1]),5) \n        self.conv2 = SAGEConv((x_t.shape[1],x_s.shape[1]),10)\n        \n        self.conv3 = SAGEConv((5,10), 4)\n        self.conv4 = SAGEConv((10,5), 4) \n\n        self.classifier1 = Linear(4,2)\n        self.classifier2 = Linear(4,2)\n\n    def forward(self, x, edge_index):\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) #n2 x 5\n        h1 = h1.tanh()\n        \n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]]) #n1 x 10 # invert edge_index for the inverse convolution\n        h2 = h2.tanh()\n        \n        h3 = self.conv3((h1,h2), edge_index[[1,0]])  #n1 x 4\n        h3_2 = h3.tanh()\n        \n        h4 = self.conv4((h2,h1), edge_index) #n2 x 4\n        h4_2 = h4.tanh() # Final GNN embedding space.\n        \n        # Apply a final (linear) classifier.\n        out1 = self.classifier1(h3_2) #n1 x 4\n        out2 = self.classifier2(h4_2) #n2 x 4\n\n        return out1,out2, h3,h4\n\nBGCN1 = BGCN()\nout1,out2, h3,h4= BGCN1((x_s,x_t),edge_index) \n\nH =torch.concat([h3,h4])\ncolor0 = np.concatenate([W1,W2+2])\n\nvisualize_embedding(H, color=color0)\n\n\n\n\n\n\n\n\nWe train the model as above and print the AUC for the classes of sources and targets.\n\nimport time\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\ncriterion = torch.nn.CrossEntropyLoss()  # Define loss criterion.\noptimizer = torch.optim.Adam(BGCN1.parameters(), lr=0.01)  # Define optimizer.\n\ntrain_mask,test_mask = train_test_split(np.arange(n1),test_size = 0.2,stratify = W1)\ntrain_mask2,test_mask2 = train_test_split(np.arange(n2),test_size = 0.2,stratify = W2)\n\ndef train():\n    optimizer.zero_grad()  # Clear gradients.\n    out1,out2, h3,h4= BGCN1((x_s,x_t),edge_index)  # Perform a single forward pass.\n    loss1 = criterion(out1[train_mask], torch.LongTensor(W1)[train_mask])  # Compute the loss solely based on the training nodes.\n    loss2 = criterion(out2[train_mask2], torch.LongTensor(W2)[train_mask2])\n    loss = loss1+loss2\n    loss.backward()  # Derive gradients.\n    optimizer.step()  # Update parameters based on gradients.\n    return loss,out1,out2, h3,h4\n\nfor epoch in range(101):\n    loss,out1,out2, h3,h4 = train()\n    if epoch % 50 == 0:\n        H =torch.concat([h3,h4])\n        color0 = np.concatenate([W1,W2+2])\n        visualize_embedding(H, color=color0, epoch=epoch, loss=loss)\n        time.sleep(0.3)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ny_pred1 = out1[test_mask].argmax(1).detach().numpy()\ny_pred2 = out2[test_mask2].argmax(1).detach().numpy()\nprint(\"AUC 1 : \",roc_auc_score(W1[test_mask],y_pred1))\n\nAUC 1 :  1.0\n\nprint(\"AUC 2 : \",roc_auc_score(W2[test_mask2],y_pred2))\n\nAUC 2 :  1.0"
  },
  {
    "objectID": "Bipartite_GNN.html#mini-batches-for-pooling-operation-in-gnns",
    "href": "Bipartite_GNN.html#mini-batches-for-pooling-operation-in-gnns",
    "title": "Graph Neural Networks for bipartite graphs with pytorch_geometric",
    "section": "4 Mini-batches for pooling operation in GNNs",
    "text": "4 Mini-batches for pooling operation in GNNs\nThe function DataLoader called with a list of graphs and the parameter batch_size creates a new UNCONNECTED graph with the as many different graphs as given in batch_size.\nOften, it is useful to be able to distinguish nodes from one graph to the other for different objectives such as graph classification. To keep track of which nodes belong to which graph, we can use batch.batch, that returns a vector of indices pairing each target node to its graph.\n\nfrom torch_geometric.nn import  pool\nfrom torch_geometric.loader import DataLoader\n\nx_s = torch.randn(2, 16)  # 2 nodes.\nx_t = torch.randn(3, 10)  # 3 nodes.\nedge_index = torch.tensor([\n    [0, 0, 1, 1],\n    [0, 1, 1, 2],\n])\n\ndata = BipartiteData(x_s=x_s, x_t=x_t, edge_index=edge_index,num_nodes = x_t.shape[0])\n    \ndata_list = [data, data, data, data, data, data] # 6 identical graphs (but can be different in size, features, ...\nloader = DataLoader(data_list, batch_size=3) # the dataloader creates a new UNCONNECTED graph with the 3 different graphs\nbatch = next(iter(loader))\n\nprint(\"batch \", batch)\n\nbatch  BipartiteDataBatch(edge_index=[2, 12], x_s=[6, 16], x_t=[9, 10], num_nodes=9, batch=[9], ptr=[4])\n\nprint(\"edge_index \", batch.edge_index)\n\nedge_index  tensor([[0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5],\n        [0, 1, 1, 2, 3, 4, 4, 5, 6, 7, 7, 8]])\n\nprint(\"node index \", batch.batch) # these are batches for target nodes (ONLY), vector of indexes\n\nnode index  tensor([0, 0, 0, 1, 1, 1, 2, 2, 2])\n\n\n\nedge_list = list(zip(batch.edge_index[0].tolist(),(batch.edge_index[1]+1+max(batch.edge_index[0])).tolist()))\nG=nx.from_edgelist(edge_list)\n\nnx.draw_networkx(G, pos=nx.bipartite_layout(G,batch.edge_index[0].tolist(),aspect_ratio=2), with_labels=False)\n\n\n\n\n\n\n\n\nIf we want to pair also the source nodes, we can use the following code.\n\n# code for creating batches for source nodes, vector of indexes\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nprint(pool.global_add_pool(batch.x_t,batch.batch).shape)\n\ntorch.Size([3, 10])\n\nprint(pool.global_add_pool(batch.x_s,batch_s).shape)\n\ntorch.Size([3, 16])\n\n\n\n4.1 Real case study\nData are a list of interactions between plants and insects collected from different studies. We also know how data were collected for each study : Transect or Timed observation. This information is encoded in the boolean TO (= 1 for Timed observation). The objective is to retrieve the variable TO from the networks (graph classification).\n\n#%% Exemple on real dataset\nimport pandas as pandas\nfrom sknetwork.data import from_edge_list\nfrom torch_geometric.utils import degree\nfrom sklearn.model_selection import train_test_split\n\nNetworks = pandas.read_csv(\"Interaction data Mael.txt\", encoding=\"latin-1\",sep=\"\\t\")\nNetworks[\"plant\"] = Networks['plantgenus'] + \"_\"+ Networks['plantspecies']\nNetworks[\"insects\"] = Networks[\"insectgenus\"]+ \"_\"+ Networks[\"insectspecies\"]\n\nsupinfo = pandas.read_excel(\"supinfo.xlsx\",1)\n#torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values*1)\n\ndata_list = []\nid_network_aggreg= Networks[\"id_network_aggreg\"].unique()\nfor k in id_network_aggreg:\n    Networks2 =Networks[[\"plant\",\"insects\"]][Networks[\"id_network_aggreg\"]==k]\n    graph = from_edge_list(edge_list=list(Networks2.itertuples(index=False)),bipartite=True)\n    biadjacency = graph.biadjacency.tocoo()\n    edge_index = torch.LongTensor([graph.biadjacency.tocoo().row,graph.biadjacency.tocoo().col])\n    TO =  torch.Tensor((supinfo[supinfo[\"Idweb\"]==k][\"Sampling_type\"]==\"TO\").values)*1\n    \n    # we can add arguments in the function to add for example the class of the graph\n    data = BipartiteData(x_s=degree(edge_index[0],num_nodes=biadjacency.shape[0]).reshape(-1,1),\n                         x_t=degree(edge_index[1],num_nodes=biadjacency.shape[1]).reshape(-1,1),\n                         edge_index=edge_index,\n                         TO = TO,\n                         num_nodes =biadjacency.shape[1] ) # number of tartet nodes\n    data_list.append(data)\n\n\nprint(data_list[0])\n\nBipartiteData(edge_index=[2, 544], x_s=[131, 1], x_t=[113, 1], TO=[1], num_nodes=113)\n\nprint(\"data_list len : \", len(data_list))\n\ndata_list len :  123\n\n\nWe define the model architecture. Poolings layers are described here.\nWe add a pooling layer between the CGLs and the MLP in order to agregate the features from target nodes belonging to the same graph in one feature vector for each graph.\nThe pooling is made thanks to the indices vector batch.batch.\n\nfrom torch_geometric.nn import GATConv\n\nclass BGCN(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        torch.manual_seed(1234)\n        self.conv1 = GATConv((1,1),5)\n        self.conv2 = SAGEConv((1,1),10)\n        self.conv3 = SAGEConv((self.conv2.out_channels,self.conv1.out_channels), 4)\n        \n        self.classifier1 = Linear(9,15) # 9 because 5 + 4 in the concatanation of h1 and h3\n        self.classifier2 = Linear(15,10)\n        self.classifier3 = Linear(10,1)\n        self.ReLU = torch.nn.ReLU()\n\n    def forward(self, x, edge_index,batch): #  batch is given here as input\n        x_1,x_2 = x\n        h1 = self.conv1((x_1,x_2), edge_index) \n        h1 = h1.tanh()\n        h2 = self.conv2((x_2,x_1), edge_index[[1,0]])\n        h2 = h2.tanh()\n        h3 = self.conv3((h2,h1), edge_index)\n\n        h4 = torch.concat([h1,h3],1) # concatenation in order to have only targets and use batch as indexes \n        \n        #H = pool.global_add_pool(h4,batch) ##Pooling layer ! \n        #H = pool.global_mean_pool(h4,batch)  \n        H = pool.global_max_pool(h4,batch)  # the pooling is made graph after graph (thanks to the argument batch) \n        \n         \n        H1 = self.classifier1(H)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier2(H1)\n        H1 = self.ReLU(H1)\n        H1 = self.classifier3(H1)\n        \n        H1 = torch.nn.Sigmoid()(H1)\n        \n        return H1\n    \n    \nloader = DataLoader(data_list, batch_size=10)\nbatch = next(iter(loader))\nprint(x_t.shape)\n\ntorch.Size([3, 10])\n\nprint(batch.batch.shape)\n\ntorch.Size([1355])\n\n\nBGCN2 = BGCN()\nbatch_s = torch.cat([torch.full((data.x_s.size(0),), i, dtype=torch.long) for i, data in enumerate(batch.to_data_list())])\n\nH=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch) # don't forget the argument batch.batch (on targets)\n\nWe train the model and show the AUC.\n\ny=[x.TO.item() for x in data_list]\ndata_train,data_test =train_test_split(data_list,stratify = y,test_size = 0.2,random_state=5)\n\nfrom tqdm import tqdm\nBGCN2 = BGCN()\ncriterion = torch.nn.BCELoss() # Binary Cross Entropy\noptimizer = torch.optim.Adam(BGCN2.parameters(), lr=0.01) # Define optimizer.\nloader = DataLoader(data_train, batch_size=10)\n\nloss_list = []\nfor K in tqdm(range(20)):\n    for batch in loader:\n        optimizer.zero_grad()  # Clear gradients.\n        H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)   # Perform a single forward pass.\n        loss = criterion(H,batch.TO.reshape(-1,1))\n        loss.backward() \n        optimizer.step()\n        loss_list.append(loss.item()) # Derive gradients.\n\n\n  0%|          | 0/20 [00:00&lt;?, ?it/s]\n 15%|#5        | 3/20 [00:00&lt;00:00, 21.10it/s]\n 30%|###       | 6/20 [00:00&lt;00:00, 21.33it/s]\n 45%|####5     | 9/20 [00:00&lt;00:00, 21.22it/s]\n 60%|######    | 12/20 [00:00&lt;00:00, 21.33it/s]\n 75%|#######5  | 15/20 [00:00&lt;00:00, 21.29it/s]\n 90%|######### | 18/20 [00:00&lt;00:00, 21.30it/s]\n100%|##########| 20/20 [00:00&lt;00:00, 21.31it/s]\n\nplt.plot(loss_list)\n\n[&lt;matplotlib.lines.Line2D object at 0x7f1d32a6ff40&gt;]\n\nloader_train = DataLoader(data_train, batch_size=len(data_train))\nfor batch in loader_train:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n    \nprint(\"AUC train \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n\nAUC train  0.7997448979591836\n\n    \nloader_test = DataLoader(data_test, batch_size=len(data_test))\nfor batch in loader_test:\n    H=BGCN2((batch.x_s,batch.x_t),batch.edge_index,batch.batch)\n\nprint(\"AUC test \",roc_auc_score(batch.TO.numpy(),H.detach().numpy()))\n\nAUC test  0.6753246753246753"
  },
  {
    "objectID": "c_python.html",
    "href": "c_python.html",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "On propose dans ce tutoriel une méthode pour l’utilisation de code C / C++ depuis Python. Les ressources à ce sujet sont très nombreuses, aussi nous allons nous placer dans un cas un peu particulier et moins étudié, c’est à dire :\n\nNous découvrirons bazel comme outil de compilation.\nNous utiliserons la bibliothèque pybind11_bazel et plus précisément les objets PyCapsule de cette bibliothèque.\nNous ouvrirons la PyCapsule côté Python en la reconstruisant avec la bibliothèque ctypes.\n\nNote: Ces choix sont motivés par l’objectif à plus long terme d’étendre la bibliothèque JAX avec du code C / C++ personnel, non couvert dans ce tutoriel. Voir par exemple https://github.com/dfm/extending-jax pour l’ancienne pipeline. Depuis JAX 0.4.31 sortie le 29 juillet 2024, l’intégration d’appel à du code C / C++ perso a été simplifié par jax.extend.ffi, voir par exemple https://jax.readthedocs.io/en/latest/ffi.html.\n\n\n\nNous allons travailler dans un projet structuré tel que :\nc_python/\n|___bazel-bin/\n||______ ...\n|___bazel-c_python/\n||______ ...\n|___bazel-out/\n||______ ...\n|___bazel-testlogs/\n||______ ...\n|___lib/\n||______BUILD.bazel\n||______loop.cpp\n|___loop.py\n|___MODULE.bazel\n|___WORKSPACE.bazel\nNous allons détailler la création et le contenu de chacun des éléments de l’arborescence.\n\n\n\n\nNous avons besoin d’un environnement Python simple dont nous ne détaillons pas l’installation.\nPour les utilisateurs linux, bazelisk est l’approche la plus simple pour installer bazel.\npybind11_bazel fournira pybind11.\n\n\n\n\nSoit le fichier loop.cpp :\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;cmath&gt;\n\ntemplate &lt;typename T&gt;\nvoid loop_a_lot(const std::int64_t L, T* result) {\n    *result = 0;\n    for (int l1 = 0; l1 &lt; L; ++l1) {\n        for (int l2 = 0; l2 &lt; L; ++l2) {\n            for (int l3 = 0; l3 &lt; L; ++l3) {\n                for (int l4 = 0; l4 &lt; L; ++l4) {\n                    *result += exp(3.14);\n                }\n            }\n        }\n    }\n  }\n\npybind11::dict Registrations() {\n  pybind11::dict dict;\n  dict[\"loop_f32_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;float&gt;), \"loop_plain\");\n  dict[\"loop_f64_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;double&gt;), \"loop_plain\");\n  return dict;\n}\n\nPYBIND11_MODULE(pyloop, m) {   // please match the pybind_extension target name\n  m.def(\"registrations\", &Registrations); \n}\nLes premières lignes définissent la fonction loop_a_lot simpliste que nous voulons appeler depuis Python. La deuxième partie du code utilise la bibliothèque pybind11. Nous créons un module pyloop auquel on donne une fonction registrations qui retournera un dictionnaire avec deux entrées : une fonction loop_a_lot pour chacun des types float et double. Au détail près que nous encapsulons ces fonctions dans des PyCapsules, un object Python opaque, que Python ne semble pas être censé lire (…useful for C extension modules who need to pass an opaque value (as a void * pointer) through Python code to other C code… https://docs.python.org/3/c-api/capsule.html)\n\n\n\nNous donnons l’origine des règles de compilations bazel dans le fichier WORKSPACE.bazel :\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\nhttp_archive(\n  name = \"pybind11_bazel\",\n  strip_prefix = \"pybind11_bazel-2.12.0\",\n  urls = [\"https://github.com/pybind/pybind11_bazel/archive/refs/tags/v2.12.0.zip\"],\n)\n# We still require the pybind library.\nhttp_archive(\n  name = \"pybind11\",\n  build_file = \"@pybind11_bazel//:pybind11-BUILD.bazel\",\n  strip_prefix = \"pybind11-2.13.0\",\n  urls = [\"https://github.com/pybind/pybind11/archive/refs/tags/v2.13.0.zip\"],\n)\nMODULE.bazel contient :\nbazel_dep(name = \"rules_python\", version = \"0.33.2\")\nLe fichier BUILD.bazel utilise la règle pybind_extension de pybind11_bazel :\nload(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")\n\npybind_extension(\n    name = \"pyloop\", # please match the PYBIND MODULE NAME\n    srcs = [\"loop.cpp\"],\n)\nEn se plaçant à la racine du projet et en exécutant bazel build //lib:pyloop nous obtenons directement le module Python voulu. Toute la complexité de la compilation est cachée par bazel. On voit que l’appel à build crée les quatre fichiers bazel-bin, bazel-c_python, bazel-out et bazel-testlogs. En particulier, le module d’intêret se situe dans bazel-bin/lib/.\n\n\n\nNous allons maintenant ouvrir les PyCapsules que nous avons à disposition dans le module pyloop fraîchement compilé, avec l’aide de la bibliothèque ctypes.\n\nOn rappelle que nous nous imposons les PyCapsules car ce sont les objets que nous devons manipuler pour exposer des fonctions C / C++ à JAX (notre objectif futur !). Voir par exemple (https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html)[https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html].\nOn note d’emblée que la manipulation de PyCapsule dans Python est compliquée par rapport à d’autres méthodes par lesquelles nous pouvons exposer des objets C / C++ à Python avec pybind11 (voir les tutoriels dans https://github.com/tdegeus/pybind11_examples). En effet, ces objets ne semblent pas être voués à être utilisés dans Python. Ouvrir la capsule avec ctypes constitue néanmoins un bon exercice avec cette bibliothèque.\n\nimport sys\nsys.path.insert(0, 'bazel-bin/lib/')\n\nimport ctypes\nimport numpy as np\n\nimport pyloop\n\nregistrations = pyloop.registrations()\n\nloop_f32_plain_capsule = registrations[\"loop_f32_plain\"]\nloop_f64_plain_capsule = registrations[\"loop_f64_plain\"]\n\n# Following is adapted from https://stackoverflow.com/questions/59887319/python-c-extension-exposing-a-capsule-to-ctypes-in-order-to-use-third-party-c-co\nPyCapsule_GetPointer = ctypes.pythonapi.PyCapsule_GetPointer\nPyCapsule_GetPointer.restype = ctypes.c_void_p\nPyCapsule_GetPointer.argtypes = [ctypes.py_object, ctypes.c_char_p]\n\nloop_f32_plain_ptr = PyCapsule_GetPointer(loop_f32_plain_capsule, b\"loop_plain\")\nloop_f64_plain_ptr = PyCapsule_GetPointer(loop_f64_plain_capsule, b\"loop_plain\")\n\n# This defines the functions signature\nloop_f32_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_float))(loop_f32_plain_ptr)\n\nloop_f64_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_double))(loop_f64_plain_ptr)\n\nL = ctypes.c_int64(10)\n\nresult_f32 = ctypes.c_float()\nresult_f64 = ctypes.c_double()\n\nout_buf_f32 = ctypes.pointer(result_f32)\nout_buf_f64 = ctypes.pointer(result_f64)\n\nloop_f32_plain_fn_c(L, out_buf_f32)\nloop_f64_plain_fn_c(L, out_buf_f64)\n\n# Print the results\nprint(\"Result (float):\", result_f32.value)\nprint(\"Result (double):\", result_f64.value)\n    Result (float): 231057.875\n    Result (double): 231038.66858726053"
  },
  {
    "objectID": "c_python.html#objectifs",
    "href": "c_python.html#objectifs",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "On propose dans ce tutoriel une méthode pour l’utilisation de code C / C++ depuis Python. Les ressources à ce sujet sont très nombreuses, aussi nous allons nous placer dans un cas un peu particulier et moins étudié, c’est à dire :\n\nNous découvrirons bazel comme outil de compilation.\nNous utiliserons la bibliothèque pybind11_bazel et plus précisément les objets PyCapsule de cette bibliothèque.\nNous ouvrirons la PyCapsule côté Python en la reconstruisant avec la bibliothèque ctypes.\n\nNote: Ces choix sont motivés par l’objectif à plus long terme d’étendre la bibliothèque JAX avec du code C / C++ personnel, non couvert dans ce tutoriel. Voir par exemple https://github.com/dfm/extending-jax pour l’ancienne pipeline. Depuis JAX 0.4.31 sortie le 29 juillet 2024, l’intégration d’appel à du code C / C++ perso a été simplifié par jax.extend.ffi, voir par exemple https://jax.readthedocs.io/en/latest/ffi.html."
  },
  {
    "objectID": "c_python.html#arborescence-du-projet",
    "href": "c_python.html#arborescence-du-projet",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous allons travailler dans un projet structuré tel que :\nc_python/\n|___bazel-bin/\n||______ ...\n|___bazel-c_python/\n||______ ...\n|___bazel-out/\n||______ ...\n|___bazel-testlogs/\n||______ ...\n|___lib/\n||______BUILD.bazel\n||______loop.cpp\n|___loop.py\n|___MODULE.bazel\n|___WORKSPACE.bazel\nNous allons détailler la création et le contenu de chacun des éléments de l’arborescence."
  },
  {
    "objectID": "c_python.html#installations",
    "href": "c_python.html#installations",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous avons besoin d’un environnement Python simple dont nous ne détaillons pas l’installation.\nPour les utilisateurs linux, bazelisk est l’approche la plus simple pour installer bazel.\npybind11_bazel fournira pybind11."
  },
  {
    "objectID": "c_python.html#code-c",
    "href": "c_python.html#code-c",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Soit le fichier loop.cpp :\n#include &lt;pybind11/pybind11.h&gt;\n#include &lt;cstdint&gt;\n#include &lt;cmath&gt;\n\ntemplate &lt;typename T&gt;\nvoid loop_a_lot(const std::int64_t L, T* result) {\n    *result = 0;\n    for (int l1 = 0; l1 &lt; L; ++l1) {\n        for (int l2 = 0; l2 &lt; L; ++l2) {\n            for (int l3 = 0; l3 &lt; L; ++l3) {\n                for (int l4 = 0; l4 &lt; L; ++l4) {\n                    *result += exp(3.14);\n                }\n            }\n        }\n    }\n  }\n\npybind11::dict Registrations() {\n  pybind11::dict dict;\n  dict[\"loop_f32_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;float&gt;), \"loop_plain\");\n  dict[\"loop_f64_plain\"] = pybind11::capsule(reinterpret_cast&lt;void*&gt;(loop_a_lot&lt;double&gt;), \"loop_plain\");\n  return dict;\n}\n\nPYBIND11_MODULE(pyloop, m) {   // please match the pybind_extension target name\n  m.def(\"registrations\", &Registrations); \n}\nLes premières lignes définissent la fonction loop_a_lot simpliste que nous voulons appeler depuis Python. La deuxième partie du code utilise la bibliothèque pybind11. Nous créons un module pyloop auquel on donne une fonction registrations qui retournera un dictionnaire avec deux entrées : une fonction loop_a_lot pour chacun des types float et double. Au détail près que nous encapsulons ces fonctions dans des PyCapsules, un object Python opaque, que Python ne semble pas être censé lire (…useful for C extension modules who need to pass an opaque value (as a void * pointer) through Python code to other C code… https://docs.python.org/3/c-api/capsule.html)"
  },
  {
    "objectID": "c_python.html#compilation-en-un-module-accessible-depuis-python",
    "href": "c_python.html#compilation-en-un-module-accessible-depuis-python",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous donnons l’origine des règles de compilations bazel dans le fichier WORKSPACE.bazel :\nload(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\nhttp_archive(\n  name = \"pybind11_bazel\",\n  strip_prefix = \"pybind11_bazel-2.12.0\",\n  urls = [\"https://github.com/pybind/pybind11_bazel/archive/refs/tags/v2.12.0.zip\"],\n)\n# We still require the pybind library.\nhttp_archive(\n  name = \"pybind11\",\n  build_file = \"@pybind11_bazel//:pybind11-BUILD.bazel\",\n  strip_prefix = \"pybind11-2.13.0\",\n  urls = [\"https://github.com/pybind/pybind11/archive/refs/tags/v2.13.0.zip\"],\n)\nMODULE.bazel contient :\nbazel_dep(name = \"rules_python\", version = \"0.33.2\")\nLe fichier BUILD.bazel utilise la règle pybind_extension de pybind11_bazel :\nload(\"@pybind11_bazel//:build_defs.bzl\", \"pybind_extension\")\n\npybind_extension(\n    name = \"pyloop\", # please match the PYBIND MODULE NAME\n    srcs = [\"loop.cpp\"],\n)\nEn se plaçant à la racine du projet et en exécutant bazel build //lib:pyloop nous obtenons directement le module Python voulu. Toute la complexité de la compilation est cachée par bazel. On voit que l’appel à build crée les quatre fichiers bazel-bin, bazel-c_python, bazel-out et bazel-testlogs. En particulier, le module d’intêret se situe dans bazel-bin/lib/."
  },
  {
    "objectID": "c_python.html#code-python",
    "href": "c_python.html#code-python",
    "title": "Du C++ depuis Python",
    "section": "",
    "text": "Nous allons maintenant ouvrir les PyCapsules que nous avons à disposition dans le module pyloop fraîchement compilé, avec l’aide de la bibliothèque ctypes.\n\nOn rappelle que nous nous imposons les PyCapsules car ce sont les objets que nous devons manipuler pour exposer des fonctions C / C++ à JAX (notre objectif futur !). Voir par exemple (https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html)[https://jax.readthedocs.io/en/latest/_autosummary/jax.extend.ffi.register_ffi_target.html].\nOn note d’emblée que la manipulation de PyCapsule dans Python est compliquée par rapport à d’autres méthodes par lesquelles nous pouvons exposer des objets C / C++ à Python avec pybind11 (voir les tutoriels dans https://github.com/tdegeus/pybind11_examples). En effet, ces objets ne semblent pas être voués à être utilisés dans Python. Ouvrir la capsule avec ctypes constitue néanmoins un bon exercice avec cette bibliothèque.\n\nimport sys\nsys.path.insert(0, 'bazel-bin/lib/')\n\nimport ctypes\nimport numpy as np\n\nimport pyloop\n\nregistrations = pyloop.registrations()\n\nloop_f32_plain_capsule = registrations[\"loop_f32_plain\"]\nloop_f64_plain_capsule = registrations[\"loop_f64_plain\"]\n\n# Following is adapted from https://stackoverflow.com/questions/59887319/python-c-extension-exposing-a-capsule-to-ctypes-in-order-to-use-third-party-c-co\nPyCapsule_GetPointer = ctypes.pythonapi.PyCapsule_GetPointer\nPyCapsule_GetPointer.restype = ctypes.c_void_p\nPyCapsule_GetPointer.argtypes = [ctypes.py_object, ctypes.c_char_p]\n\nloop_f32_plain_ptr = PyCapsule_GetPointer(loop_f32_plain_capsule, b\"loop_plain\")\nloop_f64_plain_ptr = PyCapsule_GetPointer(loop_f64_plain_capsule, b\"loop_plain\")\n\n# This defines the functions signature\nloop_f32_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_float))(loop_f32_plain_ptr)\n\nloop_f64_plain_fn_c = ctypes.CFUNCTYPE(None, ctypes.c_int64,\n        ctypes.POINTER(ctypes.c_double))(loop_f64_plain_ptr)\n\nL = ctypes.c_int64(10)\n\nresult_f32 = ctypes.c_float()\nresult_f64 = ctypes.c_double()\n\nout_buf_f32 = ctypes.pointer(result_f32)\nout_buf_f64 = ctypes.pointer(result_f64)\n\nloop_f32_plain_fn_c(L, out_buf_f32)\nloop_f64_plain_fn_c(L, out_buf_f64)\n\n# Print the results\nprint(\"Result (float):\", result_f32.value)\nprint(\"Result (double):\", result_f64.value)\n    Result (float): 231057.875\n    Result (double): 231038.66858726053"
  },
  {
    "objectID": "01_nimble.html",
    "href": "01_nimble.html",
    "title": "Introduction to nimble",
    "section": "",
    "text": "library(compareMCMCs)\nlibrary(ggmcmc)\nlibrary(mvtnorm)\nlibrary(nimble)\nlibrary(nimbleHMC)\nlibrary(tidyverse)"
  },
  {
    "objectID": "01_nimble.html#toy-model",
    "href": "01_nimble.html#toy-model",
    "title": "Introduction to nimble",
    "section": "Toy model",
    "text": "Toy model\nWe observe a sample \\(Y_1,\\dots, Y_n\\) of i.i.d. random variables having a negative binomial distribution with parameter \\(p \\in [0, 1]\\) and \\(\\theta \\in \\mathbb{R}_+^*\\). Formally, for \\(i \\in \\lbrace 1,\\dots, n\\rbrace\\), and \\(k \\in \\mathbb{N}\\), we have that:\n\\[\n\\mathbb{P}\\left(Y_i = k \\vert p, \\theta\\right) = \\frac{\\Gamma(k + \\theta)}{k!\\Gamma(\\theta)}p^\\theta(1 - p)^k\\,.\n\\]\nLet’s simulate data from this model with \\(n = 100, p = 0.4\\) and \\(\\theta = 12\\):\n\nset.seed(123) # For reproducibility\ndata_ex1 &lt;- rnbinom(n = 100, prob = 0.4, size = 12)\n\nOur goal is to estimate \\(p\\) and \\(\\theta\\) from these observations, within a Bayesian framework. For this tutorial, we assume the following priors: \\[\\begin{align*}\n\\theta &\\sim \\mathcal{E}(0.1)\\,,\\\\\np &\\sim \\mathcal{U}\\left[0, 1\\right]\\,.\\\\\n\\end{align*}\\]"
  },
  {
    "objectID": "01_nimble.html#defining-a-negative-binomial-model-in-nimble",
    "href": "01_nimble.html#defining-a-negative-binomial-model-in-nimble",
    "title": "Introduction to nimble",
    "section": "Defining a negative binomial model in nimble",
    "text": "Defining a negative binomial model in nimble\nBasically, as in BUGSor JAGS, the user’s role is to write the way to simulate the data and to give the prior distributions of the unkown. This is done within the nimbleCode function. This function will typically need to use built-in distributions that can be seen in the native documentation. All random variables must be assigned using the ~ symbol while deterministic quantities are assigned using the &lt;- or = as in R. Overall, the syntax is quite similar to R.\n\ncode_neg_bin &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # PRIORS\n  prob ~ dunif(0, 1)\n  theta ~ dexp(0.1)\n})\n\nNote that in this code, nothing distinguishes observed data from unknown (or latent variables). The order of lines has no importance as everything will be compiled afterwards."
  },
  {
    "objectID": "01_nimble.html#defining-the-nimble-model",
    "href": "01_nimble.html#defining-the-nimble-model",
    "title": "Introduction to nimble",
    "section": "Defining the nimble model",
    "text": "Defining the nimble model\nNow that the code exists, we define the model. That’s here that data and constants will be provided. Typically, data are quantities which are considered as realizations of random variables in the code, while constants are not.\n\nmodel_neg_bin &lt;- nimbleModel(code = code_neg_bin, \n                             name = \"Negative binomial\", \n                             constants = list(n = length(data_ex1)),\n                             data = list(y = data_ex1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n\n\nNote that the code points that we did not give initial guesses (which would typically be starting points for MCMC sampling algorithms). We will do it in the sampling step."
  },
  {
    "objectID": "01_nimble.html#basic-mcmc-sampling",
    "href": "01_nimble.html#basic-mcmc-sampling",
    "title": "Introduction to nimble",
    "section": "Basic MCMC sampling",
    "text": "Basic MCMC sampling\nA direct way to proceed is to use the nimbleMCMC function that provides basic Metropolis Hastings within Gibbs sampling.\n\nposterior_samples_neg_bin &lt;- nimbleMCMC(model_neg_bin,\n                                        inits = list(prob = 0.5, theta = 1),\n                                        nchains = 2, # Number of independent chains \n                                        niter = 10000, # Number of it. per chain\n                                        thin = 10, # Thinning\n                                        nburnin = 1000) # Number of initial iterations discarded\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|"
  },
  {
    "objectID": "01_nimble.html#exploring-the-results",
    "href": "01_nimble.html#exploring-the-results",
    "title": "Introduction to nimble",
    "section": "Exploring the results",
    "text": "Exploring the results\nNow that we have performed MCMC sampling, we can access the results, which are lists (one element per chain) of matrices having \\(n_{\\text{iter}}\\) rows and \\(n_{\\text{parameters}}\\) columns.\n\nstr(posterior_samples_neg_bin)\n\nList of 2\n $ chain1: num [1:900, 1:2] 0.334 0.328 0.333 0.334 0.315 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n $ chain2: num [1:900, 1:2] 0.343 0.363 0.379 0.336 0.352 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n\n\nTo perform any post processing or plotting results, a bit of formatting must be done.\n\nformatted_results &lt;- imap_dfr(posterior_samples_neg_bin, \n                              function(x, nm){\n                                as.data.frame(x) %&gt;% \n                                  rowid_to_column(var = \"Iteration\") %&gt;% \n                                  mutate(Chain = str_remove(nm, \"chain\"))\n                              }) %&gt;% \n  pivot_longer(cols = -c(\"Iteration\", \"Chain\"),\n               names_to = \"Parameter\", \n               values_to = \"value\")\n\nWe can then perform usual plots.\n\nggplot(formatted_results) +\n  aes(x = Iteration,\n      y = value, color = Chain) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Sample ID\", y = \"Parameter value\", color = \"\")\n\n\n\n\n\n\n\n\n\nPackage for automatic formatting of results\nFor ggplotusers, the ggmcmc package provide useful tools for plots and formatting of MCMC outputs in R (not necessarily for the nimble package). This package is suited for any coda object, which is an historic format for MCMC outputs in R. We can specify during the sampling that we want outputs to be in coda.\n\nposterior_samples_neg_bin &lt;- nimbleMCMC(model_neg_bin, \n                                        nchains = 2, \n                                        niter = 10000, \n                                        thin = 10, \n                                        nburnin = 1000,\n                                        samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nWe can see that this modifies the type of output:\n\nstr(posterior_samples_neg_bin)\n\nList of 2\n $ chain1: 'mcmc' num [1:900, 1:2] 0.286 0.31 0.301 0.304 0.348 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n $ chain2: 'mcmc' num [1:900, 1:2] 0.398 0.412 0.419 0.429 0.433 ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:2] \"prob\" \"theta\"\n  ..- attr(*, \"mcpar\")= num [1:3] 1 900 1\n - attr(*, \"class\")= chr \"mcmc.list\"\n\n\nNow, we can use the ggsfunction which performs the post processing that we made above.\n\nformatted_results &lt;- ggs(posterior_samples_neg_bin)\nformatted_results # same as above\n\n# A tibble: 3,600 × 4\n   Iteration Chain Parameter value\n       &lt;int&gt; &lt;int&gt; &lt;fct&gt;     &lt;dbl&gt;\n 1         1     1 prob      0.286\n 2         2     1 prob      0.310\n 3         3     1 prob      0.301\n 4         4     1 prob      0.304\n 5         5     1 prob      0.348\n 6         6     1 prob      0.325\n 7         7     1 prob      0.308\n 8         8     1 prob      0.346\n 9         9     1 prob      0.358\n10        10     1 prob      0.383\n# ℹ 3,590 more rows\n\n\nThen, everything works as before!."
  },
  {
    "objectID": "01_nimble.html#defining-a-nimblefunction",
    "href": "01_nimble.html#defining-a-nimblefunction",
    "title": "Introduction to nimble",
    "section": "Defining a nimbleFunction",
    "text": "Defining a nimbleFunction\nWhat makes nimble’s popularity is it suitability for statistical programming.\nAs your specific model will certainly requires specific functions, we cannot expect to find all our tools in the built-in function.\nHowever, we can define new functions in a syntax which is pretty similar to R.\n\nAlternative parameterization of the negative binomial\nSuppose now we want to perform negative binomial regression. In this context, we model the expectation (typically through a link to some covariates) of the response variable. Typically, if we denote, for all \\(1\\leq i \\leq n\\), \\(\\mu = \\mathbb{E}\\left[Y_i\\right]\\), we assume the following prior:\n\\[\n\\ln \\mu \\sim \\mathcal{N}\\left(0, 1\\right)\\,.\n\\] Sadly, in nimble, we do not have access to an implementation of the negative binomial distribution parameterized by \\((\\mu,  \\theta)\\). However, we know that: \\[\n\\mu = \\theta \\times \\frac{1 - p}{p}\\,,\n\\] or, equivalently, that: \\[\np = \\frac{\\theta}{\\theta + \\mu}\n\\]\n\nget_p_from_mu &lt;- nimbleFunction(\n  run = function(mu = double(0),\n                 theta = double(0)) { # type declarations\n    returnType(double(0))  # return type declaration\n    output &lt;- theta / (theta + mu)\n    return(output)\n  })\nget_p_from_mu(18, 12) # Works as a usual R function\n\n[1] 0.4\n\n\n\ncode_alternatif &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dnbinom(prob, theta)\n  }\n  # Alternative vectorized formulation \n  # y[1:n] ~ dnbinom(prob, theta)\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  theta ~ dexp(0.1)\n  # Quantites deterministes\n  mu &lt;- exp(log_mu)\n  prob &lt;- get_p_from_mu(mu = mu, theta = theta)\n})\n\nmodel_alternatif &lt;- nimbleModel(code = code_alternatif, \n                                name = \"Alternative negative binomial\", \n                                constants = list(n = length(data_ex1)),\n                                data = list(y = data_ex1),\n                                inits = list(mu = 0.5, theta = 1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n  [Note] This model is not fully initialized. This is not an error.\n         To see which variables are not initialized, use model$initializeInfo().\n         For more information on model initialization, see help(modelInitialization).\n\nposterior_samples_alternatif &lt;- nimbleMCMC(model_alternatif, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000,\n                                           monitors = c(\"prob\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|"
  },
  {
    "objectID": "01_nimble.html#defining-new-distribution",
    "href": "01_nimble.html#defining-new-distribution",
    "title": "Introduction to nimble",
    "section": "Defining new distribution",
    "text": "Defining new distribution\nAn alternative is to define a new distribution.\n\ndmynegbin &lt;- nimbleFunction(\n  run = function(x = double(0), \n                 mu = double(0),\n                 theta = double(0),\n                 log = integer(0, default = 0)) {\n    returnType(double(0))\n    prob = get_p_from_mu(mu, theta)\n    output &lt;- dnbinom(x, size = theta, prob = prob, log = log)\n    return(output)\n  })\nregisterDistributions(list(\n  dmynegbin = list(BUGSdist = \"dmynegbin(mu, theta)\",\n                   discrete = TRUE, pqAvail = FALSE)\n))\n\n  [Warning] Random generation function for dmynegbin is not available. NIMBLE is generating a placeholder function, rmynegbin, that will invoke an error if an algorithm needs to simulate from this distribution. Some algorithms (such as random-walk Metropolis MCMC sampling) will work without the ability to simulate from the distribution.  If simulation is needed, provide a nimbleFunction (with no setup code) to do it.\n\n\n\ncode_with_my_dist &lt;- nimbleCode({\n  # Observation model\n  for(i in 1:n){# n is never defined before, it will be a constant\n    y[i] ~ dmynegbin(mu, theta) # my distribution\n  }\n  # PRIORS\n  log_mu ~ dnorm(0, 1)\n  mu &lt;- exp(log_mu)\n  theta ~ dexp(0.1)\n})\n\nmodel_with_my_dist &lt;- nimbleModel(code = code_with_my_dist, \n                                  name = \"Alternative negative binomial\", \n                                  constants = list(n = length(data_ex1)),\n                                  data = list(y = data_ex1),\n                                  inits = list(log_mu = 0.5, theta = 1))\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\ncompileNimble(model_with_my_dist)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nDerived CmodelBaseClass created by buildModelInterface for model Alternative negative binomial\n\nposterior_samples_alternatif &lt;- nimbleMCMC(model_with_my_dist, \n                                           nchains = 2, \n                                           niter = 10000, \n                                           thin = 10, \n                                           nburnin = 1000, \n                                           monitors = c(\"mu\", \"theta\"),\n                                           samplesAsCodaMCMC = TRUE)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\n\nposterior_samples_alternatif %&gt;% \n  ggs() %&gt;% \n  ggplot() +\n  aes(x = Iteration,\n      y = value, color = factor(Chain)) +\n  facet_wrap(~Parameter, scales = \"free\") +\n  geom_line() +\n  labs(x = \"Iteration\", y = \"Parameter value\", color = \"\")"
  },
  {
    "objectID": "01_nimble.html#alternative-mcmc-sampler",
    "href": "01_nimble.html#alternative-mcmc-sampler",
    "title": "Introduction to nimble",
    "section": "Alternative MCMC sampler",
    "text": "Alternative MCMC sampler\nOne big strength of nimble are the several samplers that are available in the package."
  },
  {
    "objectID": "01_nimble.html#conjuguate-priors",
    "href": "01_nimble.html#conjuguate-priors",
    "title": "Introduction to nimble",
    "section": "Conjuguate priors",
    "text": "Conjuguate priors\nFirst, nimble is able to identify conjugate priors and make the exact computation of the posterior link."
  },
  {
    "objectID": "01_nimble.html#hmc-algorithm",
    "href": "01_nimble.html#hmc-algorithm",
    "title": "Introduction to nimble",
    "section": "HMC algorithm",
    "text": "HMC algorithm\nnimble provides support for Hamiltonian Monte Carlo (HMC) and compute the derivatives of the likelihood through automatic differentiation. The nimbleHMC package implement two versions of No-U-Turn (NUTS) HMC sampling: the standard one developed in Hoffman and Gelman (link) and an updated one with improved adaptation routines and convergence criteria, which matches the HMC sampler of STAN.\nIn order to allow an algorithm to use AD for a specific model, that model must be created with buildDerivs = TRUE.\n\n# Build model with nimble\nmodel_neg_bin_HMC &lt;- nimbleModel(code = code_neg_bin, \n                                 name = \"Negative binomial\", \n                                 constants = list(n = length(data_ex1)),\n                                 data = list(y = data_ex1),\n                                 inits = list(prob = 0.5, theta = 1),\n                                 calculate = FALSE, buildDerivs = TRUE) # This is the line required for running HMC\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nChecking model sizes and dimensions\n\nC_model_neg_bin_HMC &lt;- compileNimble(model_neg_bin_HMC) # Compile the model (they require this for the compilation of the HMC object)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n# Build the MCMC algorithm which applies HMC sampling\nHMC &lt;- buildHMC(C_model_neg_bin_HMC)\n\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nNUTS sampler (1)\n  - prob, theta \n\n# Careful here, when the model has random effects\n# HMC requires to set values in the model before running the algorithm\n# One solution is to simulate with the model and set the model with these values\n# See : https://r-nimble.org/html_manual/cha-mcmc.html#subsec:HMC-example\n# Here, as the model is simple, there is no need for this and everything is handled withing nimble/nimbleHMC\n\n## Then everything is standard in nimble\nCHMC &lt;- compileNimble(HMC) # Compile the HMC model/algo\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\nsamples &lt;- runMCMC(CHMC, niter = 1000, nburnin = 500) # Short run for illustration\n\nrunning chain 1...\n\n\n  [Note] NUTS sampler (nodes: prob, theta) is using 500 warmup iterations.\n         Since `warmupMode` is 'default' and `nburnin` &gt; 0,\n         the number of warmup iterations is equal to `nburnin`.\n         The burnin samples will be discarded, and all samples returned will be post-warmup.\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nsummary(coda::as.mcmc(samples)) # Summary of the estimates\n\n\nIterations = 1:500\nThinning interval = 1 \nNumber of chains = 1 \nSample size per chain = 500 \n\n1. Empirical mean and standard deviation for each variable,\n   plus standard error of the mean:\n\n         Mean      SD Naive SE Time-series SE\nprob   0.3714 0.04763  0.00213       0.005035\ntheta 10.9433 2.20934  0.09880       0.232706\n\n2. Quantiles for each variable:\n\n       2.5%    25%     50%     75%   97.5%\nprob  0.284 0.3349  0.3756  0.4048  0.4671\ntheta 7.074 9.2270 10.7757 12.3756 15.7634\n\n\nAnd there are plenty of others samplers:\n\nParticle filters / sequential Monte Carlo and iterated filtering (package nimbleSMC)\nMonte Carlo Expectation Maximization (MCEM)\n\nSee link"
  },
  {
    "objectID": "01_nimble.html#the-laplace-approximation",
    "href": "01_nimble.html#the-laplace-approximation",
    "title": "Introduction to nimble",
    "section": "The laplace approximation",
    "text": "The laplace approximation\nnimble also implements the Laplace approximation. But be careful, it performs maximum likelihood estimation. This is not the same as INLA (fully bayesian approach), but more like TMB (or glmmTMB- maximum likelihood estimation through Laplace approximation and automatic differentiation).\n\n# We need the derivatives to build the Laplace algorithm\n# so we take the object model_neg_bin_HMC built previously\nmodel_laplace &lt;- buildLaplace(model_neg_bin_HMC)\nCmodel_laplace &lt;- compileNimble(model_laplace)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n# Get the Laplace approximation for one set of parameter values.\nCmodel_laplace$calcLaplace(c(0.5,0.5)) \n\n[1] -1499.737\n\n # Get the corresponding gradient.\nCmodel_laplace$gr_Laplace(c(0.5,0.5))\n\n[1] -3552.0000   409.7602\n\n# Search the (approximate) MLE\nMLE &lt;- Cmodel_laplace$findMLE(c(0.5,0.5)) # Find the (approximate) MLE.\nMLE$par\n\n[1]  0.366619 10.569421\n\n# Get log-likelihood value\nMLE$value\n\n[1] -333.2813\n\n# And output summaries\nCmodel_laplace$summary(MLE)\n\nnimbleList object of type AGHQuad_summary\nField \"params\":\nnimbleList object of type AGHQuad_params\nField \"names\":\n[1] \"prob\"  \"theta\"\nField \"estimates\":\n[1]  0.366619 10.569421\nField \"stdErrors\":\n[1] 0.05242939 2.35119020\nField \"randomEffects\":\nnimbleList object of type AGHQuad_params\nField \"names\":\ncharacter(0)\nField \"estimates\":\nnumeric(0)\nField \"stdErrors\":\nnumeric(0)\nField \"vcov\":\n&lt;0 x 0 matrix&gt;\nField \"scale\":\n[1] \"original\"\n\n\nN.b this example is only for illustration of the code. The Laplace approximation is relevant only when there are random effects in the model (which is not the case here).\nFor a full example see link"
  },
  {
    "objectID": "01_nimble.html#comparing-mcmc-algorithms",
    "href": "01_nimble.html#comparing-mcmc-algorithms",
    "title": "Introduction to nimble",
    "section": "Comparing MCMC algorithms",
    "text": "Comparing MCMC algorithms\nOne can compare several algorithms through the package compareMCMCs. It is possible to compare several algorithms internal to nimble with those from jags (or even STAN) algorithms. An example below for nimble and STAN.\n\n# This model code will be used for both nimble and JAGS\nmodelInfo &lt;- list(\n  code = code_neg_bin,\n  constants = list(n = length(data_ex1)),\n  data = list(y = data_ex1),\n  inits = list(prob = 0.5, theta = 1)\n)\n\n# Here is a custom MCMC configuration function for nimble\nconfigure_nimble_slice &lt;- function(model) {\n  configureMCMC(model, onlySlice = TRUE)\n}\n\n# Here is the call to compareMCMCs\nres &lt;- compareMCMCs(modelInfo,\n                    MCMCs = c('nimble',       # nimble with default samplers\n                              'nimble_slice' # nimble with slice samplers\n                              ),\n                    nimbleMCMCdefs = \n                      list(nimble_slice = 'configure_nimble_slice'),\n                    MCMCcontrol = list(inits = list(prob = 0.5, theta = 1),\n                                       niter = 10000,\n                                       burnin = 1000))\n\nbuilding nimble model...\n\n\nDefining model\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions\n\n\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nRW sampler (2)\n  - prob\n  - theta\n===== Monitors =====\nthin = 1: prob, theta\n===== Samplers =====\nslice sampler (2)\n  - prob\n  - theta\n\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\nmake_MCMC_comparison_pages(res, modelName = 'code_neg_bin',dir = \"/tmp/\",\n                           control = list(res = 75))\n\nLoading required namespace: xtable"
  },
  {
    "objectID": "01_nimble.html#data-generation",
    "href": "01_nimble.html#data-generation",
    "title": "Introduction to nimble",
    "section": "Data generation",
    "text": "Data generation\nWe consider a simple settings in dimension \\(p=5\\), with Toeplitz-like covariance.\n\nN &lt;- 100\np &lt;- 5\nd &lt;- 1:p\nDsqrt &lt;- diag(sqrt(d))\nSigma &lt;- Dsqrt %*% toeplitz(0.75^(0:(p-1))) %*% Dsqrt\nOmega &lt;- solve(Sigma)\nmu &lt;- 5 + 1:p\npi &lt;- c(0.25, 0, 0.8, 0.1, .5)\n\nHere are some data (100 points):\n\nW &lt;- t(replicate(N, rbinom(p, prob = pi, size = 1)))\nY &lt;- (1 - W) * rmvnorm(N, mu, Sigma)\nggplot(data.frame(y = c(Y))) + aes(x=y) + geom_histogram()"
  },
  {
    "objectID": "01_nimble.html#auxiliary-functions",
    "href": "01_nimble.html#auxiliary-functions",
    "title": "Introduction to nimble",
    "section": "Auxiliary functions",
    "text": "Auxiliary functions\nWe need some auxiliary nimble functions to handle the density and generation of the random binomial vector \\(W\\):\n\ndbinom_vector &lt;- nimbleFunction(\n  run = function( x = double(1),\n                  size = double(1),\n                  prob = double(1), \n                  log = integer(0, default = 0)\n  ) {\n    returnType(double(0))\n    logProb &lt;- sum(dbinom(x, prob = prob, size = size, log = TRUE))\n    if(log) return(logProb) else return(exp(logProb))\n  })\n\nrbinom_vector &lt;- nimbleFunction(\n  run = function( n = integer(0, default = 1),\n                  size = double(1),\n                  prob = double(1)\n  ) {\n    returnType(double(1))\n    return(rbinom(length(size), prob = prob, size = size))\n  })"
  },
  {
    "objectID": "01_nimble.html#nimble-code-and-model-for-zi-normal-v1",
    "href": "01_nimble.html#nimble-code-and-model-for-zi-normal-v1",
    "title": "Introduction to nimble",
    "section": "Nimble code and model for ZI-normal: V1",
    "text": "Nimble code and model for ZI-normal: V1\nRather than defining a probability density function for this model (which is in fact a bit complicated…), we adopt a generative approach:\n\nZInormal_code &lt;- nimbleCode({\n  \n  for (j in 1:p) {\n    mean[j] ~ dnorm(0,1)  \n  }\n  for (j in 1:p) {\n    zeroProb[j] ~ dunif(0,1)\n  }\n  \n  prec[1:p,1:p] ~ dwish(Ip[1:p,1:p], p)\n\n  for (i in 1:N) {\n    w[i, 1:p] ~ dbinom_vector(onep[1:p], zeroProb[1:p])\n    z[i, 1:p] ~ dmnorm(mean[1:p], prec[1:p,1:p])\n    ytilde[i, 1:p] &lt;- (1 - w[i,1:p]) * z[i,1:p]\n    ## P. Barbillon/M.-P. Étienne: astuce en zero \n    ## a.k.a \"I got a trick at zero\"\n    y[i, 1:p] ~ dmnorm(ytilde[i, 1:p], prec_inf[1:p,1:p])\n  }\n  \n})\n\nWe can now define the nimble model for the ZI-normal model. We give some sound intial values for the parameters and latent variable, define some constants and provide the data:\n\nZInormal_model &lt;- nimbleModel(\n  ZInormal_code, \n  constants = \n    list(N = N, p = p, Ip = diag(1,p,p),\n         onep = rep(1,p), prec_inf = diag(1e5,p,p)),\n  data = list(y = Y, w = W),\n  inits = list(mean = rep(5,p), prec = diag(1,p,p), zeroProb=rep(0.5,p), z = Y))\n\nDefining model\n\n\n  [Note] Registering 'dbinom_vector' as a distribution based on its use in BUGS code. If you make changes to the nimbleFunctions for the distribution, you must call 'deregisterDistributions' before using the distribution in BUGS code for those changes to take effect.\n\n\nBuilding model\n\n\nSetting data and initial values\n\n\nRunning calculate on model\n  [Note] Any error reports that follow may simply reflect missing values in model variables.\n\n\nChecking model sizes and dimensions"
  },
  {
    "objectID": "01_nimble.html#mcmc-estimation",
    "href": "01_nimble.html#mcmc-estimation",
    "title": "Introduction to nimble",
    "section": "MCMC estimation",
    "text": "MCMC estimation\nLet us run a simple 2-chain MCMC estimation\n\nmy_MCMC &lt;- nimbleMCMC(\n  ZInormal_model, \n  monitors = c(\"mean\", \"prec\", \"zeroProb\"),\n  nchains = 2, \n  niter = 1000, \n  samplesAsCodaMCMC = TRUE,\n  nburnin=100)\n\nCompiling\n  [Note] This may take a minute.\n  [Note] Use 'showCompilerOutput = TRUE' to see C++ compilation details.\n\n\nrunning chain 1...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\nrunning chain 2...\n\n\n|-------------|-------------|-------------|-------------|\n|-------------------------------------------------------|\n\n\n\n\n\n\n\nEstimation of the mean \\(\\mu\\)\n\n\n\n\n\nprint(mu)\n\n[1]  6  7  8  9 10\n\n\n\n\n\n\n\nEstimation of the zero inflation probabilities \\(\\pi\\)\n\n\n\n\n\nprint(pi)\n\n[1] 0.25 0.00 0.80 0.10 0.50\n\n\n\n\n\n\n\nEstimation of the precision matrix \\(\\Omega\\)\n\n\n\n\n\nprint(round(Omega,3))\n\n       [,1]   [,2]   [,3]   [,4]   [,5]\n[1,]  2.286 -1.212  0.000  0.000  0.000\n[2,] -1.212  1.786 -0.700  0.000  0.000\n[3,]  0.000 -0.700  1.190 -0.495  0.000\n[4,]  0.000  0.000 -0.495  0.893 -0.383\n[5,]  0.000  0.000  0.000 -0.383  0.457"
  },
  {
    "objectID": "instructions.html",
    "href": "instructions.html",
    "title": "Instructions pour le dépot sur le site web",
    "section": "",
    "text": "Protocole https :\ngit clone https://github.com/StateOfTheR/finistR2024.git\nAvec clés SSH : git clone git@github.com:git@github.com:StateOfTheR/finistR2024.git\n\n\n(Lien vers une doc complète)[https://docs.github.com/fr/get-started/getting-started-with-git/managing-remote-repositories]."
  },
  {
    "objectID": "instructions.html#cloner-le-dépôt-git-du-bootcamp",
    "href": "instructions.html#cloner-le-dépôt-git-du-bootcamp",
    "title": "Instructions pour le dépot sur le site web",
    "section": "",
    "text": "Protocole https :\ngit clone https://github.com/StateOfTheR/finistR2024.git\nAvec clés SSH : git clone git@github.com:git@github.com:StateOfTheR/finistR2024.git\n\n\n(Lien vers une doc complète)[https://docs.github.com/fr/get-started/getting-started-with-git/managing-remote-repositories]."
  },
  {
    "objectID": "instructions.html#processus-de-mise-en-commun-des-ateliers",
    "href": "instructions.html#processus-de-mise-en-commun-des-ateliers",
    "title": "Instructions pour le dépot sur le site web",
    "section": "Processus de mise en commun des ateliers",
    "text": "Processus de mise en commun des ateliers\n\nCréer une branche propre à l’atelier nommée explicitement mon_nom_parlant et basculer dessus\n\ngit checkout -b mon_nom_parlant\n\nCréer un fichier Rmarkdown de restitution de votre atelier fichier.Rmd dans votre branche\n\ngit add fichier.Rmd\ngit commit -m \"restitution atelier\"\n\nPousser vos modifications sur le serveur distant\n\ngit  push --set-upstream origin mon_nom_parlant ou\ngit  push\n\nFaire une pull request (PR) sur github\nindiquer dans le message de la PR la liste des packages ou autres besoins\nQuand la PR passe les tests, demander le merge.\ncorriger les erreurs éventuelles dans la compilation du Rmarkdown\nles admins peuvent avoir à mettre à jour l’image docker"
  },
  {
    "objectID": "instructions.html#détails-du-fonctionnement",
    "href": "instructions.html#détails-du-fonctionnement",
    "title": "Instructions pour le dépot sur le site web",
    "section": "Détails du fonctionnement",
    "text": "Détails du fonctionnement\n\nLe docker\n(Lien vers la fiche pense-bête)[https://www.docker.com/sites/default/files/d8/2019-09/docker-cheat-sheet.pdf]\nPour créer des images Docker en local sur sa machine, voici une liste de commandes utiles\n\nPour construire une image docker, il faut créer un fichier Dockerfile qui contient la recette du Docker. Pour ce site le ficher Dockerfile a la forme suivante\n\n\n\n\nFROM rocker/geospatial:4.4\nRUN export DEBIAN_FRONTEND=noninteractive; apt-get -y update \\\n && apt-get install -y pandoc \\\n    pandoc-citeproc\nRUN R -e \"install.packages('remotes')\"\nRUN R -e \"install.packages('microbenchmark')\"\nRUN R -e \"install.packages('purrr')\" # map function\nENV R_CRAN_WEB=\"https://cran.rstudio.com/\"\nRUN R -e \"install.packages('cowplot')\" # GET function\nRUN R -e \"install.packages('torch')\"\nRUN R -e \"torch::install_torch(type = 'cpu')\"\nRUN R -e \"install.packages('PLNmodels')\"\nRUN R -e \"install.packages('torchvision')\"\n\nRUN apt-get update \\\n && apt-get install -y --no-install-recommends \\\n  mercurial gdal-bin libgdal-dev gsl-bin libgsl-dev \\\n  libc6-i386\n\nRUN R -e \"install.packages('reticulate')\"\nRUN R -e \"install.packages(c('inlabru', 'lme4', 'ggpolypath', 'RColorBrewer', 'geoR'))\"\nRUN R -e \"install.packages(c('poissonreg'))\"\nRUN apt-get install -y --no-install-recommends unzip python3-pip dvipng pandoc wget git make python3-venv && \\\n    pip3 install jupyter jupyter-cache flatlatex matplotlib && \\\n    apt-get --purge -y remove texlive.\\*-doc$ && \\\n    apt-get clean\n\n\npuis demander la construction de l’image à l’aide de la commande\n\n docker build -t nom_depot_dockerhub/nom_du_repo:version  . ## avec un nom\n\net enfin pousser sur Dockerhub\n\n docker push nom_depot_dockerhub/nom_du_repo:version\n\n\n\nLes actions\nDans les action de Github, on peut spécifier un container docker à utiliser, c’est ce que fait la ligne container du fichier d’action suivant, utiliser pour créer ce site web\n\n\nname: website\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    name: Build website with rmarkdown\n    runs-on: ubuntu-latest\n    container: stateofther/r-finistr2024:0.1\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v2\n      - name: Additional R packages\n        run: |\n          Rscript -e \"install.packages(c('tictoc', 'nimble', 'ggmcmc', 'compareMCMCs', 'nimbleHMC', 'mvtnorm'))\"\n      - name: Additional Python packages\n        run: |\n          pip install torch torch_geometric \n          pip install numpy==1.26.1\n          pip install scikit-learn scikit-network networkx matplotlib tqdm openpyxl pandas\n      - name: Generate slides\n        run: \"quarto render\"\n      - name: GitHub Pages action\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./_site"
  },
  {
    "objectID": "shiny-deployment.html",
    "href": "shiny-deployment.html",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "besoin de déploiement d’appli shiny pour utilisation sans programmation\nsolution proposée par shinyapps.io: limitation à 25h/mois et 5 applications concurrentes pour la version gratuite, et 1Gb de RAM. Les étapes du déploiement sont illustrées dans la Section 1.6\nsolution proposée par Posit (anciennement par Shiny Server Pro): PositConnect: payant (cher)\nintérêt d’avoir une solution institutionnelle\n\n\n\n\n\n\nOutil\nInstitution\nRéférences\n\n\n\n\nplmshift\nCNRS\n\n\n\nSK8\nINRAE\nMaigné et al. (2023)\n\n\nShiny-K8s\nInstitut Pasteur\nBrancotte and Chapeaublanc (2024)\n\n\n\n\n\n\nCes trois outils sont dédiés au déploiement d’applications shiny via Kubernetes (aka K8s). Le développeur de l’application shiny doit fournir un dépôt git contenant le code source de l’application et spécifier les dépendances (via un fichier csv dédié pour shiny-K8s et plmshift, ou automatiquement via renv pour SK8).\n\n\n\nEtapes pour le déploiement d’une application shiny via SK8 (INRAE)\n\n\n\n\n\nC’est ici que les trois solutions se différencient:\n\nPour plmshift, on demande également au développeur de l’application de configurer et d’administrer lui-même son instance ShinyServer, via l’interface d’OpenShift. Ces étapes sont documentées ici\n\nIdem pour Shiny-K8s, avec (semble-t-il) moins de compétences techniques requises. Ces étapes sont documentées ici\nSK8 propose une interface simplifiée pour la configuration du serveur shiny, qui permet au développeur de l’application shiny spécifier directement les paramètres (RAM, CPU) sans avoir besoin de compétences en déploiement.\n\n\n\n\nplmshift, SK8 et Shiny-K8s sont respectivement accessibles seulement pour des projets développés par le CNRS, INRAE et l’Institut Pasteur.\nAujourd’hui, SK8 semble la solution la plus simple d’utilisation pour le développeur shiny. Les paramètres de configuration sont relativement proches de ceux demandés pour le dépoiements sur shinyapps.io (voir Section 1.6). Afin de rendre ce type d’outil accessible à d’autres institutions qu’’INRAE, on peut envisager soit l’ouverture d’un des services existants à ces institutions, soit la mise à disposition de ce type de service directement par chaque institution. Les deux solutions nécessitent des ressources matérielles et humaines; la première solution peut permettre des économies d’échelle mais peut poser des questions sur le partage des données de recherche entre institutions.\n\n\n\n\ncode d’une application démo pour déploiement avec shiny-K8s\nprésentation d’Elise Maigné aux rencontres R 2024\n\n\n\n\n\n\n\nVue d’ensemble\n\n\n\n\n\nConfiguration: paramètres de base\n\n\n\n\n\nConfiguration: paramètres avancés\n\n\n\n\n\nStatistiques d’utilisation"
  },
  {
    "objectID": "shiny-deployment.html#outils-institutionnels-existants",
    "href": "shiny-deployment.html#outils-institutionnels-existants",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Outil\nInstitution\nRéférences\n\n\n\n\nplmshift\nCNRS\n\n\n\nSK8\nINRAE\nMaigné et al. (2023)\n\n\nShiny-K8s\nInstitut Pasteur\nBrancotte and Chapeaublanc (2024)"
  },
  {
    "objectID": "shiny-deployment.html#préparation-de-lappli-au-déploiement",
    "href": "shiny-deployment.html#préparation-de-lappli-au-déploiement",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Ces trois outils sont dédiés au déploiement d’applications shiny via Kubernetes (aka K8s). Le développeur de l’application shiny doit fournir un dépôt git contenant le code source de l’application et spécifier les dépendances (via un fichier csv dédié pour shiny-K8s et plmshift, ou automatiquement via renv pour SK8).\n\n\n\nEtapes pour le déploiement d’une application shiny via SK8 (INRAE)"
  },
  {
    "objectID": "shiny-deployment.html#configuration-du-serveur-shiny",
    "href": "shiny-deployment.html#configuration-du-serveur-shiny",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "C’est ici que les trois solutions se différencient:\n\nPour plmshift, on demande également au développeur de l’application de configurer et d’administrer lui-même son instance ShinyServer, via l’interface d’OpenShift. Ces étapes sont documentées ici\n\nIdem pour Shiny-K8s, avec (semble-t-il) moins de compétences techniques requises. Ces étapes sont documentées ici\nSK8 propose une interface simplifiée pour la configuration du serveur shiny, qui permet au développeur de l’application shiny spécifier directement les paramètres (RAM, CPU) sans avoir besoin de compétences en déploiement."
  },
  {
    "objectID": "shiny-deployment.html#accessibilité",
    "href": "shiny-deployment.html#accessibilité",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "plmshift, SK8 et Shiny-K8s sont respectivement accessibles seulement pour des projets développés par le CNRS, INRAE et l’Institut Pasteur.\nAujourd’hui, SK8 semble la solution la plus simple d’utilisation pour le développeur shiny. Les paramètres de configuration sont relativement proches de ceux demandés pour le dépoiements sur shinyapps.io (voir Section 1.6). Afin de rendre ce type d’outil accessible à d’autres institutions qu’’INRAE, on peut envisager soit l’ouverture d’un des services existants à ces institutions, soit la mise à disposition de ce type de service directement par chaque institution. Les deux solutions nécessitent des ressources matérielles et humaines; la première solution peut permettre des économies d’échelle mais peut poser des questions sur le partage des données de recherche entre institutions."
  },
  {
    "objectID": "shiny-deployment.html#autres-ressources",
    "href": "shiny-deployment.html#autres-ressources",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "code d’une application démo pour déploiement avec shiny-K8s\nprésentation d’Elise Maigné aux rencontres R 2024"
  },
  {
    "objectID": "shiny-deployment.html#sec-shinyapps.io",
    "href": "shiny-deployment.html#sec-shinyapps.io",
    "title": "Solutions institutionnelles de déploiement d’applications shiny avec kubernetes",
    "section": "",
    "text": "Vue d’ensemble\n\n\n\n\n\nConfiguration: paramètres de base\n\n\n\n\n\nConfiguration: paramètres avancés\n\n\n\n\n\nStatistiques d’utilisation"
  },
  {
    "objectID": "Readme.html",
    "href": "Readme.html",
    "title": "Ateliers Finist’R 2024",
    "section": "",
    "text": "Ateliers Finist’R 2024\n\n\n\nwebsite\n\n\nL’atelier Finist’R 2024 – ou bootcamp R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et dévelopeurs de paquets pour explorer les dernières fonctionalités du logiciel et les nouvelles pratiques de développement. A l’issu de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLa restitution se fait sous forme de site web. Le site de l’édition 2024 sera disponible ici"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "",
    "text": "L’atelier Finist’R 2024 – ou bootcamp R du groupe State Of The R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nStateoftheR est un réseau du département MathNum INRAE.\n\n\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et développeurs de paquets pour explorer les dernières fonctionnalités du logiciel et les nouvelles pratiques de développement. A l’issue de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLe résultat de cette semaine est disponible sur cette page"
  },
  {
    "objectID": "index.html#où-quand",
    "href": "index.html#où-quand",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "",
    "text": "L’atelier Finist’R 2024 – ou bootcamp R du groupe State Of The R s’est déroulé à la station biologique de Roscoff du 19 au 23 août 2024.\nStateoftheR est un réseau du département MathNum INRAE.\n\n\nIl s’agit de la huitième édition de l’atelier Finist’R. Cet atelier réunit annuellement un groupe de chercheurs, ingénieurs, doctorants, tous utilisateurs avancés de R et développeurs de paquets pour explorer les dernières fonctionnalités du logiciel et les nouvelles pratiques de développement. A l’issue de l’atelier le collectif produit une synthèse de cette veille logiciel de manière à progresser collectivement dans l’utilisation du logiciel mais surtout dans la production d’outils statistiques à destination de la communauté.\nLe résultat de cette semaine est disponible sur cette page"
  },
  {
    "objectID": "index.html#programme",
    "href": "index.html#programme",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Programme",
    "text": "Programme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGroupe 1\nGroupe 2\nGroupe 3\nGroupe 4\nGroupe 5\nGroupe 6\n\n\n\n\n\n\nLundi Après midi\nDébut en Python\n{{Simulator}}\nGraphical Neural Network\nNimble\nCalling C++ from Python\n\n\n\n\n\nMardi Matin 1\nCours future\n\n\n\n\n\n\n\n\n\nMardi Matin 2\nPackaging/Testing\nJulia\nDiffusion\nNimble\n\n\n\n\n\n\nMardi Après midi\nPackaging/Testing\nJulia\nDiffusion\nNimble\n\n\n\n\n\n\nMercredi Matin 1\nCours future\n\n\n\n\n\n\n\n\n\nMercredi Matin 2\nRestitution\n\n\n\n\n\n\n\n\n\nJeudi Matin\n{{Rix}}\nShiny Dev\nEnergy and Optimisation\nPINNS\nCTView Network\nEnseignement\n\n\n\n\nJeudi Après Midi\n{{Rix}}\nShiny Dev\nEnergy and Optimisation\nPINNS\nCTView Network\nEnseignement\n\n\n\n\nVendredi Matin\nRestitution"
  },
  {
    "objectID": "index.html#participants",
    "href": "index.html#participants",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Participants",
    "text": "Participants\nBaptiste Alglave, Emré Anakok, Julie Aubert, Pierre Barbillon, Julien Chiquet, Lucia Clarotto, Caroline Cognot, Annaïg De Walsche, Sophie Donnet, Marie-Pierre Etienne, Armand Favrot, Hugo Gangloff, Pierre Gloaguen, Adeline Leclercq Samson, Tristan Mary-Huard, Cédric Midoux, Pierre Neuvial, Aymeric Stamm, Florian Teste, François Victor, Emily Walker."
  },
  {
    "objectID": "index.html#soutien",
    "href": "index.html#soutien",
    "title": "FinistR : bootcamp R à Roscoff",
    "section": "Soutien",
    "text": "Soutien"
  }
]